h45814
s 01316/00001/00000
d D 1.2 92/02/21 15:47:59 rous 2 1
c 
e
s 00001/00000/00000
d D 1.1 92/02/11 11:49:37 rous 1 0
c date and time created 92/02/11 11:49:37 by rous
e
u
U
f e 0
t
T
I 1
D 2
 
E 2
I 2
DUTCH 22

&
\newpage
\begin{verbatim}
%
% TRANSFORMATION SentenceOK0
< m1: CLAUSE{CLAUSErec1}
            [ mu1,
              predrel/VERBP{VERBPrec1}[I1:mu2],
              mu3 
            ]
>

< m : CLAUSE{CLAUSErec1}
            [ mu1,
              predrel/VERBP{VERBPrec1}[I1:mu2],
              mu3 
            ]
>

   MATCHCONDITIONS
      <
       I1: (NOT EXIST(mu2, [ complrel/SENTENCE{SENTENCErec1}[mu4]])) AND
           (NOT EXIST(mu2, [prepobjrel/PREPP{PREPPrec1}
                                 [mu5, objrel/SENTENCE{SENTENCErec1}[mu6], mu7]
                          ]
                     )                        
           )                                                     AND   
           (NOT EXIST(mu2, [predrel/ADJP{}[I11:mu8]]))
           I11: EXIST(mu8,[complrel/SENTENCE{}[mu9]])

      >
      COMP
         <
          C1:true
          A1:@
         >
      DECOMP
         <
          C1:true
          A1:@
         >


&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] SentenceOK0
\item[* relevant examples:] (all clauses not containing a complrel/SENTENCE.
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] (name of rule, transformation or filter class) TC:SentenceOK
\item[* date of creation:] 26-FEB-1987 10:44:02  
\item[* author:] Jan Odijk
\item[* copied from:]--
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To let clauses without a complrel/SENTENCE pass the TC:
SentenceOK.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] dna
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:]dna
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% TRANSFORMATION Extraposition1
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                   [ I2:mu2,
                     complrel/I5::SENTENCE{SENTENCErec1}[mu3],
                     I1:sig1,                     
                     head/VERB{VERBrec1}[mu4],
                     mu5 
                   ]
           ]
>

< m :CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ I2:mu2,
                      I1:sig1,
                      head/VERB{VERBrec1}[mu4],
                      mu5
                    ],
             I3:sig2,
             extraposrel/I5::SENTENCE{SENTENCErec1}[mu3] 
           ]
>

   MATCHCONDITIONS
      <
       I1: ALL(sig1, partrel/PART{PARTrec1})
       I2: NOT EXIST (mu2, [partrel/PART{PARTrec1}])
       I3: ALL (sig2, puncrel/PUNC(AUX_kommapunckey){PUNCrec2})
       I5: (SENTENCErec1.VRCompl = false) (* A VRcomplement cannot extrapose *)
      >

<
   SUBRULE
      < >
      <sig2: [] >

      COMP
         <
          C1: SENTENCErec1.finiteness <> infinite OR
              VERBrec1.Verbraiser <> ObligatoryVR
          A1: @
         >
      DECOMP
         <
          C1: SENTENCErec1.finiteness <> infinite OR
              VERBrec1.Verbraiser <> ObligatoryVR
          A1: @
         >

   SUBRULE
      < >
      <sig2:[puncrel/PUNC(AUX_kommapunckey){PUNCrec1}] >

      DECOMP
         <
          C1: ( SENTENCErec1.finiteness <> infinite) OR
              ( VERBrec1.Verbraiser <> ObligatoryVR )
          A1: @
         >
>
&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] Extraposition1
\item[* relevant examples:] hij [dat hij wegging] zei $\rightarrow$
hij zei(,) [dat hij wegging]; hij [om weg te gaan] beloofde $\rightarrow$
hij beloofde(,) [om weg te gaan]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] (name of rule, transformation or filter class) TC:SentenceOKrules
\item[* date of creation:] 17-FEB-1987 16:40:39  
\item[* author:] Jan Odijk
\item[* copied from:] --
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 18/02/87\ \ \ \ \ author:Jan Odijk\\
VRCompl added; All wh-sentences (also infinitives) get a comma in generation.
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
mu5 is intended for auxiliary verbs. A more precise characterization is perhaps
necessary, e.g. a matchcondition ALL(mu5, I10:rel1/T1) with I10: rel1 IN [
auxrel, progauxrel ]
\item[\ \ clarification of the splitting up into subrules:]
There is a subrule for the case that there is a comma (analytically) or a comma
must be made (generatively), and a subrule for the case that  no comma is 
present/must be made in the outputmodel
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] 
In generation a comma is introduced if the extraposed sentence is finite, or
has mood whinterrogative; otherwise  no comma is introduced in 
generation.
In analysis both the presence  and the absence of a comma is accepted.
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\
It is assumed that the particles are next to the verb, not under a verb node
(* Particles left by VR must be taken into account anyway! *)
\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}



\newpage
\begin{verbatim}
% TRANSFORMATION Extraposition2
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                  [ mu2,
                    prepobjrel/PREPP{PREPPrec1}
                             [ head/PREP{PREPrec1},
                               objrel/SENTENCE{SENTENCErec1}[mu3]
                             ] ,
                    I3:sig2,
                    head/VERB{VERBrec1}[mu4],
                    mu5
                  ] 
           ]
>

< m :CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                  [ mu2,
                    prepobjrel/PREPP{PREPPrec1}
                             [ head/PREP{PREPrec1},
                               objrel/NP{NPrec1}
                                 [head/PERSPRO{PERSPROrec1}
                                  [head/BPERSPRO(AUX_hetbpersprokey){BPERSPROrec1}] 
                                 ]
                             ],
                    I3:sig2,
                    head/VERB{VERBrec1}[mu4],
                    mu5
                  ] ,
              I2:sig1,
              extraposrel/SENTENCE{SENTENCErec1}[mu3]
           ]
>

   MATCHCONDITIONS
      <
       I2:   ALL(sig1, puncrel/PUNC(AUX_kommapunckey){PUNCrec1})
       I3:   ALL(sig2, partrel/PART{PARTrec1})
      >

<
   SUBRULE
      < >
      <sig1:[] >

      COMP
         <
          C1: true
          A1: PERSPROrec1 := COPYT_bpersprotoperspro(BPERSPROrec1);
                (* persprocases, reduced retain the default values *)

              NPrec1 :=  AUX_NPONHetBprspr
         >

      DECOMP
         <
          C1: (NPrec1 = AUX_NPONHetBprspr) AND
              (PERSPROrec1 = COPYT_bpersprotoperspro(BPERSPROrec1)) AND
              ( PERSPROrec1 = 
                       { persprocases: [Nominative]
                         reduced     : false
                       }
              )
          A1: @
         >

   SUBRULE
      < >
      <sig1:[puncrel/PUNC(AUX_kommapunckey){PUNCrec2}] >

      DECOMP
         <
          C1: (NPrec1 = AUX_NPONhetBPRSPR) AND
              (PERSPROrec1 = COPYT_bpersprotoperspro(BPERSPROrec1)) AND
              ( PERSPROrec1 = 
                       { persprocases: [Nominative]
                         reduced     : false
                       }
              )
          A1: @
         >

>
&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] Extraposition2
\item[* relevant examples:] hij [op dat zij kwam ] rekende $\rightarrow$
hij [op het] rekende, dat zij kwam
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] (name of rule, transformation or filter class) TC:SentenceOK
\item[* date of creation:] 17-FEB-1987 16:54:46  
\item[* author:] Jan Odijk
\item[* copied from:] --
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To extrapose sentential complements out of a prepobj/..
leaving {\em het} behind (which will turn later into {\em er})
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:] 
mu5 for auxiliary verbs
sig2 for particles
\item[\ \ clarification of the splitting up into subrules:]
There is a subrule for the case that a comma is present in the output model,
and one where no comma is present in the output model
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In generation a comma is placed before a finite extraposed sentence and
before all sentences with mood=whinterrogative, but not 
before other sentences.
In analysis a comma or no comma is accepted in all cases.
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
<% TRANSFORMATION VerbRaising1
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                [ mu2,
                  complrel/I1::SENTENCE{SENTENCErec1}
                       [ mu3,
                         predrel/VERBP{VERBPrec2}
                             [ mu4,
                               I5:rel1/I2::VERB{VERBrec1}[mu6] 
                             ],
                         I10:sig10
                       ],
                  head/I3::VERB{VERBrec2}[mu7],
                  I7:mu9
                ] 
           ]
>

< m :CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                [ mu2,
                  complrel/I9::SENTENCE{SENTENCErec2}
                      [ mu3,
                        predrel/VERBP{VERBPrec4}[mu4],
                        I10:sig10
                      ],
                  I5:rel1/I4::VERB{VERBrec3}
                         [ head/I6::VERB{VERBrec4}[mu7],
                           adjoinrel/I2::VERB{VERBrec1}[mu6] 
                         ],
                  I7:mu9
                ]
           ]
>

   MATCHCONDITIONS
      <
       I1: ( SENTENCErec1 = { 
                             VRcompl    :true
                             finiteness :infinite
                            }
           )
       I2: ( VERBrec1.modus = infinitive ) AND (VERBrec1.status <> aanhetV )
       I3: ( VERBrec2.Verbraiser IN [optionalVR, obligatoryVR] ) AND
           ( VERBrec2.status IN [ bareV, teV] ) 
       I4: VERBrec3.status = VV
       I5: rel1 IN [head, auxrel, progauxrel]
       I6: ( VERBrec4.Verbraiser IN [optionalVR, obligatoryVR] ) AND
           ( VERBrec4.status IN [ bareV, teV] ) 
       I7: ALL(mu9, I8:rel2/T2 )
       I8: (rel2 IN [progauxrel, auxrel])
       I9:  ( SENTENCErec2 = { 
                             VRcompl    :true
                             finiteness :infinite
                            }
           )
       I10: ALL(sig10, extraposrel/..)
      >

<
   SUBRULE (* 1 *)
      <mu9:[sig1,sig2] >
      <mu9:[sig1,sig2] >

   MATCHCONDITIONS
      <
       mu9: ( ALL(sig1, progauxrel/..))      AND 
            ( ALL(sig2, auxrel/..))          AND
            ( (NOT EXIST(sig2, [auxrel/..])) OR
              (EXIST(sig1,[progauxrel/..]))
            )
      >

      COMP
         <
          C1: (VERBrec2.modus <> pastpart)

 (* reductie van voice en infsort *)

              C11: VERBrec1.status IN [ teV, teVV, partteV, teAuxV ] AND
                   SENTENCErec1.infsort = teinf 
                   C111: SENTENCErec1.voice = Active
                   A111: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
                   C112: SENTENCErec1.voice = Passive                 AND
                         ((VERBrec1.status = teV AND 
                           VERBrec1.subc IN [wordenaux, zijnaux ]) OR
                          VERBrec1.status IN [AuxV, teAuxV]
                         )
                   A112: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
              A11: SENTENCErec2.infsort := inf;
              C12: VERBrec1.status IN [ bareV, partV, VV, AuxV ] AND
                   SENTENCErec1.infsort = inf 
                   C121: SENTENCErec1.voice = Active
                   A121: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
                   C122: SENTENCErec1.voice = DoorActive AND
                         CLAUSErec1.synvpefs * AUX_DoorActivevps <> [] AND
                         NOT EXIST(mu3, [subjrel/..])
                   A122: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice;
                   C123: SENTENCErec1.voice = AanActive AND
                         CLAUSErec1.synvpefs * AUX_AanActivevps <> []  AND
                         NOT EXIST(mu3, [subjrel/..])
                   A123: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
                   C124: SENTENCErec1.voice = Passive                 AND
                         ((VERBrec1.status = bareV AND 
                           VERBrec1.subc IN [wordenaux, zijnaux ]) OR
                          VERBrec1.status IN [AuxV, teAuxV]
                         )
                   A124: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
              A12: @

 (* einde reductie van voice en infsort *)

          A1: VERBrec4 := VERBrec2;
              VERBrec3 := VERBrec2;
              VERBrec3.status := VV;

         >

      DECOMP
         <
          C1: (VERBrec4.modus <> pastpart) AND
              (VERBrec3 = VERBrec4 
                  EXCEPT FOR [ status, foundauxes, synvpefs2, prepkey1, 
                               prepkey2, particle, reflexivity, adjuncts])
              C11: VERBrec1.status IN [ teV, teVV, partteV, teAuxV ] AND
                   SENTENCErec2.infsort = inf 
                   C111: SENTENCErec2.voice = omegavoice
                   A111: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := Active;
                   C112: SENTENCErec2.voice = omegavoice                 AND
                         ((VERBrec1.status = teV AND 
                           VERBrec1.subc IN [wordenaux, zijnaux ]) OR
                          VERBrec1.status IN [AuxV, teAuxV]
                         )
                   A112: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := Passive;
              A11: SENTENCErec1.infsort := teinf;

              C12: VERBrec1.status IN [ bareV, partV ,VV, AuxV ] AND
                   SENTENCErec2.infsort = inf 
                   C121: SENTENCErec2.voice = omegavoice
                   A121: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := Active;
                   C122: SENTENCErec2.voice = omegavoice AND
                         CLAUSErec1.synvpefs * AUX_DoorActivevps <> []  AND
                         NOT EXIST(mu3, [subjrel/..])
                   A122: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := DoorActive;
                   C123: SENTENCErec2.voice = omegavoice AND
                         CLAUSErec1.synvpefs * AUX_AanActivevps <> []  AND
                         NOT EXIST(mu3, [subjrel/..])
                   A123: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := AanActive; 
                   C124: SENTENCErec2.voice = omegavoice                 AND
                         ((VERBrec1.status = bareV AND 
                           VERBrec1.subc IN [wordenaux, zijnaux ]) OR
                          VERBrec1.status IN [AuxV, teAuxV]
                         )
                   A124: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := Passive;
              A12: @
          A1: (* VERBrec2 := VERBrec3; *)
              VERBrec2 := VERBrec4;
         >


   SUBRULE (* 2 *)
      <mu9:[auxrel/T4] >
      <mu9:[auxrel/T4] >

      COMP
         <
          C1: VERBrec2.modus = pastpart      
              C11: CLAUSErec1.voice <> Passive
                   C111: VERBrec2.IPP  = NOIPP
 (* reductie van voice en infsort *)

              C11: VERBrec1.status IN [ teV, teVV, partteV, teAuxV ] AND
                   SENTENCErec1.infsort = teinf 
                   C111: SENTENCErec1.voice = Active
                   A111: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
                   C112: SENTENCErec1.voice = Passive                 AND
                         ((VERBrec1.status = teV AND 
                           VERBrec1.subc IN [wordenaux, zijnaux ]) OR
                          VERBrec1.status IN [AuxV, teAuxV]
                         )
                   A112: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
              A11: SENTENCErec2.infsort := inf;
              C12: VERBrec1.status IN [ bareV, partV, VV, AuxV ] AND
                   SENTENCErec1.infsort = inf 
                   C121: SENTENCErec1.voice = Active
                   A121: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
                   C122: SENTENCErec1.voice = DoorActive AND
                         CLAUSErec1.synvpefs * AUX_DoorActivevps <> [] 
                   A122: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice;
                   C123: SENTENCErec1.voice = AanActive AND
                         CLAUSErec1.synvpefs * AUX_AanActivevps <> [] 
                   A123: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
                   C124: SENTENCErec1.voice = Passive                 AND
                         ((VERBrec1.status = bareV AND 
                           VERBrec1.subc IN [wordenaux, zijnaux ]) OR
                          VERBrec1.status IN [AuxV, teAuxV]
                         )
                   A124: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
              A12: @

 (* einde reductie van voice en infsort *)

                   A111: VERBrec4 := VERBrec2;
                         VERBrec3 := VERBrec2;
                   C112: VERBrec2.IPP IN [obligatoryIPP, optionalIPP]
 (* reductie van voice en infsort *)

              C11: VERBrec1.status IN [ teV, teVV, partteV, teAuxV ] AND
                   SENTENCErec1.infsort = teinf 
                   C111: SENTENCErec1.voice = Active
                   A111: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
                   C112: SENTENCErec1.voice = Passive                 AND
                         ((VERBrec1.status = teV AND 
                           VERBrec1.subc IN [wordenaux, zijnaux ]) OR
                          VERBrec1.status IN [AuxV, teAuxV]
                         )
                   A112: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
              A11: SENTENCErec2.infsort := inf;
              C12: VERBrec1.status IN [ bareV, partV, VV, AuxV ] AND
                   SENTENCErec1.infsort = inf 
                   C121: SENTENCErec1.voice = Active
                   A121: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
                   C122: SENTENCErec1.voice = DoorActive AND
                         CLAUSErec1.synvpefs * AUX_DoorActivevps <> [] 
                   A122: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice;
                   C123: SENTENCErec1.voice = AanActive AND
                         CLAUSErec1.synvpefs * AUX_AanActivevps <> [] 
                   A123: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
                   C124: SENTENCErec1.voice = Passive                 AND
                         ((VERBrec1.status = bareV AND 
                           VERBrec1.subc IN [wordenaux, zijnaux ]) OR
                          VERBrec1.status IN [AuxV, teAuxV]
                         )
                   A124: SENTENCErec2 := SENTENCErec1;
                         SENTENCErec2.voice := omegavoice
              A12: @

 (* einde reductie van voice en infsort *)

                   A112: VERBrec4 := VERBrec2;
                         VERBrec4.modus := infinitive;
                         VERBrec3 := VERBrec2;
                         VERBrec3.modus := infinitive;
              A11: @
          A1: VERBrec3.status := VV;

         >
      DECOMP
         <
          C1: VERBrec3.status = VV    
              C11: (CLAUSErec1.voice <> Passive)
                   C111: (VERBrec4.IPP  IN [NOIPP, optionalIPP])
              C11: VERBrec1.status IN [ teV, teVV, partteV, teAuxV ] AND
                   SENTENCErec2.infsort = inf 
                   C111: SENTENCErec2.voice = omegavoice
                   A111: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := Active;
                   C112: SENTENCErec2.voice = omegavoice                 AND
                         ((VERBrec1.status = teV AND 
                           VERBrec1.subc IN [wordenaux, zijnaux ]) OR
                          VERBrec1.status IN [AuxV, teAuxV]
                         )
                   A112: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := Passive;
              A11: SENTENCErec1.infsort := teinf;

              C12: VERBrec1.status IN [ bareV, partV ,VV, AuxV ] AND
                   SENTENCErec2.infsort = inf 
                   C121: SENTENCErec2.voice = omegavoice
                   A121: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := Active;
                   C122: SENTENCErec2.voice = omegavoice AND
                         CLAUSErec1.synvpefs * AUX_DoorActivevps <> [] 
                   A122: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := DoorActive;
                   C123: SENTENCErec2.voice = omegavoice AND
                         CLAUSErec1.synvpefs * AUX_AanActivevps <> [] 
                   A123: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := AanActive; 
                   C124: SENTENCErec2.voice = omegavoice                 AND
                         ((VERBrec1.status = bareV AND 
                           VERBrec1.subc IN [wordenaux, zijnaux ]) OR
                          VERBrec1.status IN [AuxV, teAuxV]
                         )
                   A124: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := Passive;
              A12: @
                   A111: (* VERBrec2 := VERBrec3; *)
                         VERBrec2 := VERBrec4
                   C112: (VERBrec4.IPP IN [obligatoryIPP, optionalIPP]) AND
                         (VERBrec4.modus = infinitive)
              C11: VERBrec1.status IN [ teV, teVV, partteV, teAuxV ] AND
                   SENTENCErec2.infsort = inf 
                   C111: SENTENCErec2.voice = omegavoice
                   A111: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := Active;
                   C112: SENTENCErec2.voice = omegavoice                 AND
                         ((VERBrec1.status = teV AND 
                           VERBrec1.subc IN [wordenaux, zijnaux ]) OR
                          VERBrec1.status IN [AuxV, teAuxV]
                         )
                   A112: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := Passive;
              A11: SENTENCErec1.infsort := teinf;

              C12: VERBrec1.status IN [ bareV, partV ,VV, AuxV ] AND
                   SENTENCErec2.infsort = inf 
                   C121: SENTENCErec2.voice = omegavoice
                   A121: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := Active;
                   C122: SENTENCErec2.voice = omegavoice AND
                         CLAUSErec1.synvpefs * AUX_DoorActivevps <> [] 
                   A122: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := DoorActive;
                   C123: SENTENCErec2.voice = omegavoice AND
                         CLAUSErec1.synvpefs * AUX_AanActivevps <> [] 
                   A123: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := AanActive; 
                   C124: SENTENCErec2.voice = omegavoice                 AND
                         ((VERBrec1.status = bareV AND 
                           VERBrec1.subc IN [wordenaux, zijnaux ]) OR
                          VERBrec1.status IN [AuxV, teAuxV]
                         )
                   A124: SENTENCErec1 := SENTENCErec2;
                         SENTENCErec1.voice := Passive;
              A12: @
                   A112: VERBrec2 := VERBrec4;
              A11: @
          A1: VERBrec2.modus := pastpart;
         >

>
&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] VerbRaising1
\item[* relevant examples:] See subrules
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] (name of rule, transformation or filter class) TC:
SentenceOkrules
\item[* date of creation:] 19-FEB-1987 16:37:49  
\item[* author:] Jan Odijk
\item[* copied from:] --
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 26/02/87\ \ \ \ \ author:Jan Odijk\\
The matchcondition I9 has been introduced, replacing several subrules by one
subrule plus a matchcondition.
\item date: 11/05/87\ \ \ \ \ author: Jan Odijk\\
The sentencerecord and the verbprecord are made empty to facilitate pruning
later.
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To form Verb raising structures
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:] To delete the VERBP in this rule as well.
There are two reasons for postponing this:
\begin{enumerate}
   \item It would make this rule still more complex
   \item It is not necessarily uniquely determined how in analysis 
   which part belongs under VERBP or not.
\end{enumerate}
\item[\ \ clarification of variables:]
The auxiliaries are mentioned explicitly to avoid an ambiguity in analysis
(cf. mu9 and the subrules)
\item[\ \ clarification of the splitting up into subrules:]

There are 2 subrules. 
Subrule 1 is for the case that no auxrel/.. is present directly following
VERBP (hence the clause
is not passive, nor in perfect tense). Examples
\begin{enumerate}
   \item dat hij [x1 de appel kopen/opeten ] wou $\rightarrow$\\
         dat hij [x1 de appel ] wou kopen/opeten
   \item dat hij [x1 de appel te kopen/op te eten ] probeerde $\rightarrow$
         dat hij [x1 de appel] probeerde te kopen/ op te eten
   \item dat hij [x1 de appel gekocht/opgegeten hebben ] wou $\rightarrow$
         dat hij [x1 de appel gekocht/opgegeten ] wou hebben
   \item dat hij [x1 de appel gekocht/opgegeten te hebben ] probeerde $\rightarrow$
         dat hij [x1 de appel gekocht/opgegeten ] probeerde te hebben
   \item dat hij [x1 de appel hebben gekocht/opgegeten ] wou $\rightarrow$
         dat hij [x1 de appel ] wou hebben gekocht/opgegeten 
   \item dat hij [x1 de appel te hebben gekocht/opgegeten ] probeerde $\rightarrow$
         dat hij [x1 de appel ] probeerde te hebben gekocht/opgegeten 
   \item dat hij [x1 de appel aan het kopen/opeten zijn ] wou $\rightarrow$\\
         dat hij [x1 de appel aan het kopen/opeten ] wou zijn
   \item dat hij [x1 de appel aan het kopen/opeten te zijn ] probeerde $\rightarrow$\\
         dat hij [x1 de appel aan het kopen/opeten ] probeerde te zijn
   \item dat hij [x1 de appel aan het kopen/opeten geweest zijn ] wou $\rightarrow$\\
         dat hij [x1 de appel aan het kopen/opeten geweest ] wou zijn
   \item dat hij [x1 de appel aan het kopen/opeten geweest te zijn ] probeerde $\rightarrow$\\
         dat hij [x1 de appel aan het kopen/opeten geweest ] probeerde te zijn
   \item dat hij [x1 de appel aan het kopen/opeten zijn geweest ] wou $\rightarrow$\\
         dat hij [x1 de appel aan het kopen/opeten ] wou zijn geweest 
   \item dat hij [x1 de appel aan het kopen/opeten te zijn geweest ] probeerde $\rightarrow$\\
         dat hij [x1 de appel aan het kopen/opeten ] probeerde te zijn geweest 
   \item dat hij [x1 onderzocht worden ] wou $\rightarrow$\\
         dat hij [x1 onderzocht ] wou worden
   \item dat hij [x1 onderzocht te worden ] probeerde $\rightarrow$\\
         dat hij [x1 onderzocht ] probeerde te worden
   \item dat hij [x1 worden onderzocht ] wou $\rightarrow$\\
         dat hij [x1 ] wou worden onderzocht 
   \item dat hij [x1 te worden onderzocht ] probeerde $\rightarrow$\\
         dat hij [x1 ] probeerde te worden onderzocht 
\end{enumerate}

Subrule 2 is for the case that an auxrel/.. is present, that immediately 
follows VERBP. There are two
further subcases:

\begin{enumerate}

   \item No Passive, the embedded verb does not partake in IPP (infinitivum pro
          participio)
	 \begin{enumerate}
	    \item dat hij [x1 de appel te kopen/op te eten ] beloofd heeft $\rightarrow$
		  dat hij [x1 de appel] beloofd te kopen/ op te eten heeft
	 \end{enumerate}
         Ultimately this will yield: {\em dat hij de appel heeft beloofd te 
kopen/ op te eten}
   \item No passive; the verb partakes in IPP:
	 \begin{enumerate}
	    \item dat hij [x1 de appel kopen/opeten ] gekund heeft$\rightarrow$\\
		  dat hij [x1 de appel] kunnen kopen/opeten heeft
	    \item dat hij [x1 de appel te kopen/op te eten ] geprobeerd heeft $\rightarrow$
		  dat hij [x1 de appel] probeeren te kopen/ op te eten heeft
	 \end{enumerate}
yielding ultimately: {\em dat hij de appel heeft kunnen kopen/opeten } resp.
{\em dat hij de appel heeft proberen te kopen/ op te eten}
\end{enumerate}

The CApairs of subrule 1 are for the following subcases:
CA1111: [te hebben gedood] schijnt / [te zijn gevallen] schijnt\\
CA1112: [te doden] probeert / [te vallen] schijnt\\
CA1121: [te zijn  gedood] schijnt\\
CA1122: [te worden gedood] schijnt\\
CA1211: [ hebben gedood] kan / [zijn gevallen] kan\\
CA1212: [doden] kan\\
CA122 : (door Piet) [doden] liet ( It is assumed that retro=false if Dooractive)
CA123 : (aan Piet) [lezen] liet ( It is assumed that retro=false if Aanactive)
CA1241: [ zijn gedood ] kan\\
CA1242: [worden gedood] kan\\

Originally, this rule took care of the case where the clause is passive as well
((only?) example: {\em geacht worden }). This has been removed and will have to
be taken care of in a special rule.

The matchcondition I9 is quite complex. It is supposed to express the fact that
mu9 cannot exist completely of an auxrel/.. (or: mu9 cannot start with an 
auxrel/..)

 20-JAN-1988 11:23:04 (JO) IPP adapted. The asymmetry betweem generation and 
analysis has been brought in on purpose. In generation the participle is
replaced by the infinitve as much as possible; in analysis for certain verbs
both the infinitive and the participle are accepted. (perhaps: beloven):
hij heeft die boeken beloven te verkopen vs. hij heeft die boeken beloofd te
verkopen (my own judgement: second one is completely ungrammatical, first one
is significantly better, though perhaps marginal) 

 2-FEB-1988 14:26:10(JO) reduceMAcro mentioned;
                      rule extended so that it is applicable to cases
of auxrel, progauxrel as well

\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\
\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% TRANSFORMATION Verbraising2
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             I9:predrel/VERBP{VERBPrec1}
                [ mu2,
                  complrel/SENTENCE{SENTENCErec1}
                       [ mu3,
                         predrel/VERBP{VERBPrec2}
                             [ mu4,
                               head/I5::VERB{VERBrec1}
                                   [ head/SUBVERB{SUBVERBrec1}
                                         [ partrel/PART{PARTrec1},
                                           head/SUBVERB{SUBVERBrec3}[mu6]
                                         ]
                                   ] 
                             ],
                         I10:sig10
                       ],
                  head/VERB{VERBrec2}[mu7],
                  I7:mu9
                ] 
           ]
>

< m :CLAUSE{CLAUSErec1}
           [ mu1,
             I9:predrel/VERBP{VERBPrec1}
                [ mu2,
                  complrel/I1::SENTENCE{SENTENCErec2}
                      [ mu3,
                        predrel/VERBP{VERBPrec2}
                               [ mu4,
                                 partrel/PART{PARTrec1}
                               ],
                        I10:sig10
                      ],
                  head/I4::VERB{VERBrec3}
                      [ head/I6::VERB{VERBrec4}[mu7],
                        adjoinrel/I2::VERB{VERBrec5}
                                 [head/SUBVERB{SUBVERBrec3}[mu6]] 
                      ],
                  I7:mu9
                ]
           ]
>

   MATCHCONDITIONS
      <
       I1: ( SENTENCErec2 = { 
                             VRcompl    :true
                             finiteness :infinite
                            }
           )
       I2: ( VERBrec5.modus = infinitive ) AND (VERBrec5.status IN [bareV])
       I4: VERBrec3.status = VV
       I5: VERBrec1.status = partV
       I6: ( VERBrec4.Verbraiser IN [optionalVR, obligatoryVR] ) AND
           ( VERBrec4.status IN [ bareV, teV] ) 
       I7: ALL(mu9, I8:rel1/T2 )
       I8: (rel1 IN [progauxrel, auxrel])
       I9: PARTrec1.key = VERBrec5.particle
       I10: ALL(sig10, extraposrel/..)
      >

<
   SUBRULE  (* 1a *) 
      <
       mu9:[sig1,sig2]
      >
      <
       mu9:[sig1,sig2] 
      >

   MATCHCONDITIONS
      <
       mu9: ( ALL(sig1, progauxrel/..))      AND 
            ( ALL(sig2, auxrel/..))          AND
            ( (NOT EXIST(sig2, [auxrel/..])) OR
              (EXIST(sig1,[progauxrel/..] ))
            )
      >

      DECOMP
         <
          C1: SENTENCErec2.voice = omegavoice
          A1: VERBrec2 := VERBrec4;
              VERBrec1 := VERBrec5;
              SUBVERBrec1 := SUBVERBrec3;
              SUBVERBrec1.lastaffix := partaffix;
              VERBrec1.status := partV;
              SENTENCErec1 := SENTENCErec2;
              SENTENCErec1.voice := Active;
         >

   SUBRULE (* 2a *)
      <
       mu9 :[auxrel/T4] 
      >
      <
       mu9 :[auxrel/T4] 
      >

      DECOMP
         <
          C1: SENTENCErec2.voice = omegavoice
              C11: true
                   C111: (VERBrec4.IPP IN [NOIPP, optionalIPP])
                   A111: VERBrec2 := VERBrec4
                   C112: (VERBrec4.IPP IN [obligatoryIPP, optionalIPP]) AND
                         (VERBrec4.modus = infinitive)
                   A112: VERBrec2 := VERBrec4;
                         VERBrec2.modus := pastpart;
              A11: @
          A1: VERBrec1 := VERBrec5;
              VERBrec1.status := partV;
              SUBVERBrec1 := SUBVERBrec3;
              SUBVERBrec1.lastaffix := partaffix;
              SENTENCERec1 := SENTENCErec2;
              SENTENCErec1.voice := Active;
         >

>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Verbraising2
\item[* relevant examples:]\mbox{}\\
\begin{enumerate}
\item  ..opbellen] wou $\rightarrow$ .. op] wou bellen; 
\end{enumerate}
See also under 'subrules' 
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] (name of rule, transformation or filter class) TC:
SentenceOkrules
\item[* date of creation:]  25-FEB-1987 09:24:07 
\item[* author:] Jan Odijk
\item[* copied from:]  VerbRaising1
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 26/02/87\ \ \ \ \ author:Jan Odijk\\
The matchcondition I9 has been introduced, replacing several subrules by one
subrule plus a matchcondition.
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To form Verb raising structures
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:] To delete the VERBP in this rule as well.
There are two reasons for postponing this:
\begin{enumerate}
   \item It would make this rule still more complex
   \item It is not necessarily uniquely determined how in analysis 
   which part belongs under VERBP or not.
\end{enumerate}
See for this also Verbraising1
\item[\ \ clarification of variables:]
The auxiliaries are mentioned explicitly to avoid an ambiguity in analysis
(cf. mu9, and the subrules)\\

\item[\ \ clarification of the splitting up into subrules:]
Subrule 1a,b  are for the case that no auxrel/.. immediately following VERBP 
is present (hence the clause is not passive, nor in perfect tense). 
Here subrule 1a is for the case that the embedded verb does not have {\em
te}, subrule 1b for the case that the verb does have {\em te}. 


 Examples (1a,b)
\begin{enumerate}
   \item dat hij [x1 de appel opeten ] wou $\rightarrow$\\
         dat hij [x1 de appel op ] wou eten
\end{enumerate}

Subrules 2a,b are for the case that an auxrel/.. is present. 
Here 2a is for the case that embedded verb does not have {\em te}, subrule
2 for the case that the embedded verb does have {\em te}.
There are two
further subcases per subrule:

\begin{enumerate}

   \item No Passive, the embedded verb does not partake in IPP (infinitivum pro
          participio)
               does not exist
   \item No passive; the verb partakes in IPP:
	 \begin{enumerate}
	    \item dat hij [x1 de appel op eten ] gewild heeft $\rightarrow$
		  dat hij [x1 de appel op ] willen eten heeft
	 \end{enumerate}
yielding ultimately: {\em dat hij de appel op heeft kunnen eten } resp.
{\em dat hij de appel op heeft proberen op te eten}
\end{enumerate}
The matchcondition I9 is supposed to mean that mu9 does not start with auxrel/..
(the complement of the mu9-value in subrule 2).
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] There is no generative 
version (more precisely, generatively this rule is never applicable).
\item[\  \ suggested semantics:] none
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\
\item modifications:\\
 2-FEB-1988 14:47:40 (JO) adapted to new treatment of  PARTICLES as 
prefixes. A new rule for op + te bellen is to be added
\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% TRANSFORMATION TVerbraising3
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             I9:predrel/VERBP{VERBPrec1}
                [ mu2,
                  complrel/SENTENCE{SENTENCErec1}
                       [ mu3,
                         predrel/VERBP{VERBPrec2}
                             [ mu4,
                               head/VERB{VERBrec1}
                                   [ partrel/PART{PARTrec1},
                                     head/VERB{VERBrec5}[mu6]
                                   ] 
                             ],
                         I10:sig10
                       ],
                  head/VERB{VERBrec2}[mu7],
                  I7:mu9
                ] 
           ]
>

< m :CLAUSE{CLAUSErec1}
           [ mu1,
             I9:predrel/VERBP{VERBPrec1}
                [ mu2,
                  complrel/I1::SENTENCE{SENTENCErec2}
                      [ mu3,
                        predrel/VERBP{VERBPrec2}
                               [ mu4,
                                 partrel/PART{PARTrec1}
                               ],
                        I10:sig10
                      ],
                  head/I4::VERB{VERBrec3}
                      [ head/I6::VERB{VERBrec4}[mu7],
                        adjoinrel/I2::VERB{VERBrec5}[mu6] 
                      ],
                  I7:mu9
                ]
           ]
>

   MATCHCONDITIONS
      <
       I1: ( SENTENCErec2 = { 
                             VRcompl    :true
                             finiteness :infinite
                            }
           )
       I2: ( VERBrec5.modus = infinitive ) AND (VERBrec5.status IN [teV])
       I4: VERBrec3.status = VV
       (* I5 does not exist *)
       I6: ( VERBrec4.Verbraiser IN [optionalVR, obligatoryVR] ) AND
           ( VERBrec4.status IN [ bareV, teV] ) 
       I7: ALL(mu9, I8:rel1/T2 )
       I8: (rel1 IN [progauxrel, auxrel])
       I9: PARTrec1.key = VERBrec5.particle
       I10: ALL(sig10, extraposrel/..)
      >

<
   SUBRULE  (* 1a *) 
      <
       mu9:[sig1,sig2]
      >
      <
       mu9:[sig1,sig2] 
      >

   MATCHCONDITIONS
      <
       mu9: ( ALL(sig1, progauxrel/..))      AND 
            ( ALL(sig2, auxrel/..))          AND
            ( (NOT EXIST(sig2, [auxrel/..])) OR
              (EXIST(sig1,[progauxrel/..] ))
            )
      >

      DECOMP
         <
          C1: SENTENCErec2.voice = omegavoice
          A1: VERBrec2 := VERBrec4;
              VERBrec1 := VERBrec5;
              VERBrec1.status := partteV;
              SENTENCErec1 := SENTENCErec2;
              SENTENCErec1.voice := Active;
              SENTENCErec1.infsort := teinf;
         >

   SUBRULE (* 2a *)
      <
       mu9 :[auxrel/T4] 
      >
      <
       mu9 :[auxrel/T4] 
      >

      DECOMP
         <
          C1: SENTENCErec2.voice = omegavoice
              C11: true
                   C111: (VERBrec4.IPP IN [NOIPP, optionalIPP])
                   A111: VERBrec2 := VERBrec4
                   C112: (VERBrec4.IPP IN [obligatoryIPP, optionalIPP]) AND
                         (VERBrec4.modus = infinitive)  
                   A112: VERBrec2 := VERBrec4;
                         VERBrec2.modus := pastpart;
              A11: @
          A1: VERBrec1 := VERBrec5;
              VERBrec1.status := partteV;
              SENTENCErec1 := SENTENCErec2;
              SENTENCErec1.voice := Active;
         >

>


&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] TVerbraising3
\item[* relevant examples:]
\begin{enumerate}
\item ..dat hij [ de appels op te eten] probeerde $\rightarrow$\\
      ..dat hij [ de appels op ] probeerde te eten
\item ..dat hij [ de appels op te eten] beloofd heeft $\rightarrow$\\
      ..dat hij [ de appels op ] beloofd te eten heeft
\item ..dat hij [ de appels op te eten] geprobeerd heeft $\rightarrow$\\
      ..dat hij [ de appels op ] proberen te eten heeft
\end{enumerate}
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 3-FEB-1988 10:39:50  
\item[* author:] Jan Odijk
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


%%
E 2
E 1
