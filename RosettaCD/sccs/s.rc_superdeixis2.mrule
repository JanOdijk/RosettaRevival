h52708
s 01617/00000/00001
d D 1.2 92/02/21 15:44:38 rous 2 1
c 
e
s 00001/00000/00000
d D 1.1 92/02/11 11:48:20 rous 1 0
c date and time created 92/02/11 11:48:20 by rous
e
u
U
f e 0
t
T
I 2
DUTCH 78
&
\newpage
\begin{verbatim}
%
% RULE Rinfinpresentsuperdeixis
< m1:CLAUSE{CLAUSErec1}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I3:rel1/VERB{VERBrec1}[mu4]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I3:rel1/VERB{VERBrec1}[mu4]
                   ],
            mu5
           ] 

>
   MATCHCONDITIONS
      <
       I1: QUOTE_temprefnotfound(mu1)
       I2: QUOTE_temprefnotfound(mu2)
       m1: (CLAUSErec1.deixis = omegadeixis) AND
           (CLAUSErec1.finiteness = infinite)
       I3: (VERBrec1.tense = omegatense) 
       m : (CLAUSErec2.finiteness = infinite) AND
           (CLAUSErec2.deixis = omegadeixis)

      >

<
   SUBRULE
      <sig1: [ ]>
      <sig1: [ ]>


      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := presentdeixis;
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: @
         >
      DECOMP
         <
          C1:true
              C11: (CLAUSErec2.superdeixis = presentdeixis)
              A11: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := omegadeixis;

              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
E 2
I 1
 
I 2
          A1: @
         >

   SUBRULE
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            ((ADVPVARrec1.deixis = omegadeixis) OR
             (ADVPVARrec1.deixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := presentdeixis;
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: @
         >
      DECOMP
         <
          C1:true
              C11: (CLAUSErec2.superdeixis = presentdeixis)
              A11: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := omegadeixis;

              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: @
         >

   SUBRULE
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            ((PREPPVARrec1.deixis = omegadeixis) OR
             (PREPPVARrec1.deixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := presentdeixis;
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: @
         >
      DECOMP
         <
          C1:true
              C11: (CLAUSErec2.superdeixis = presentdeixis)
              A11: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := omegadeixis;

              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: @
         >

   SUBRULE
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            ((SENTENCErec1.conjdeixis = omegadeixis) OR
             (SENTENCErec1.conjdeixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := presentdeixis;
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: @
         >
      DECOMP
         <
          C1:true
              C11: (CLAUSErec2.superdeixis = presentdeixis)
              A11: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := omegadeixis;

              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: @
         >
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rinfinpresentsuperdeixis
\item[* relevant examples:] Hij probeert (te slapen)
                            Hij probeert (om 3 uur te komen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 24-FEB-1988 
\item[* author:] Lisette Appelo
\item[* copied from:] Rfinpresentsuperdeixis
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 19/05/89\ \ \ \ \ author: Lisette Appelo\\
Added condition on futuredeixis adverbial 
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is simultanuous: PRESENT.
               This rule is for a infinite dependent clause.
               The deixis value of the possible reference adverbial is checked 
               for omega or future.
               The clause is marked for present superdeixis.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different categories of the variables for the 
reference adverbials and the not occurrence of a reference adverbial. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53, 263, 314, 320
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The superdeixis value also may be presentdeixis in the case 
this sentence is a sentence with {\em graag}\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rinfinpastsuperdeixis
< m1:CLAUSE{CLAUSErec1}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I3:rel1/VERB{VERBrec1}[mu4]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I3:rel1/VERB{VERBrec1}[mu4]
                   ],
            mu5
           ] 

>
   MATCHCONDITIONS
      <
       I1: QUOTE_temprefnotfound(mu1)
       I2: QUOTE_temprefnotfound(mu2)
       m1: (CLAUSErec1.deixis = omegadeixis) AND
           (CLAUSErec1.finiteness = infinite)
       I3: (VERBrec1.tense = omegatense) 
       m : (CLAUSErec2.finiteness = infinite) AND
           (CLAUSErec2.deixis = omegadeixis)

      >

<
   SUBRULE
      <sig1: [ ]>
      <sig1: [ ]>

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: @
         >
      DECOMP
         <
          C1:true

              C11: (CLAUSErec2.superdeixis = pastdeixis)
              A11: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := omegadeixis;

              C12: (CLAUSErec2.superdeixis = pastdeixis)
              A12: CLAUSErec1 := CLAUSErec2;

          A1: @
         >

   SUBRULE
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            ((ADVPVARrec1.deixis = omegadeixis) OR
             (ADVPVARrec1.deixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: @
         >
      DECOMP
         <
          C1:true
              C11: (CLAUSErec2.superdeixis = pastdeixis)
              A11: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := omegadeixis;

              C12: (CLAUSErec2.superdeixis = pastdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: @
         >

   SUBRULE
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            ((PREPPVARrec1.deixis = omegadeixis) OR
             (PREPPVARrec1.deixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
          A1: @
         >
      DECOMP
         <
          C1:true
              C11: (CLAUSErec2.superdeixis = pastdeixis)
              A11: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := omegadeixis;

              C12: (CLAUSErec2.superdeixis = pastdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: @
         >

   SUBRULE
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            ((SENTENCErec1.conjdeixis = omegadeixis) OR
             (SENTENCErec1.conjdeixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: @
         >
      DECOMP
         <
          C1:true
              C11: (CLAUSErec2.superdeixis = pastdeixis)
              A11: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := omegadeixis;

              C12: (CLAUSErec2.superdeixis = pastdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: @
         >
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rinfinpastsuperdeixis
\item[* relevant examples:] Hij probeerde (te slapen)
                            Hij probeerde (om 3 uur te komen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 24-FEB-1988 
\item[* author:] Lisette Appelo
\item[* copied from:] Rfinpastsuperdeixis
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 19/05/89\ \ \ \ \ author: Lisette Appelo\\
Added condition on futuredeixis adverbial. 
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is before: PAST.
               This rule is for a finite dependent clause.
               The deixis 
value of the possible reference adverbial is checked for 
               omega or future.
               The clause is marked for past superdeixis.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different categories of the variables for the 
reference adverbials and the not occurrence of a reference adverbial. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] 
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The superdeixis value also may be presentdeixis in the case 
this sentence is a sentence with {\em graag}\\
\end{enumerate}
\end{description}

\newpage
\begin{verbatim}

% RULE Rinfinpastsuperdeixisspec
< m1:CLAUSE{CLAUSErec1}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                I3:[mu3,
                    I4:rel1/VERB{VERBrec1}[mu4]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                I3:[mu3,
                    I5:rel1/VERB{VERBrec2}[mu4],
                    I6:auxrel/VERB{VERBrec3}
                          [head/SUBVERB{SUBVERBrec1}
                               [head/T2] 
                          ],
                    mu5
                   ]
           ] 

>
   MATCHCONDITIONS
      <
       I1: QUOTE_temprefnotfound(mu1)
       I2: QUOTE_temprefnotfound(mu2)
       I3: RIGHTTOLEFT
       m1: (CLAUSErec1.deixis = omegadeixis) AND
           (CLAUSErec1.aspect = perfective) AND
           (CLAUSErec1.retro = false) AND
           (CLAUSErec1.finiteness = infinite)
       I4: (VERBrec1.tense = omegatense) 
       m : (CLAUSErec2.deixis = omegadeixis) AND
           (CLAUSErec2.aspect = perfective) AND
           (CLAUSErec2.retro = false) AND
           (CLAUSErec2.finiteness = infinite) 
       I5: (VERBrec2.modus = pastpart) 
       I6: (VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1)) AND
           (VERBrec3 =
                     {
                      number : omeganumber
                      persons : []
                      eORenForm : NoForm
                      modus : omegamodus
                      tense : omegatense
                      status : bareV
                     }
            )
              
              (* other values: default values *)

      >

<
   SUBRULE (*1: ADVPVAR, hebben*)
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <
       sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            (ADVPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis

             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := omegatense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

   SUBRULE (*2: ADVPVAR, zijn*)
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <
       sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            (ADVPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := omegatense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

   SUBRULE (*3: PREPPVAR, hebben*)
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <
       sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            (PREPPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := omegatense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

   SUBRULE (*4: PREPPVAR, zijn*)
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <
       sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            (PREPPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := omegatense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

   SUBRULE (*5: SENTENCE, hebben*)
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <
       sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            (SENTENCErec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := omegatense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1))
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

   SUBRULE (*6: SENTENCE, zijn*)
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <
       sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            (SENTENCErec1.conjdeixis = omegadeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec1 := CLAUSErec2;
                 CLAUSErec1.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := omegatense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >


>
&
\end{verbatim}

\newpage
\begin{description}
\item[* name:] Rinfinpastsuperdeixisspec
\item[* relevant examples:] hij dacht (om 3 uur te zijn gekomen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 24-FEB-1988 
\item[* author:] Lisette Appelo
\item[* copied from:]Rfinpastsuperdeixisspec
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 17/05/89\ \ \ \ \ author: Lisette Appelo 
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The `indirect' relation between Rs and S is before: PAST.
               This rule is for a finite dependent clause. This
               is a special rule because the auxiliary verb {\em hebben/zijn} 
               expresses the past. 
               The most right verb in the clause (input generative rule)
gets modus of a past particle.
The auxiliary verb {\em hebben/zijn
} is introduced with a omega tense.
               The deixis 
value of the reference adverbial is checked for 
               omega.
               The clause is marked for past superdeixis.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different variable categories for the reference 
adverbials and the not occurrence of an adverbial. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial, perfective aspect rule \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language: This rule has the same semantics as 
Rfinpastsuperdeixis2.\\

\item in other languages: This rule corresponds to the rule for dependent
simple past tense in English and preterito in Spanish. \\

\end{enumerate}
\item[* relevant literature/documents:] doc 53, 263, 314.
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The superdeixis value also may be pastdeixis in the case 
this sentence is a sentence with {\em graag}\\
17/05/89: Deleted the subrules in which no adverbial was required. In that 
case the interpretation should be past retro. This rule now corresponds to 
Lpastpastsuperdeixis and not to Lpastsuperdeixis. This means that it 
corresponds to Rpastsuperdeixis2 and Rfinpastsuperdeixisspec. 

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rfinirrmodalsuperdeixis
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            sig1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I3:rel1/VERB{VERBrec1}
                        [head/SUBVERB{SUBVERBrec1}
                             [I2:head/BVERB(KEY1){BVERBrec1}]
                        ]
                   ],
            mu4
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [mu1,
            sig1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I4:rel1/VERB{VERBrec2}
                        [head/SUBVERB{SUBVERBrec1}
                             [I2:head/BVERB(KEY1){BVERBrec1}]
                        ]
                    ],
              mu4
           ] 

>
   MATCHCONDITIONS
      <
       I2: KEY1 = KEY_kanirr1BVERBkey OR
           KEY1 = KEY_kanirr2BVERBkey OR
           KEY1 = KEY_moetirr1BVERBkey OR
           KEY1 = KEY_moetirr2BVERBkey OR
           KEY1 = KEY_moet1BVERBkey OR
           KEY1 = KEY_moet2BVERBkey 
       m1:(CLAUSErec1.deixis = omegadeixis) AND
          (CLAUSErec1.aspect = perfective) AND
          (CLAUSErec1.retro = false) AND
          (CLAUSErec1.finiteness = finite) 
       I3:(VERBrec1.tense = omegatense)
       m: (CLAUSErec2.deixis = omegadeixis) AND
          (CLAUSErec2.aspect = perfective) AND
          (CLAUSErec2.retro = false) AND
          (CLAUSErec2.finiteness = finite) 
       I4:(VERBrec2.tense = pasttense)

       
      >

<
   SUBRULE (*1: no tempadv*)
      <sig1: []>
      <sig1: []>


      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;             

             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
             
         >
      DECOMP
         <
          C1:true
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERbrec1.tense := omegatense;
         >


   SUBRULE (*2: ADVPVAR*)
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            (ADVPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;             

             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
             
         >
      DECOMP
         <
          C1:true
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
         >


   SUBRULE (*3: PREPPVAR*)
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            (PREPPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;             

             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
             
         >
      DECOMP
         <
          C1:true
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
         >


   SUBRULE (*4: SENTENCE*)
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            (SENTENCErec1.conjdeixis = omegadeixis)
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;             

             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
               (* other values retain their default values *)
             
         >

      DECOMP
         <
          C1:true
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
         >

>
&
\end{verbatim}

\newpage
\begin{description}
\item[* name:] Rfinirrmodalsuperdeixis
\item[* relevant examples:] hij komen kunnen $rightarrow$ hij komen kunnen zou\\
hij komen moeten $rightarrow$ hij komen moeten zou
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 07-OCT-1988 
\item[* author:] Lisette Appelo
\item[* copied from:]Rinfinpastdeixisspec
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 09/01/90\ \ \ \ \ author: Lisette Appelo\\
Changed rule in accordance to changes in Rfinirrmodaldeixis. The non-irrealis
{\em moeten} is also allowed here to derive {\em hij zei dat hij moest komen} 
in the sense of {\em hij zei dat hij zou moeten komen}. 
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Irrealis construction of modals {\em kunnen} and {\em moeten}.
               This rule is for a finite dependent clause. This
               is a special rule,because irrealis is expressed by the auxiliary 
               verb {\em zou}. 
               The deixis 
value of the reference adverbial is checked for past deixis.
               The clause is marked for past superdeixis.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different variable categories for the reference 
adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial, perfective aspect rule \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language: \\

\item in other languages: \\

\end{enumerate}
\item[* relevant literature/documents:] doc 53, 263, 314, 327
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The superdeixis value also may be pastdeixis in the case 
this sentence is a sentence with {\em graag}\\

\end{enumerate}
\end{description}

% RULE Rfinpastsuperdeixisspec
< m1:CLAUSE{CLAUSErec1}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
               I3: [mu3,
                    I4:rel1/VERB{VERBrec1}[mu4]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
               I3: [mu3,
                    I5:rel1/VERB{VERBrec2}[mu4],
                    I6:auxrel/VERB{VERBrec3}
                          [head/SUBVERB{SUBVERBrec1}
                               [head/T2] 
                          ],
                    mu5
                   ]
           ] 

>
   MATCHCONDITIONS
      <
       I1: QUOTE_temprefnotfound(mu1)
       I2: QUOTE_temprefnotfound(mu2)
       I3: RIGHTTOLEFT
       m1: (CLAUSErec1.deixis = omegadeixis) AND
           (CLAUSErec1.aspect = perfective) AND
           (CLAUSErec1.retro = false) AND
           (CLAUSErec1.finiteness = finite)
       I4: (VERBrec1.tense = omegatense)
       m : (CLAUSErec2.deixis = omegadeixis) AND
           (CLAUSErec2.aspect = perfective) AND
           (CLAUSErec2.retro = false) AND
           (CLAUSErec2.finiteness = finite) 
       I5: (VERBrec2.modus = pastpart)
       I6: (VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1)) AND
           (VERBrec3 =
                     {
                      number : omeganumber
                      persons : []
                      eORenForm : NoForm
                      modus : omegamodus
                      tense : pasttense
                      status : bareV
                     }
           )
           (* other values: default values *)


      >

<
   SUBRULE (*1: ADVPVAR, hebben*)
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <
       sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            ((ADVPVARrec1.deixis = omegadeixis) OR
             (ADVPVARrec1.deixis = pastdeixis)
            ) 
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis

             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := pasttense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1: (hebaux IN VERBrec2.perfauxs) AND
              (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

   SUBRULE (*2: ADVPVAR, zijn*)
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <
       sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            ((ADVPVARrec1.deixis = omegadeixis) OR
             (ADVPVARrec1.deixis = pastdeixis)
            )
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := pasttense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

   SUBRULE (*3: PREPPVAR, hebben*)
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <
       sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1: (PREPPVARrec1.class = reference) AND
             (PREPPVARrec1.retro = false) AND
             ((PREPPVARrec1.deixis = omegadeixis) OR
              (PREPPVARrec1.deixis = pastdeixis)
             )
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := pasttense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

   SUBRULE (*4: PREPPVAR, zijn*)
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <
       sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            ((PREPPVARrec1.deixis = omegadeixis) OR
             (PREPPVARrec1.deixis = pastdeixis)
            )
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := pasttense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

   SUBRULE (*5: SENTENCE, hebben*)
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <
       sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            ((SENTENCErec1.conjdeixis = omegadeixis) OR
             (SENTENCErec1.conjdeixis = pastdeixis)
            )
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
                 CLAUSErec2.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := pasttense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

   SUBRULE (*6: SENTENCE, zijn*)
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <
       sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            ((SENTENCErec1.conjdeixis = omegadeixis) OR
              (SENTENCErec1.conjdeixis = pastdeixis)
            )
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec1 := CLAUSErec2;
                 CLAUSErec1.superdeixis := pastdeixis;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := pasttense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = pastdeixis)
             A11: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := omegadeixis;
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

>
&
\end{verbatim}

\newpage
\begin{description}
\item[* name:] Rfinpastsuperdeixisspec
\item[* relevant examples:] hij zei (dat hij om 3 uur was gekomen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 19-FEB-1988 
\item[* author:] Lisette Appelo
\item[* copied from:]Rfinpastdeixisspec
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 9/11/88\ \ \ \ \ author: Lisette Appelo 
\item date: 17/05/89\ \ \ \ \ author: Lisette Appelo
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is before: PAST.
               This rule is for a finite dependent clause. This
               is a special rule because the auxiliary verb {\em hebben/zijn} 
               expresses the past and the tense agrees with the tense of the 
               higher clause which is also past. 
               The most right verb in the clause (input generative rule)
gets modus of a past particle.
The auxiliary verb {\em hebben/zijn
} is introduced with a past tense.
               The deixis 
value of the possible reference adverbial is checked for 
               omega.
               The clause is marked for past superdeixis.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different variable categories for the reference 
adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial, perfective aspect rule \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language: This rule has the same semantics as 
Rfinpastsuperdeixis2.\\

\item in other languages: This rule corresponds to the rule for dependent
simple past tense in English and preterito in Spanish. \\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The superdeixis value also may be pastdeixis in the case 
this sentence is a sentence with {\em graag}\\
9/11/88: Added condition on adverbials for pastdeixis to allow {\em hij zei dat 
hij gisteren had gezwommen} as translation of {\em he said that he swam 
yesterday} and {\em dij\'{o} que nad\'{o} ayer.\\
17/05/89: Deleted the subrules in which no adverbial is required. Without the 
adverbial the interpretation should be past retro.
This rule 
corresponds now to Lpastpastsuperdeixis instead of Lpastsuperdeixis. This also 
means that it now corresponds to Rfinpastsuperdeixis2. 
\end{enumerate}
\end{description}

%
%
E 2
E 1
