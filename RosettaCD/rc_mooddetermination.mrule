
DUTCH 5

&
\newpage
\begin{verbatim}
%
% RULE RMooddetermination1     (*declarative main clause, finite, indicative *)
< m1:I6::CLAUSE{CLAUSErec1}
           [ I8:sig3,
             I9:sig4,
             I10:mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      I1:rel1/T2,
                      I2:mu3
                    ],
             mu4
           ] 
>

< m :I7::SENTENCE{SENTENCErec1}
             [ I8:sig3,
               I9:sig4,
               I10:mu1,
               predrel/VERBP{VERBPrec1}
                      [ mu2,
                        I1:rel1/T3,
                        I2:mu3
                      ],
               mu4
             ] 
>

   MATCHCONDITIONS
      <
       I1 : rel1 IN [head, auxrel, progauxrel]
       I2 : ALL(mu3, I12:rel2/..)
       I6 : CLAUSErec1.finiteness = finite  AND
            CLAUSErec1.deixis <> omegadeixis AND
            CLAUSErec1.modus = omegamodus
       I7 : SENTENCErec1.deixis <> omegadeixis AND
            SENTENCErec1 =
		   {
                    modus      : indicative
                    finiteness : finite
 		    mood       : declarative
		    senttype   : mainclause
                    conjkey    : 0
                    adverbial  : false
                    temporal   : false
		    conjclass  : omegaTimeAdvClass
		    conjdeixis : omegadeixis
		    conjaspect : omegaAspect
		    conjretro  : false
		   }


       I12: rel2 IN AUX_postverbrels 
       I8: ALL(sig3, leftdislocrel/..)
       I9: ALL(sig4, shiftrel/..)
       I10: ALL(mu1, I101:rel10/..)
           I101: QUOTE_Srelprec(conjrel, rel10)
      >

<
   SUBRULE (* there is a shiftrel *)
      <sig4: [I3:shiftrel/T1] >
      <sig4: [I3:shiftrel/T1] >

   MATCHCONDITIONS
      <
       I3 : T1.CAT IN [NP, PREPP, ADJP, ADVP, RADVP]
      >


<

   SUBRULE  (* bare V, partV, prepV *)
      <T2:I4::VERB{VERBrec1}[mu5] >
      <T3:I5::VERB{VERBrec2}[mu5] >

   MATCHCONDITIONS
      <
       I4: VERBrec1.status IN [bareV, partV, prepV]
       I5: VERBrec2.status IN [bareV, partV, prepV]
      >

      COMP
         <
          C1: T1.REC.mood = declxpmood AND 
              VERBrec1.modus = omegamodus
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   CLAUSErec1.deixis = presentdeixis AND
                   2 IN VERBrec1.persons
              A11: VERBrec2 := VERBrec1;
                   VERBrec2.persons := [0];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   CLAUSErec1.deixis <> presentdeixis
              A12: VERBrec2 := VERBrec1;
          A1: VERBrec2.modus := indicative;
              SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
		   {
 		    mood     : declarative
		    senttype : mainclause
                    modus    : indicative
		   }
            (* other attributes retain default values *)
         >

      DECOMP
         <
          C1: T1.REC.mood = declxpmood AND
              VERBrec2.modus = indicative 
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   SENTENCErec1.deixis = presentdeixis  AND
                   0 IN VERBrec2.persons
              A11: VERBrec1 := VERBrec2;
                   VERBrec1.persons := [2];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   SENTENCErec1.deixis <> presentdeixis
              A12: VERBrec1 := VERBrec2; 
          A1: VERBrec1.modus := omegamodus;
              CLAUSErec1 := COPYT_sentencetoclause(sentencerec1);
              CLAUSErec1.modus := omegamodus;
         >



   SUBRULE
                   (* probeerde te werken, wilde werken *)
      <T2:VERB{VERBrec1}[I1:sig1, head/I3::VERB{VERBrec2}[mu5], I2:sig2 ] >
      <T3:VERB{VERBrec3}[I1:sig1, head/I4::VERB{VERBrec4}[mu5], I2:sig2 ] >

   MATCHCONDITIONS
      <
        I1: ALL(sig1, adjoinrel/..)
        I2: ALL(sig2, adjoinrel/..)     
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: T1.REC.mood = declxpmood AND 
              VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   CLAUSErec1.deixis = presentdeixis AND
                   2 IN VERBrec1.persons   AND
                   2 IN VERBrec2.persons
              A11: VERBrec3 := VERBrec1;
                   VERBrec4 := VERBrec2;
                   VERBrec3.persons := [0];
                   VERBrec4.persons := [0];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   CLAUSErec1.deixis <> presentdeixis
              A12: VERBrec3 := VERBrec1;
                   VERBrec4 := VERBrec2;
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : declarative
                  senttype : mainclause
                  modus    : indicative
                 };
                (* rest of the attributes remains the same *)
              VERBrec3.modus := indicative;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1: T1.REC.mood = declxpmood AND 
               VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   SENTENCErec1.deixis = presentdeixis  AND
                   0 IN VERBrec3.persons AND
                   0 IN VERBrec4.persons
              A11: VERBrec1 := VERBrec3;
                   VERBrec1.persons := [2];
                   VERBrec2 := VERBrec4;
                   VERBrec2.persons := [2];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   SENTENCErec1.deixis <> presentdeixis
              A12: VERBrec1 := VERBrec2; 
                   VERBrec2 := VERBrec4;
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1.modus := omegamodus;
              VERBrec2.modus := omegamodus;
         >



   SUBRULE
                    (* heeft gewerkt; werd gedood; is gedood ;zat te werken *)
      <T2:VERB{VERBrec1}[I1:rel4/I3::VERB{VERBrec2}[mu5], sig1 ] >
      <T3:VERB{VERBrec3}[I1:rel4/I4::VERB{VERBrec4}[mu5], sig1 ] >

   MATCHCONDITIONS
      <
        I1: rel4 IN [auxrel, progauxrel]
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: T1.REC.mood = declxpmood AND 
              VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   CLAUSErec1.deixis = presentdeixis AND
                   2 IN VERBrec1.persons   AND
                   2 IN VERBrec2.persons
              A11: VERBrec3 := VERBrec1;
                   VERBrec4 := VERBrec2;
                   VERBrec3.persons := [0];
                   VERBrec4.persons := [0];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   CLAUSErec1.deixis <> presentdeixis
              A12: VERBrec3 := VERBrec1;
                   VERBrec4 := VERBrec2;
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : declarative
                  senttype : mainclause
                  modus    : indicative
                 };
                (* rest of the attributes remains the same *)
              VERBrec3.modus := indicative;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1: T1.REC.mood = declxpmood AND 
               VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   SENTENCErec1.deixis = presentdeixis  AND
                   0 IN VERBrec3.persons AND
                   0 IN VERBrec4.persons
              A11: VERBrec1 := VERBrec3;
                   VERBrec1.persons := [2];
                   VERBrec2 := VERBrec4;
                   VERBrec2.persons := [2];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   SENTENCErec1.deixis <> presentdeixis
              A12: VERBrec1 := VERBrec2; 
                   VERBrec2 := VERBrec4;
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1.modus := omegamodus;
              VERBrec2.modus := omegamodus;
         >



>

   SUBRULE (* there is no  shiftrel but a leftdislocrel *)
      <sig4: [] 
       sig3: [leftdislocrel/T4]
      >
      <sig4: []
       sig3: [leftdislocrel/T4]
      >




<

   SUBRULE  (* bare V, partV, prepV *)
      <T2:I4::VERB{VERBrec1}[mu5] >
      <T3:I5::VERB{VERBrec2}[mu5] >

   MATCHCONDITIONS
      <
       I4: VERBrec1.status IN [bareV, partV, prepV]
       I5: VERBrec2.status IN [bareV, partV, prepV]
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus AND
              ((T4.CAT IN [SENTENCE] WITH T4.REC.adverbial = false) ->
               NOT EXIST(mu1,[subjrel/..]))
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   CLAUSErec1.deixis = presentdeixis AND
                   2 IN VERBrec1.persons
              A11: VERBrec2 := VERBrec1;
                   VERBrec2.persons := [0];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   CLAUSErec1.deixis <> presentdeixis
              A12: VERBrec2 := VERBrec1;
          A1:
              VERBrec2.modus := indicative;
              SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
		   {
 		    mood     : declarative
		    senttype : mainclause
                    modus    : indicative
		   }
            (* other attributes retain default values *)
         >

      DECOMP
         <
          C1: VERBrec2.modus = indicative  AND
              ((T4.CAT IN [SENTENCE] WITH T4.REC.adverbial = false) ->
               NOT EXIST(mu1,[subjrel/..]))
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   SENTENCErec1.deixis = presentdeixis  AND
                   0 IN VERBrec2.persons
              A11: VERBrec1 := VERBrec2;
                   VERBrec1.persons := [2];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   SENTENCErec1.deixis <> presentdeixis
              A12: VERBrec1 := VERBrec2; 
          A1:
              VERBrec1.modus := omegamodus;
              CLAUSErec1 := COPYT_sentencetoclause(sentencerec1);
              CLAUSErec1.modus := omegamodus;
         >



   SUBRULE
                   (* probeerde te werken, wilde werken *)
      <T2:VERB{VERBrec1}[I1:sig1, head/I3::VERB{VERBrec2}[mu5], I2:sig2 ] >
      <T3:VERB{VERBrec3}[I1:sig1, head/I4::VERB{VERBrec4}[mu5], I2:sig2 ] >

   MATCHCONDITIONS
      <
        I1: ALL(sig1, adjoinrel/..)
        I2: ALL(sig2, adjoinrel/..)     
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus AND
              ((T4.CAT IN [SENTENCE] WITH T4.REC.adverbial = false) ->
               NOT EXIST(mu1,[subjrel/..]))
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   CLAUSErec1.deixis = presentdeixis AND
                   2 IN VERBrec1.persons   AND
                   2 IN VERBrec2.persons
              A11: VERBrec3 := VERBrec1;
                   VERBrec4 := VERBrec2;
                   VERBrec3.persons := [0];
                   VERBrec4.persons := [0];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   CLAUSErec1.deixis <> presentdeixis
              A12: VERBrec3 := VERBrec1;
                   VERBrec4 := VERBrec2;
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : declarative
                  senttype : mainclause
                  modus    : indicative
                 };
                (* rest of the attributes remains the same *)
              VERBrec3.modus := indicative;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1: VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative AND
              ((T4.CAT IN [SENTENCE] WITH T4.REC.adverbial = false) ->
               NOT EXIST(mu1,[subjrel/..]))
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   SENTENCErec1.deixis = presentdeixis  AND
                   0 IN VERBrec3.persons AND
                   0 IN VERBrec4.persons
              A11: VERBrec1 := VERBrec3;
                   VERBrec1.persons := [2];
                   VERBrec2 := VERBrec4;
                   VERBrec2.persons := [2];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   SENTENCErec1.deixis <> presentdeixis
              A12: VERBrec1 := VERBrec2; 
                   VERBrec2 := VERBrec4;
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1.modus := omegamodus;
              VERBrec2.modus := omegamodus;
         >



   SUBRULE
                    (* heeft gewerkt; werd gedood; is gedood ;zat te werken *)
      <T2:VERB{VERBrec1}[I1:rel4/I3::VERB{VERBrec2}[mu5], sig1 ] >
      <T3:VERB{VERBrec3}[I1:rel4/I4::VERB{VERBrec4}[mu5], sig1 ] >

   MATCHCONDITIONS
      <
        I1: rel4 IN [auxrel, progauxrel]
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus  AND
              ((T4.CAT IN [SENTENCE] WITH T4.REC.adverbial = false) ->
               NOT EXIST(mu1,[subjrel/..]))
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   CLAUSErec1.deixis = presentdeixis AND
                   2 IN VERBrec1.persons
              A11: VERBrec2 := VERBrec1;
                   VERBrec2.persons := [0];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   CLAUSErec1.deixis <> presentdeixis
              A12: VERBrec2 := VERBrec1;
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : declarative
                  senttype : mainclause
                  modus    : indicative
                 };
                (* rest of the attributes remains the same *)
              VERBrec3.modus := indicative;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1: VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative AND
              ((T4.CAT IN [SENTENCE] WITH T4.REC.adverbial = false) ->
               NOT EXIST(mu1,[subjrel/..]))
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   SENTENCErec1.deixis = presentdeixis  AND
                   0 IN VERBrec3.persons AND
                   0 IN VERBrec4.persons
              A11: VERBrec1 := VERBrec3;
                   VERBrec1.persons := [2];
                   VERBrec2 := VERBrec4;
                   VERBrec2.persons := [2];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   SENTENCErec1.deixis <> presentdeixis
              A12: VERBrec1 := VERBrec2; 
                   VERBrec2 := VERBrec4;
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1.modus := omegamodus;
              VERBrec2.modus := omegamodus;
         >



>
>

&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RMooddetermination1
\item[* relevant examples:]
CLAUSE[shift/hij boek koopt] $\rightarrow$\\
SENTENCE[ hij boek koopt]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] CLAUSEtoSENTENCE
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 4-JUN-1987 11:59:08  
\item[* author:] Jan Odijk
\item[* copied from:]--
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To make a finite indicative main clause
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

% RULE Rmood2
                       (* finite, declarative, subordinate *)
< m1: I3::CLAUSE{CLAUSErec1}
                [ I1:sig3, 
                  I2:mu1,
                  predrel/VERBP{VERBPrec1}
                          [ mu2,
                            I5:rel2/T2,
                            I6:mu4 
                          ],
                  mu6
                ]
>

< m : I4::SENTENCE{SENTENCErec1}
                           [I1:sig3, 
                            conjrel/CONJ(KEY_datconjkey){CONJrec1},
                            I2:mu1,
                            predrel/VERBP{VERBPrec1}
                                   [ mu2,
                                     I5:rel2/T3,
                                     I6:mu4 
                                   ],
                             mu6
                           ]
>


   MATCHCONDITIONS
      <
       I1 : ALL(sig3, shiftrel/..) AND 
            NOT EXIST(sig3, [shiftrel/I11::NP{NPrec1}[mu7]]) AND
            NOT EXIST(sig3, [shiftrel/I13::RADVP{RADVPrec1}[mu8]])
            I11: NPrec1.mood = declxpmood
            I13: RADVPrec1.mood = declxpmood
       I2 : NOT EXIST (mu1, [I12:rel1/..])
       I3 : CLAUSErec1.finiteness = finite
       I4 : SENTENCErec1.finiteness = finite AND
            SENTENCErec1 =
		   {
                    modus      : indicative
                    finiteness : finite
 		    mood       : declarative
		    senttype   : subordinateclause
                    conjkey    : KEY_datCONJkey
                    adverbial  : false
                    temporal   : false
		    conjclass  : omegaTimeAdvClass
		    conjdeixis : omegadeixis
		    conjaspect : omegaAspect
		    conjretro  : false
		   }
       I5 : rel2 IN [head, progauxrel, auxrel]
       I6 : ALL(mu4, I16:rel5/..)
       I12: rel1 IN [leftdislocrel, shiftrel]
       I16: rel5 IN AUX_postverbrels
      >


<

   SUBRULE  (* bare V, partV, prepV *)
      <T2:I4::VERB{VERBrec1}[mu5] >
      <T3:I5::VERB{VERBrec2}[mu5] >

   MATCHCONDITIONS
      <
       I4: VERBrec1.status IN [bareV, partV, prepV]
       I5: VERBrec2.status IN [bareV, partV, prepV]
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus
          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := indicative;
              SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
		   {
 		    mood     : declarative
		    senttype : subordinateclause
                    modus    : indicative
                    conjkey  : KEY_datCONJkey
		   }
            (* other attributes retain default values *)
         >

      DECOMP
         <
          C1: VERBrec2.modus = indicative 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1 := COPYT_sentencetoclause(sentencerec1);
              CLAUSErec1.modus := omegamodus;
         >



   SUBRULE
                   (* probeerde te werken, wilde werken *)
      <T2:VERB{VERBrec1}[I1:sig1, head/I3::VERB{VERBrec2}[mu5], I2:sig2 ] >
      <T3:VERB{VERBrec3}[I1:sig1, head/I4::VERB{VERBrec4}[mu5], I2:sig2 ] >

   MATCHCONDITIONS
      <
        I1: ALL(sig1, adjoinrel/..)
        I2: ALL(sig2, adjoinrel/..)     
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : declarative
                  senttype : subordinateclause
                  modus    : indicative
                  conjkey  : KEY_datCONJkey
                 };
                (* rest of the attributes remains the same *)
              VERBrec3 := VERBrec1;
              VERBrec3.modus := indicative;
              VERBrec4 := VERBrec2;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1:  
               VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1 := VERBrec3;
              VERBrec1.modus := omegamodus;
              VERBrec2 := VERBrec4;
              VERBrec2.modus := omegamodus;
         >



   SUBRULE
                    (* heeft gewerkt; werd gedood; is gedood ;zat te werken *)
      <T2:VERB{VERBrec1}[I1:rel4/I3::VERB{VERBrec2}[mu5], sig1 ] >
      <T3:VERB{VERBrec3}[I1:rel4/I4::VERB{VERBrec4}[mu5], sig1 ] >

   MATCHCONDITIONS
      <
        I1: rel4 IN [auxrel, progauxrel]
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : declarative
                  senttype : subordinateclause
                  modus    : indicative
                  conjkey  : KEY_datCONJkey
                 };
                (* rest of the attributes remains the same *)
              VERBrec3 := VERBrec1;
              VERBrec3.modus := indicative;
              VERBrec4 := VERBrec2;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1:  
               VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1 := VERBrec3;
              VERBrec1.modus := omegamodus;
              VERBrec2 := VERBrec4;
              VERBrec2.modus := omegamodus;
         >



>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rmood2
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] ClausetoSentence
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 1-FEB-1988 15:12:55  
\item[* author:] Jan Odijk
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


% RULE RMood3     (*wh main clause, finite, indicative *)
< m1:I6::CLAUSE{CLAUSErec1}
           [ I3:shiftrel/T1,
             mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      I1:rel1/T2,
                      I2:mu3
                    ],
             mu4
           ] 
>

< m :I7::SENTENCE{SENTENCErec1}
             [ I3:shiftrel/T1,
               mu1,
               predrel/VERBP{VERBPrec1}
                      [ mu2,
                        I1:rel1/T3,
                        I2:mu3
                      ],
               mu4
             ] 
>

   MATCHCONDITIONS
      <
       I1 : rel1 IN [head, auxrel, progauxrel]
       I2 : ALL(mu3, I12:rel2/..)
       I3 : T1.CAT IN [NP, PREPP, ADJP, ADVP, RADVP]
       I6 : CLAUSErec1.finiteness = finite  AND
            CLAUSErec1.deixis <> omegadeixis AND
            CLAUSErec1.modus = omegamodus
       I7 : SENTENCErec1.deixis <> omegadeixis AND
            SENTENCErec1 =
		   {
                    modus      : indicative
                    finiteness : finite
 		    mood       : whinterrogative
		    senttype   : mainclause
                    conjkey    : 0
                    adverbial  : false
                    temporal   : false
		    conjclass  : omegaTimeAdvClass
		    conjdeixis : omegadeixis
		    conjaspect : omegaAspect
		    conjretro  : false
		   }


       I12: rel2 IN AUX_postverbrels 
      >


<

   SUBRULE  (* bare V, partV, prepV *)
      <T2:I4::VERB{VERBrec1}[mu5] >
      <T3:I5::VERB{VERBrec2}[mu5] >

   MATCHCONDITIONS
      <
       I4: VERBrec1.status IN [bareV, partV, prepV]
       I5: VERBrec2.status IN [bareV, partV, prepV]
      >

      COMP
         <
          C1: T1.REC.mood = wh AND 
              VERBrec1.modus = omegamodus
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   CLAUSErec1.deixis = presentdeixis AND
                   2 IN VERBrec1.persons
              A11: VERBrec2 := VERBrec1;
                   VERBrec2.persons := [0];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   CLAUSErec1.deixis <> presentdeixis
              A12: VERBrec2 := VERBrec1;
          A1: VERBrec2.modus := indicative;
              SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
		   {
 		    mood     : whinterrogative
		    senttype : mainclause
                    modus    : indicative
		   }
            (* other attributes retain default values *)
         >

      DECOMP
         <
          C1: T1.REC.mood = wh AND
              VERBrec2.modus = indicative
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   SENTENCErec1.deixis = presentdeixis  AND
                   0 IN VERBrec2.persons
              A11: VERBrec1 := VERBrec2;
                   VERBrec1.persons := [2];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   SENTENCErec1.deixis <> presentdeixis
              A12: VERBrec1 := VERBrec2; 
          A1: VERBrec1.modus := omegamodus;
              CLAUSErec1 := COPYT_sentencetoclause(sentencerec1);
              CLAUSErec1.modus := omegamodus;
         >



   SUBRULE
                   (* probeerde te werken, wilde werken *)
      <T2:VERB{VERBrec1}[I1:sig1, head/I3::VERB{VERBrec2}[mu5], I2:sig2 ] >
      <T3:VERB{VERBrec3}[I1:sig1, head/I4::VERB{VERBrec4}[mu5], I2:sig2 ] >

   MATCHCONDITIONS
      <
        I1: ALL(sig1, adjoinrel/..)
        I2: ALL(sig2, adjoinrel/..)     
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: T1.REC.mood = wh AND 
              VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   CLAUSErec1.deixis = presentdeixis AND
                   2 IN VERBrec1.persons AND
                   2 IN VERBrec2.persons
              A11: VERBrec3 := VERBrec1;
                   VERBrec3.persons := [0];
                   VERBrec4 := VERBrec2;
                   VERBrec4.persons := [0];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   CLAUSErec1.deixis <> presentdeixis
              A12: VERBrec3 := VERBrec1; 
                   VERBrec4 := VERBrec2;
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : whinterrogative
                  senttype : mainclause
                  modus    : indicative
                 };
                (* rest of the attributes remains the same *)
              VERBrec3.modus := indicative;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1: T1.REC.mood = wh AND 
               VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative
	       C11: QUOTE_Contains2sgsubj(mu1) AND
                    SENTENCErec1.deixis = presentdeixis  AND
		    0 IN VERBrec3.persons AND
		    0 IN VERBrec4.persons
	       A11: VERBrec1 := VERBrec3;
		    VERBrec1.persons := [2];
		    VERBrec2 := VERBrec4;
		    VERBrec2.persons := [2];
	       C12: NOT QUOTE_Contains2sgsubj(mu1)  OR
                    SENTENCErec1.deixis <> presentdeixis
	       A12: VERBrec1 := VERBrec3; 
		    VERBrec2 := VERBrec4;
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1.modus := omegamodus;
              VERBrec2.modus := omegamodus;
         >



   SUBRULE
                    (* heeft gewerkt; werd gedood; is gedood ;zat te werken *)
      <T2:VERB{VERBrec1}[I1:rel4/I3::VERB{VERBrec2}[mu5], sig1 ] >
      <T3:VERB{VERBrec3}[I1:rel4/I4::VERB{VERBrec4}[mu5], sig1 ] >

   MATCHCONDITIONS
      <
        I1: rel4 IN [auxrel, progauxrel]
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: T1.REC.mood = wh AND 
              VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   CLAUSErec1.deixis = presentdeixis AND
                   2 IN VERBrec1.persons AND
                   2 IN VERBrec2.persons
              A11: VERBrec3 := VERBrec1;
                   VERBrec3.persons := [0];
                   VERBrec4 := VERBrec2;
                   VERBrec4.persons := [0];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   CLAUSErec1.deixis <> presentdeixis
              A12: VERBrec3 := VERBrec1; 
                   VERBrec4 := VERBrec2;
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : whinterrogative
                  senttype : mainclause
                  modus    : indicative
                 };
                (* rest of the attributes remains the same *)
              VERBrec3.modus := indicative;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1: T1.REC.mood = wh AND 
               VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative
	       C11: QUOTE_Contains2sgsubj(mu1) AND
                    SENTENCErec1.deixis = presentdeixis  AND
		    0 IN VERBrec3.persons AND
		    0 IN VERBrec4.persons
	       A11: VERBrec1 := VERBrec3;
		    VERBrec1.persons := [2];
		    VERBrec2 := VERBrec4;
		    VERBrec2.persons := [2];
	       C12: NOT QUOTE_Contains2sgsubj(mu1)   OR
                    SENTENCErec1.deixis <> presentdeixis
	       A12: VERBrec1 := VERBrec3; 
		    VERBrec2 := VERBrec4;
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1.modus := omegamodus;
              VERBrec2.modus := omegamodus;
         >



>

&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RMood3
\item[* relevant examples:]
CLAUSE[shift/wie boeken koopt] $\rightarrow$\\
SENTENCE[ wie boeken koopt]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] CLAUSEtoSENTENCE
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 4-JUN-1987 11:59:08  
\item[* author:] Jan Odijk
\item[* copied from:]--
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To make a finite indicative main clause
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


% RULE RMood4         (*yes-no-interrogative main clause, finite, indicative *)
< m1:I6::CLAUSE{CLAUSErec1}
           [ I3:mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      I1:rel1/T2,
                      I2:mu3
                    ],
             mu4
           ] 
>

< m :I7::SENTENCE{SENTENCErec1}
             [ I3:mu1,
               predrel/VERBP{VERBPrec1}
                      [ mu2,
                        I1:rel1/T3,
                        I2:mu3
                      ],
               mu4
             ] 
>

   MATCHCONDITIONS
      <
       I1 : rel1 IN [head, auxrel, progauxrel]
       I2 : ALL(mu3, I12:rel2/..)
       I3 : NOT EXIST(mu1, [I31:rel3/..]) AND
            (EXIST(mu1,[leftdislocrel/..]) -> EXIST(mu1,[subjrel/..]))
            I31: rel3 IN [shiftrel, conjrel] 
       I6 : CLAUSErec1.finiteness = finite  AND
            CLAUSErec1.deixis <> omegadeixis AND
            CLAUSErec1.modus = omegamodus
       I7 : SENTENCErec1.deixis <> omegadeixis AND
            SENTENCErec1 =
		   {
                    modus      : indicative
                    finiteness : finite
 		    mood       : yesnointerrogative
		    senttype   : mainclause
                    conjkey    : 0
                    adverbial  : false
                    temporal   : false
		    conjclass  : omegaTimeAdvClass
		    conjdeixis : omegadeixis
		    conjaspect : omegaAspect
		    conjretro  : false
		   }


       I12: rel2 IN AUX_postverbrels 
      >


<

   SUBRULE  (* bare V, partV, prepV *)
      <T2:I4::VERB{VERBrec1}[mu5] >
      <T3:I5::VERB{VERBrec2}[mu5] >

   MATCHCONDITIONS
      <
       I4: VERBrec1.status IN [bareV, partV, prepV]
       I5: VERBrec2.status IN [bareV, partV, prepV]
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   CLAUSErec1.deixis = presentdeixis AND
                   2 IN VERBrec1.persons
              A11: VERBrec2 := VERBrec1;
                   VERBrec2.persons := [0];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   CLAUSErec1.deixis <> presentdeixis
              A12: VERBrec2 := VERBrec1;

          A1: VERBrec2.modus := indicative;
              SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
		   {
 		    mood     : yesnointerrogative
		    senttype : mainclause
                    modus    : indicative
		   }
            (* other attributes retain default values *)
         >

      DECOMP
         <
          C1: VERBrec2.modus = indicative 
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   SENTENCErec1.deixis = presentdeixis  AND
                   0 IN VERBrec2.persons
              A11: VERBrec1 := VERBrec2;
                   VERBrec1.persons := [2];
              C12: NOT QUOTE_Contains2sgsubj(mu1)   OR
                    SENTENCErec1.deixis <> presentdeixis
              A12: VERBrec1 := VERBrec2; 
          A1: VERBrec1.modus := omegamodus;
              CLAUSErec1 := COPYT_sentencetoclause(sentencerec1);
              CLAUSErec1.modus := omegamodus;
         >



   SUBRULE
                   (* probeerde te werken, wilde werken *)
      <T2:VERB{VERBrec1}[I1:sig1, head/I3::VERB{VERBrec2}[mu5], I2:sig2 ] >
      <T3:VERB{VERBrec3}[I1:sig1, head/I4::VERB{VERBrec4}[mu5], I2:sig2 ] >

   MATCHCONDITIONS
      <
        I1: ALL(sig1, adjoinrel/..)
        I2: ALL(sig2, adjoinrel/..)     
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   CLAUSErec1.deixis = presentdeixis AND
                   2 IN VERBrec1.persons AND
                   2 IN VERBrec2.persons
              A11: VERBrec3 := VERBrec1;
                   VERBrec3.persons := [0];
                   VERBrec4 := VERBrec2;
                   VERBrec4.persons := [0];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   CLAUSErec1.deixis <> presentdeixis
              A12: VERBrec3 := VERBrec1; 
                   VERBrec4 := VERBrec2;
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : yesnointerrogative
                  senttype : mainclause
                  modus    : indicative
                 };
                (* rest of the attributes remains the same *)
              VERBrec3.modus := indicative;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1: 
               VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative
	       C11: QUOTE_Contains2sgsubj(mu1) AND
                    SENTENCErec1.deixis = presentdeixis  AND
		    0 IN VERBrec3.persons AND
		    0 IN VERBrec4.persons
	       A11: VERBrec1 := VERBrec3;
		    VERBrec1.persons := [2];
		    VERBrec2 := VERBrec4;
		    VERBrec2.persons := [2];
	       C12: NOT QUOTE_Contains2sgsubj(mu1)   OR
                    SENTENCErec1.deixis <> presentdeixis
	       A12: VERBrec1 := VERBrec3; 
		    VERBrec2 := VERBrec4;
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1.modus := omegamodus;
              VERBrec2.modus := omegamodus;
         >



   SUBRULE
                    (* heeft gewerkt; werd gedood; is gedood ;zat te werken *)
      <T2:VERB{VERBrec1}[I1:rel4/I3::VERB{VERBrec2}[mu5], sig1 ] >
      <T3:VERB{VERBrec3}[I1:rel4/I4::VERB{VERBrec4}[mu5], sig1 ] >

   MATCHCONDITIONS
      <
        I1: rel4 IN [auxrel, progauxrel]
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
              C11: QUOTE_Contains2sgsubj(mu1) AND
                   CLAUSErec1.deixis = presentdeixis AND
                   2 IN VERBrec1.persons AND
                   2 IN VERBrec2.persons
              A11: VERBrec3 := VERBrec1;
                   VERBrec3.persons := [0];
                   VERBrec4 := VERBrec2;
                   VERBrec4.persons := [0];
              C12: NOT QUOTE_Contains2sgsubj(mu1) OR
                   CLAUSErec1.deixis <> presentdeixis
              A12: VERBrec3 := VERBrec1; 
                   VERBrec4 := VERBrec2;
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : yesnointerrogative
                  senttype : mainclause
                  modus    : indicative
                 };
                (* rest of the attributes remains the same *)
              VERBrec3.modus := indicative;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1: 
               VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative
	       C11: QUOTE_Contains2sgsubj(mu1) AND
                    SENTENCErec1.deixis = presentdeixis  AND
		    0 IN VERBrec3.persons AND
		    0 IN VERBrec4.persons
	       A11: VERBrec1 := VERBrec3;
		    VERBrec1.persons := [2];
		    VERBrec2 := VERBrec4;
		    VERBrec2.persons := [2];
	       C12: NOT QUOTE_Contains2sgsubj(mu1)   OR
                    SENTENCErec1.deixis <> presentdeixis
	       A12: VERBrec1 := VERBrec3; 
		    VERBrec2 := VERBrec4;
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1.modus := omegamodus;
              VERBrec2.modus := omegamodus;
         >



>

&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RMood4
\item[* relevant examples:]
CLAUSE[subjrel/hij boeken koopt] $\rightarrow$\\
SENTENCE[ hij boeken koopt]  (uiteindelijk: koopt hij boeken?)
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] CLAUSEtoSENTENCE
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 4-JUN-1987 11:59:08  
\item[* author:] Jan Odijk
\item[* copied from:]--
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To make a finite indicative main clause
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


% RULE Rmood5
                       (* finite, yesnointerrogative, subordinate *)
< m1: I3::CLAUSE{CLAUSErec1}
                [ I2:mu1,
                  predrel/VERBP{VERBPrec1}
                          [ mu2,
                            I5:rel2/T2,
                            I6:mu4 
                          ],
                  mu6
                ]
>

< m : I4::SENTENCE{SENTENCErec1}
                           [conjrel/CONJ(KEY_ofconjkey){CONJrec1},
                            I2:mu1,
                            predrel/VERBP{VERBPrec1}
                                   [ mu2,
                                     I5:rel2/T3,
                                     I6:mu4 
                                   ],
                            mu6
                           ]
>


   MATCHCONDITIONS
      <
       I2 : NOT EXIST (mu1, [I12:rel1/..])
       I3 : CLAUSErec1.finiteness = finite
       I4 : SENTENCErec1 =
                 {
                  finiteness: finite
                  mood      : yesnointerrogative
                  senttype  : subordinateclause
                  modus     : indicative
                  conjkey   : KEY_ofCONJkey
                  adverbial : false
                  temporal  : false
                  conjclass : omegaTimeadvClass
                  conjdeixis: omegadeixis
                  conjaspect: omegaAspect
                  conjretro : false
                 }                                            
       I5 : rel2 IN [head, progauxrel, auxrel]
       I6 : ALL(mu4, I16:rel5/..)
       I12: rel1 IN [leftdislocrel, shiftrel, conjrel]
       I16: rel5 IN AUX_postverbrels
      >


<

   SUBRULE  (* bare V, partV, prepV *)
      <T2:I4::VERB{VERBrec1}[mu5] >
      <T3:I5::VERB{VERBrec2}[mu5] >

   MATCHCONDITIONS
      <
       I4: VERBrec1.status IN [bareV, partV, prepV]
       I5: VERBrec2.status IN [bareV, partV, prepV]
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus
          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := indicative;
              SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
		   {
 		    mood     : yesnointerrogative
		    senttype : subordinateclause
                    modus    : indicative
		   }
            (* other attributes retain default values *)
         >

      DECOMP
         <
          C1: VERBrec2.modus = indicative 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1 := COPYT_sentencetoclause(sentencerec1);
              CLAUSErec1.modus := omegamodus;
         >



   SUBRULE
                   (* probeerde te werken, wilde werken *)
      <T2:VERB{VERBrec1}[I1:sig1, head/I3::VERB{VERBrec2}[mu5], I2:sig2 ] >
      <T3:VERB{VERBrec3}[I1:sig1, head/I4::VERB{VERBrec4}[mu5], I2:sig2 ] >

   MATCHCONDITIONS
      <
        I1: ALL(sig1, adjoinrel/..)
        I2: ALL(sig2, adjoinrel/..)     
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : yesnointerrogative
                  senttype : subordinateclause
                  modus    : indicative
                 };
                (* rest of the attributes remains the same *)
              VERBrec3 := VERBrec1;
              VERBrec3.modus := indicative;
              VERBrec4 := VERBrec2;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1:  

               VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1 := VERBrec3;
              VERBrec1.modus := omegamodus;
              VERBrec2 := VERBrec4;
              VERBrec2.modus := omegamodus;
         >



   SUBRULE
                    (* heeft gewerkt; werd gedood; is gedood ;zat te werken *)
      <T2:VERB{VERBrec1}[I1:rel4/I3::VERB{VERBrec2}[mu5], sig1 ] >
      <T3:VERB{VERBrec3}[I1:rel4/I4::VERB{VERBrec4}[mu5], sig1 ] >

   MATCHCONDITIONS
      <
        I1: rel4 IN [auxrel, progauxrel]
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : yesnointerrogative
                  senttype : subordinateclause
                  modus    : indicative
                 };
                (* rest of the attributes remains the same *)
              VERBrec3 := VERBrec1;
              VERBrec3.modus := indicative;
              VERBrec4 := VERBrec2;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1:  
               VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1 := VERBrec3;
              VERBrec1.modus := omegamodus;
              VERBrec2 := VERBrec4;
              VERBrec2.modus := omegamodus;
         >



>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rmood5
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] ClausetoSentence
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 1-FEB-1988 15:12:55  
\item[* author:] Jan Odijk
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


% RULE RMood6     (*wh subordinate clause, finite, indicative *)
< m1:I6::CLAUSE{CLAUSErec1}
           [ I3:shiftrel/T1,
             I4:mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      I1:rel1/T2,
                      I2:mu3
                    ],
             mu4
           ] 
>

< m :I7::SENTENCE{SENTENCErec1}
             [ I3:shiftrel/T1,
               conjrel/CONJ(KEY_ofCONJkey){CONJrec1},
               I4:mu1,
               predrel/VERBP{VERBPrec1}
                      [ mu2,
                        I1:rel1/T3,
                        I2:mu3
                      ],
               mu4
             ] 
>

   MATCHCONDITIONS
      <
       I1 : rel1 IN [head, auxrel, progauxrel]
       I2 : ALL(mu3, I12:rel2/..)
       I3 : T1.CAT IN [NP, PREPP, ADJP, ADVP, RADVP]
       I4 : NOT EXIST(mu1, [conjrel/..])
       I6 : CLAUSErec1.finiteness = finite  
       I7 : (* SENTENCErec1.deixis <> omegadeixis AND removed JO  
                 20-DEC-1988 13:38:10 *)
            SENTENCErec1 =
		   {
                    modus      : indicative
                    finiteness : finite
 		    mood       : whinterrogative
		    senttype   : subordinateclause
                    conjkey    : KEY_ofCONJkey
                    adverbial  : false
                    temporal   : false
		    conjclass  : omegaTimeAdvClass
		    conjdeixis : omegadeixis
		    conjaspect : omegaAspect
		    conjretro  : false
		   }


       I12: rel2 IN AUX_postverbrels 
      >


<

   SUBRULE  (* bare V, partV, prepV *)
      <T2:I4::VERB{VERBrec1}[mu5] >
      <T3:I5::VERB{VERBrec2}[mu5] >

   MATCHCONDITIONS
      <
       I4: VERBrec1.status IN [bareV, partV, prepV]
       I5: VERBrec2.status IN [bareV, partV, prepV]
      >

      COMP
         <
          C1: T1.REC.mood = wh AND 
              VERBrec1.modus = omegamodus
          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := indicative;
              SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
		   {
 		    mood     : whinterrogative
		    senttype : subordinateclause
                    modus    : indicative
                    conjkey    : KEY_ofCONJkey
		   }
            (* other attributes retain default values *)
         >

      DECOMP
         <
          C1: T1.REC.mood = wh AND
              VERBrec2.modus = indicative 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1 := COPYT_sentencetoclause(sentencerec1);
              CLAUSErec1.modus := omegamodus;
         >



   SUBRULE
                   (* probeerde te werken, wilde werken *)
      <T2:VERB{VERBrec1}[I1:sig1, head/I3::VERB{VERBrec2}[mu5], I2:sig2 ] >
      <T3:VERB{VERBrec3}[I1:sig1, head/I4::VERB{VERBrec4}[mu5], I2:sig2 ] >

   MATCHCONDITIONS
      <
        I1: ALL(sig1, adjoinrel/..)
        I2: ALL(sig2, adjoinrel/..)     
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: T1.REC.mood = wh AND 
              VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : whinterrogative
                  senttype : subordinateclause
                  modus    : indicative
                  conjkey    : KEY_ofCONJkey
                 };
                (* rest of the attributes remains the same *)
              VERBrec3 := VERBrec1;
              VERBrec3.modus := indicative;
              VERBrec4 := VERBrec2;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1: T1.REC.mood = wh AND 
               VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1 := VERBrec3;
              VERBrec1.modus := omegamodus;
              VERBrec2 := VERBrec4;
              VERBrec2.modus := omegamodus;
         >



   SUBRULE
                    (* heeft gewerkt; werd gedood; is gedood ;zat te werken *)
      <T2:VERB{VERBrec1}[I1:rel4/I3::VERB{VERBrec2}[mu5], sig1 ] >
      <T3:VERB{VERBrec3}[I1:rel4/I4::VERB{VERBrec4}[mu5], sig1 ] >

   MATCHCONDITIONS
      <
        I1: rel4 IN [auxrel, progauxrel]
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
      >

      COMP
         <
          C1: T1.REC.mood = wh AND 
              VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : whinterrogative
                  senttype : subordinateclause
                  modus    : indicative
                  conjkey    : KEY_ofCONJkey
                 };
                (* rest of the attributes remains the same *)
              VERBrec3 := VERBrec1;
              VERBrec3.modus := indicative;
              VERBrec4 := VERBrec2;
              VERBrec4.modus := indicative;
         >
      DECOMP
         <
          C1: T1.REC.mood = wh AND 
               VERBrec3.modus = indicative                    AND
               VERBrec4.modus = indicative
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              VERBrec1 := VERBrec3;
              VERBrec1.modus := omegamodus;
              VERBrec2 := VERBrec4;
              VERBrec2.modus := omegamodus;
         >



>

&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RMood6
\item[* relevant examples:]
CLAUSE[shift/wie boeken koopt] $\rightarrow$\\
SENTENCE[ wie of boeken koopt]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] CLAUSEtoSENTENCE
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 4-JUN-1987 11:59:08  
\item[* author:] Jan Odijk
\item[* copied from:]--
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To make a finite indicative main clause
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
% RULE Rmoodinfrel
< m1: I3::CLAUSE{CLAUSErec1}
                [ I1:shiftrel/T4, 
                  I2:subjrel/T1,
                  mu1,
                  predrel/VERBP{VERBPrec1}
                          [ mu2,
                            I5:rel2/T2,
                            I6:mu4 
                          ],
                  mu6
                ]
>

< m : I4::SENTENCE{SENTENCErec1}
                           [I1:shiftrel/T4,
                            conjrel/CONJ(AUX_omCONJkey){CONJrec1},
                            I2:subjrel/T1, 
                            mu1,
                            predrel/VERBP{VERBPrec1}
                                   [ mu2,
                                     I5:rel2/T3,
                                     I6:mu4 
                                   ],
                            mu6
                           ]
>


   MATCHCONDITIONS
      <
       I1 : T4.CAT IN [NPVAR, VARPREPP, CNVAR] OR
            (T4.CAT = RADVP AND QUOTE_varinradv(T4))
       I2 : T1.CAT IN [NPVAR, CNVAR] OR QUOTE_bigpronp(T1)
       I3 : CLAUSErec1.finiteness = infinite AND
            CLAUSErec1.PROsubject =true AND
            CLAUSErec1.infsort = omegainf AND
            CLAUSErec1.aspect = perfective
       I4 : SENTENCErec1 =
		   {
 		    mood       : relative
		    senttype   : subordinateclause
                    modus      : infinitive
                    finiteness : infinite
                    PROsubject : true
                    infsort    : omteinf
                    adverbial  : false
                    temporal   : false
                    aspect     : perfective
                    conjclass  : omegaTimeadvClass
                    conjdeixis : omegadeixis
                    conjaspect : omegaAspect
                    conjretro  : false
		   }
       I5 : rel2 IN [head, progauxrel, auxrel]
       I6 : ALL(mu4, I16:rel5/..)
       I16: rel5 IN AUX_postverbrels
      >


<

   SUBRULE  (* bare V*)
      <T2:I4::VERB{VERBrec1}[mu5] >
      <T3:I6::VERB{VERBrec3}
              [ terel/TE(AUX_teTEkey){TErec1},
                head/I5::VERB{VERBrec2}[mu5]
              ] 
      >

   MATCHCONDITIONS
      <
       I4: VERBrec1.status IN [bareV ]
       I5: VERBrec2.status IN [bareV ]
       I6: VERBrec3.status IN [teV]
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus
          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := infinitive;
              VERBrec3 := VERBrec1;
              VERBrec3.modus := infinitive;
              VERBrec3.status := teV;
              SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
		   {
 		    mood     : relative
		    senttype : subordinateclause
                    modus    : infinitive
                    infsort  : omteinf
		   }
            (* other attributes retain default values *)
         >

      DECOMP
         <
          C1: VERBrec2.modus = infinitive AND
              VERBrec3 = VERBrec2 EXCEPT FOR [status] 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1 := COPYT_sentencetoclause(sentencerec1);
              CLAUSErec1.modus := omegamodus;
              CLAUSErec1.infsort := omegainf;
         >


   SUBRULE  (* partV *)
      <T2:I4::VERB{VERBrec1}[head/SUBVERB{SUBVERBrec1}
                                 [ partrel/PART{PARTrec1},
                                   head/SUBVERB{SUBVERBrec2}[mu5] 
                                 ]
                            ] 
      >
      <T3:I6::VERB{VERBrec4}
                  [ partrel/PART{PARTrec1},
		    head/I7::VERB{VERBrec3}
			     [ terel/TE(AUX_teTEkey){TErec1},
			       head/I5::VERB{VERBrec2}
                                            [ head/SUBVERB{SUBVERBrec2}[mu5]
                                            ]
			     ]
                  ] 
      >

   MATCHCONDITIONS
      <
       I4: VERBrec1.status IN [partV]
       I5: VERBrec2.status IN [bareV ]
       I6: VERBrec4.status IN [partteV]
       I7: VERBrec3.status IN [teV] 
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus AND
              SUBVERBrec1 = SUBVERBrec2 EXCEPT FOR [lastaffix] AND
              SUBVERBrec1.lastaffix = partaffix 
          A1: VERBrec2 := VERBrec1;
              VERBrec2.modus := infinitive;
              VERBrec2.status := bareV;
              VERBrec3 := VERBrec1;
              VERBrec3.modus := infinitive;
              VERBrec3.status := teV;
              VERBrec4 := VERBrec1;
              VERBrec4.modus := infinitive;
              VERBrec4.status := partteV;
              SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
		   {
 		    mood     : relative
		    senttype : subordinateclause
                    modus    : infinitive
                    infsort  : omteinf
		   }
            (* other attributes retain default values *)
         >


      DECOMP
         <
          C1: VERBrec2.modus = infinitive AND
              VERBrec3 = VERBrec2 EXCEPT FOR [status] AND
              VERBrec4 = VERBrec2 EXCEPT FOR [status]
          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              VERBrec1.status := partV;
              SUBVERBrec1 := SUBVERBrec2;
              SUBVERBrec1.lastaffix := partaffix;
              CLAUSErec1 := COPYT_sentencetoclause(sentencerec1);
              CLAUSErec1.modus := omegamodus;
              CLAUSErec1.infsort := omegainf;
         >



   SUBRULE (* prepV*)
      <T2:I4::VERB{VERBrec1}
                  [ partrel/PREP{PREPrec1},
                    gluerel/GLUE{GLUErec1},
                    head/I5::VERB{VERBrec2}[mu5] 
                  ]
      >
      <T3:I6::VERB{VERBrec3}
                  [ partrel/PREP{PREPrec1},
                    head/I7::VERB{VERBrec4}
                        [ terel/TE(AUX_teTEkey){TErec1}, 
                          head/I8::VERB{VERBrec5}[mu5] 
                        ]
                  ]
         
      >

   MATCHCONDITIONS
      <
       I4: VERBrec1.status IN [prepV ]
       I5: VERBrec2.status IN [bareV ]
       I6: VERBrec3.status IN [prepteV]
       I7: VERBrec4.status IN [teV]
       I8: VERBrec5.status IN [bareV]
 
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus 
          A1: VERBrec3 := VERBrec1;
              VERBrec3.status := prepteV;
              VERBrec3.modus  := infinitive;
              VERBrec4 := VERBrec1;
              VERBrec4.status := teV;
              VERBrec4.modus  := infinitive;
              VERBrec5 := VERBrec2;
              VERBrec5.modus  := infinitive;
              SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
		   {
 		    mood     : relative
		    senttype : subordinateclause
                    modus    : infinitive
                    infsort  : omteinf
		   }
            (* other attributes retain default values *)
         >
      DECOMP
         <
          C1: VERBrec3 = VERBrec4 EXCEPT FOR [status] AND
              VERBrec5.modus = infinitive AND
              VERBrec3.modus = infinitive               
          A1: VERBrec1 := VERBrec3;
              VERBrec1.status := prepV;
              VERBrec1.modus := omegamodus;
              VERBrec2.modus := omegamodus;
              CLAUSErec1 := COPYT_sentencetoclause(sentencerec1);
              CLAUSErec1.modus := omegamodus;
              CLAUSErec1.infsort := omegainf;
         >


   SUBRULE
                   (* te proberen te werken, te willen werken *)
      <T2:I6::VERB{VERBrec1}[I1:sig1, head/I3::VERB{VERBrec2}[mu5], I2:sig2 ] >
      <T3:I7::VERB{VERBrec3}[I1:sig1, 
                         head/I5::VERB{VERBrec5}
                             [ terel/TE(AUX_teTEkey){TErec1}, 
                               head/I4::VERB{VERBrec4}[mu5]
                             ],
                         I2:sig2 
                        ] 
      >

   MATCHCONDITIONS
      <
        I1: ALL(sig1, adjoinrel/..)
        I2: ALL(sig2, adjoinrel/..)     
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV 
        I5: VERBrec5.status = teV 
        I6: VERBrec1.status = VV
        I7: VERBrec3.status = teVV
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : relative
                  senttype : subordinateclause
                  modus    : infinitive
                  infsort  : omteinf
                 };
                (* rest of the attributes remains the same *)
              VERBrec3 := VERBrec1;
              VERBrec3.modus := infinitive;
              VERBrec3.status := teVV;
              VERBrec4 := VERBrec2;
              VERBrec4.modus := infinitive;
              VERBrec5 := VERBrec2;
              VERBrec5.status := teV;
              VERBrec5.modus := infinitive
         >
      DECOMP
         <
          C1:  
               VERBrec3.modus = infinitive                    AND
               VERBrec4.modus = infinitive                    AND
               VERBrec5 = VERBrec4 EXCEPT FOR [status]
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              CLAUSErec1.infsort := omegainf;
              VERBrec1 := VERBrec3;
              VERBrec1.modus := omegamodus;
              VERBrec1.status := VV;
              VERBrec2 := VERBrec4;
              VERBrec2.modus := omegamodus;
         >



   SUBRULE
                    (* te hebben gewerkt; te worden  gedood; te zijn gedood ;
                         te zitten te werken *)
      <T2:I2::VERB{VERBrec1}[I1:rel4/I3::VERB{VERBrec2}[mu5], sig1 ] >
      <T3:I6::VERB{VERBrec3}
             [ I1:rel4/I5::VERB{VERBrec5}
                      [  terel/TE(AUX_teTEkey){TErec1},
                         head/I4::VERB{VERBrec4}[mu5]
                      ], 
               sig1 
             ]
      >

   MATCHCONDITIONS
      <
        I1: rel4 IN [auxrel, progauxrel]
        I2: VERBrec1.status IN [AuxV]
        I3: VERBrec2.status = bareV
        I4: VERBrec4.status = bareV  
        I6: VERBrec3.status IN [teAuxV]
      >

      COMP
         <
          C1: VERBrec1.modus = omegamodus AND
              VERBrec2.modus = omegamodus
          A1: SENTENCErec1 := COPYT_clausetosentence(CLAUSErec1);
              SENTENCErec1 :=
                 {
                  mood     : relative
                  senttype : subordinateclause
                  modus    : infinitive
                  infsort  : omteinf
                 };
                (* rest of the attributes remains the same *)
              VERBrec3 := VERBrec1;
              VERBrec3.modus := infinitive;
              VERBrec4 := VERBrec2;
              VERBrec4.modus := infinitive;
              VERBrec5 := VERBrec2;
              VERBrec5.modus := infinitive;
              VERBrec5.status := teAuxV;
         >
      DECOMP
         <
          C1:  
               VERBrec3.modus = infinitive                    AND
               VERBrec4.modus = infinitive                    AND
               VERBrec5 = VERBrec4 EXCEPT FOR [status]
          A1: CLAUSErec1 := COPYT_sentencetoclause(SENTENCErec1);
              CLAUSErec1.modus := omegamodus;
              CLAUSErec1.infsort := omegainf;
              VERBrec1 := VERBrec3;
              VERBrec1.modus := omegamodus;
              VERBrec1.status := AuxV;
              VERBrec2 := VERBrec4;
              VERBrec2.modus := omegamodus;
         >



>


&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rmoodinfrel
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 11-JAN-1990 11:18:01  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


%%
