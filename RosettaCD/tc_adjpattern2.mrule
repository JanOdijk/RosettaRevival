DUTCH 34
&
\begin{verbatim}
%
% TRANSFORMATION TADJPATTERN21     (* ik ben aan x1 x2 verplicht 
                                                        schuldig *)
                                   (* ergative adjs: 
                                      meewerkend voorwerp met prepositie
                                      aan mij duidelijk dierbaar, 
                                      aan ons bekend
                                    *)

< m1: ADJPPROP{ADJPPROPrec1}[ mu1,
                                predrel/ADJP{ADJPrec1}
                                       [ argrel/T1,
                                         argrel/T2,
                                         head/I1::ADJ{ADJrec1}[mu2]
                                       ] 
                               ]
>

< m : ADJPPROP{ADJPPROPrec2}
               [ mu1,
                 predrel/ADJP{ADJPrec2}
		        [aanobjrel/VARPREPP{VARPREPPrec1}
				[ head/PREP(KEY_aanioprepkey){PREPrec1},
                                  objrel/T2
				],
		          rel1/T1,
		          head/I1::ADJ{ADJrec1}[mu2]
		        ] 
	       ]
>
   MATCHCONDITIONS
      <
       I1: ADJrec1.adjpatterns * [synAANNP_DONP, 
                                  synAANNP_OPENOMTESENT,
                                  synAANNP_QSENT,
                                  synAANNP_THATSENT] <> []
      >


<

   SUBRULE(*1a*)      (* ik ben aan jou een gulden schuldig *)
      <
        T1: NPVAR{NPVARrec1}
        T2: NPVAR{NPVARrec2} 
      >
      < 
        T1: NPVAR{NPVARrec1}
        T2: NPVAR{NPVARrec2} 
      >

      COMP
         <
          C1: (synAANNP_DONP IN ADJrec1.adjpatterns) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (ADJPrec1.adjpatternefs = []) 
    
          A1: rel1 := objrel;
              VARPREPPrec1 := VARPREPPrecdef;
              VARPREPPrec1.specQ := NPVARrec2.specQ;
              VARPREPPrec1.headkey := KEY_aanioprepkey;
              VARPREPPrec1.synppefs := [synNP];
              VARPREPPrec1.thetapp := pp120;
              VARPREPPrec1.actsubcefs := PREPrec1.subcs;
              ADJPrec2 := ADJPrec1;
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPrec2.adjpatternefs := [ synAANNP_DONP];
              ADJPPROPrec2.adjpatternefs := [ synAANNP_DONP];
         >
      DECOMP
         <
          C1: (synAANNP_DONP IN ADJrec1.adjpatterns) AND
              (synAANNP_DONP IN ADJPrec2.adjpatternefs) AND
              (synAANNP_DONP IN ADJPPROPrec2.adjpatternefs) AND
              (PREPrec1.key = KEY_aanioprepkey) AND
              (rel1 = objrel) AND
              (VARPREPPrec1 = VARPREPPrecdef 
                EXCEPT FOR [synppefs, headkey, thetapp, actsubcefs, specQ]) AND
              (VARPREPPrec1.specQ = NPVARrec2.specQ) AND
              (VARPREPPrec1.actsubcefs = PREPrec1.subcs) AND
              (VARPREPPrec1.thetapp = pp120) AND
              (VARPREPPrec1.headkey = KEY_aanioprepkey) AND
              (synNP IN VARPREPPrec1.synppefs)
          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

   SUBRULE(*1b, variant van 1a *) 
      <
        T1: CNVAR{CNVARrec1}
        T2: NPVAR{NPVARrec2} 
      >
      < 
        T1: CNVAR{CNVARrec1}
        T2: NPVAR{NPVARrec2} 
      >

      COMP
         <
          C1: (synAANNP_DONP IN ADJrec1.adjpatterns) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (ADJPrec1.adjpatternefs = []) 
    
          A1: rel1 := objrel;
              VARPREPPrec1 := VARPREPPrecdef;
              VARPREPPrec1.specQ := NPVARrec2.specQ;
              VARPREPPrec1.headkey := KEY_aanioprepkey;
              VARPREPPrec1.synppefs := [synNP];
              VARPREPPrec1.thetapp := pp120;
              VARPREPPrec1.actsubcefs := PREPrec1.subcs;
              ADJPrec2 := ADJPrec1;
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPrec2.adjpatternefs := [ synAANNP_DONP];
              ADJPPROPrec2.adjpatternefs := [ synAANNP_DONP];
         >
      DECOMP
         <
          C1: (synAANNP_DONP IN ADJrec1.adjpatterns) AND
              (synAANNP_DONP IN ADJPrec2.adjpatternefs) AND
              (synAANNP_DONP IN ADJPPROPrec2.adjpatternefs) AND
              (PREPrec1.key = KEY_aanioprepkey) AND
              (rel1 = objrel) AND
              (VARPREPPrec1 = VARPREPPrecdef 
                EXCEPT FOR [synppefs, headkey, thetapp, actsubcefs, specQ]) AND
              (VARPREPPrec1.specQ = NPVARrec2.specQ) AND
              (VARPREPPrec1.actsubcefs = PREPrec1.subcs) AND
              (VARPREPPrec1.thetapp = pp120) AND
              (VARPREPPrec1.headkey = KEY_aanioprepkey) AND
              (synNP IN VARPREPPrec1.synppefs)
          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

   SUBRULE(*1c, variant van 1a *)
      <
        T1: NPVAR{NPVARrec1}
        T2: CNVAR{CNVARrec2} 
      >
      < 
        T1: NPVAR{NPVARrec1}
        T2: CNVAR{CNVARrec2} 
      >

      COMP
         <
          C1: (synAANNP_DONP IN ADJrec1.adjpatterns) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (ADJPrec1.adjpatternefs = []) 
    
          A1: rel1 := objrel;
              VARPREPPrec1 := VARPREPPrecdef;
              VARPREPPrec1.specQ := yesspec;
              VARPREPPrec1.headkey := KEY_aanioprepkey;
              VARPREPPrec1.synppefs := [synNP];
              VARPREPPrec1.thetapp := pp120;
              VARPREPPrec1.actsubcefs := PREPrec1.subcs;
              ADJPrec2 := ADJPrec1;
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPrec2.adjpatternefs := [ synAANNP_DONP];
              ADJPPROPrec2.adjpatternefs := [ synAANNP_DONP];
         >
      DECOMP
         <
          C1: (synAANNP_DONP IN ADJrec1.adjpatterns) AND
              (synAANNP_DONP IN ADJPrec2.adjpatternefs) AND
              (synAANNP_DONP IN ADJPPROPrec2.adjpatternefs) AND
              (PREPrec1.key = KEY_aanioprepkey) AND
              (rel1 = objrel) AND
              (VARPREPPrec1 = VARPREPPrecdef 
                EXCEPT FOR [synppefs, headkey, thetapp, actsubcefs, specQ]) AND
              (VARPREPPrec1.specQ = yesspec) AND
              (VARPREPPrec1.actsubcefs = PREPrec1.subcs) AND
              (VARPREPPrec1.thetapp = pp120) AND
              (VARPREPPrec1.headkey = KEY_aanioprepkey) AND
              (synNP IN VARPREPPrec1.synppefs)
          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

   SUBRULE(* 1d, variant van 1a *)
      <
        T1: CNVAR{CNVARrec1}
        T2: CNVAR{CNVARrec2} 
      >
      < 
        T1: CNVAR{CNVARrec1}
        T2: CNVAR{CNVARrec2} 
      >

      COMP
         <
          C1: (synAANNP_DONP IN ADJrec1.adjpatterns) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (ADJPrec1.adjpatternefs = []) 
    
          A1: rel1 := objrel;
              VARPREPPrec1 := VARPREPPrecdef;
              VARPREPPrec1.specQ := yesspec;
              VARPREPPrec1.headkey := KEY_aanioprepkey;
              VARPREPPrec1.synppefs := [synNP];
              VARPREPPrec1.thetapp := pp120;
              VARPREPPrec1.actsubcefs := PREPrec1.subcs;
              ADJPrec2 := ADJPrec1;
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPrec2.adjpatternefs := [ synAANNP_DONP];
              ADJPPROPrec2.adjpatternefs := [ synAANNP_DONP];
         >
      DECOMP
         <
          C1: (synAANNP_DONP IN ADJrec1.adjpatterns) AND
              (synAANNP_DONP IN ADJPrec2.adjpatternefs) AND
              (synAANNP_DONP IN ADJPPROPrec2.adjpatternefs) AND
              (PREPrec1.key = KEY_aanioprepkey) AND
              (rel1 = objrel) AND
              (VARPREPPrec1 = VARPREPPrecdef 
                EXCEPT FOR [synppefs, headkey, thetapp, actsubcefs, specQ]) AND
              (VARPREPPrec1.specQ = yesspec) AND
              (VARPREPPrec1.actsubcefs = PREPrec1.subcs) AND
              (VARPREPPrec1.thetapp = pp120) AND
              (VARPREPPrec1.headkey = KEY_aanioprepkey) AND
              (synNP IN VARPREPPrec1.synppefs)
          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >


   SUBRULE(*2 ik ben aan x1 verplicht (om) te x2 *)
      <
        T1: SENTENCEVAR{SENTENCEVARrec1}
        T2: NPVAR{NPVARrec2} 
      >
      < 
        T1: SENTENCEVAR{SENTENCEVARrec1}
        T2: NPVAR{NPVARrec2} 
      >

      COMP
         <
          C1: (synAANNP_OPENOMTESENT IN ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          PROsubject  : true
			 }
              ) AND
              (SENTENCEVARrec1.infsort IN  [teinf,omteinf])

          A1: rel1 := complrel;
              VARPREPPrec1 := VARPREPPrecdef;
              VARPREPPrec1.specQ := NPVARrec2.specQ;
              VARPREPPrec1.headkey := KEY_aanioprepkey;
              VARPREPPrec1.synppefs := [synNP];
              VARPREPPrec1.thetapp := pp120;
              VARPREPPrec1.actsubcefs := PREPrec1.subcs;
              ADJPrec2 := ADJPrec1;
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPrec2.adjpatternefs := [synAANNP_OPENOMTESENT];
              ADJPPROPrec2.adjpatternefs := [synAANNP_OPENOMTESENT];
         >
      DECOMP
         <
          C1: (synAANNP_OPENOMTESENT IN ADJrec1.adjpatterns) AND
              (synAANNP_OPENOMTESENT IN ADJPrec2.adjpatternefs) AND
              (synAANNP_OPENOMTESENT IN ADJPPROPrec2.adjpatternefs) AND
              (SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          PROsubject  : true
			 }
              ) AND
              (SENTENCEVARrec1.infsort IN [teinf,omteinf]) AND
                 (rel1 = complrel) AND
              (VARPREPPrec1 = VARPREPPrecdef 
                EXCEPT FOR [synppefs, headkey, thetapp, actsubcefs, specQ]) AND
              (VARPREPPrec1.specQ = NPVARrec2.specQ) AND
              (VARPREPPrec1.actsubcefs = PREPrec1.subcs) AND
              (VARPREPPrec1.thetapp = pp120) AND
              (VARPREPPrec1.headkey = KEY_aanioprepkey) AND
              (synNP IN VARPREPPrec1.synppefs) 


          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

   SUBRULE(*2b,  variant van 2a *)
      <
        T1: SENTENCEVAR{SENTENCEVARrec1}
        T2: CNVAR{CNVARrec2} 
      >
      < 
        T1: SENTENCEVAR{SENTENCEVARrec1}
        T2: CNVAR{CNVARrec2} 
      >

      COMP
         <
          C1: (synAANNP_OPENOMTESENT IN ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          PROsubject  : true
			 }
              ) AND
              (SENTENCEVARrec1.infsort IN  [teinf,omteinf])

          A1: rel1 := complrel;
              VARPREPPrec1 := VARPREPPrecdef;
              VARPREPPrec1.specQ := yesspec;
              VARPREPPrec1.headkey := KEY_aanioprepkey;
              VARPREPPrec1.synppefs := [synNP];
              VARPREPPrec1.thetapp := pp120;
              VARPREPPrec1.actsubcefs := PREPrec1.subcs;
              ADJPrec2 := ADJPrec1;
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPrec2.adjpatternefs := [synAANNP_OPENOMTESENT];
              ADJPPROPrec2.adjpatternefs := [synAANNP_OPENOMTESENT];
         >
      DECOMP
         <
          C1: (synAANNP_OPENOMTESENT IN ADJrec1.adjpatterns) AND
              (synAANNP_OPENOMTESENT IN ADJPrec2.adjpatternefs) AND
              (synAANNP_OPENOMTESENT IN ADJPPROPrec2.adjpatternefs) AND
              (SENTENCEVARrec1 =
			 {mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          PROsubject  : true
			 }
              ) AND
              (SENTENCEVARrec1.infsort IN [teinf,omteinf]) AND
              (PREPrec1.key = KEY_aanioprepkey) AND
              (rel1 = complrel) AND
              (VARPREPPrec1 = VARPREPPrecdef 
                EXCEPT FOR [synppefs, headkey, thetapp, actsubcefs, specQ]) AND
              (VARPREPPrec1.specQ = yesspec) AND
              (VARPREPPrec1.actsubcefs = PREPrec1.subcs) AND
              (VARPREPPrec1.thetapp = pp120) AND
              (VARPREPPrec1.headkey = KEY_aanioprepkey) AND
              (synNP IN VARPREPPrec1.synppefs) 

          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

   SUBRULE (* 5 *)
      <T1: NPVAR{NPVARrec1}
       T2: SENTENCEVAR{SENTENCEVARrec1}
      >
      <T1: NPVAR{NPVARrec1}
       T2: SENTENCEVAR{SENTENCEVARrec1}
      >

      COMP
         <
          C1: (ADJrec1.adjpatterns * [synAANNP_THATSENT,
                                        synAANNP_QSENT] <> []) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 = { senttype  : subordinateclause
                                   finiteness: finite})

              C11: SENTENCEVARrec1.mood = declarative
              A11: ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPPROPrec2.adjpatternefs := [synAANNP_THATSENT];
                   ADJPrec2 := ADJPrec1;
                   ADJPrec2.adjpatternefs := [synAANNP_THATSENT];
              C12: (SENTENCEVARrec1.mood IN [whinterrogative, yesnointerrogative])
              A12: ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPPROPrec2.adjpatternefs := [synAANNP_QSENT];
                   ADJPrec2 := ADJPrec1;
                   ADJPrec2.adjpatternefs := [synAANNP_QSENT];

          A1: rel1 := complrel;
              VARPREPPrec1 := VARPREPPrecdef;
              VARPREPPrec1.specQ := NPVARrec1.specQ;
              VARPREPPrec1.headkey := KEY_aanioprepkey;
              VARPREPPrec1.synppefs := [synNP];
              VARPREPPrec1.thetapp := pp120;
              VARPREPPrec1.actsubcefs := PREPrec1.subcs;
              
              
         >
      DECOMP
         <
          C1: (rel1 = complrel) AND
              (ADJPrec2.adjpatternefs * [synAANNP_THATSENT,
                                             synAANNP_QSENT] 
               <> []) AND
              (ADJPPROPrec2.adjpatternefs * [synAANNP_THATSENT,
                                             synAANNP_QSENT] 
               <> []) AND
              (SENTENCEVARrec1 = { senttype  : subordinateclause
                                   finiteness: finite}) AND
              (PREPrec1.key = KEY_aanioprepkey) AND
              (VARPREPPrec1 = VARPREPPrecdef 
                EXCEPT FOR [synppefs, headkey, thetapp, actsubcefs, specQ]) AND
              (VARPREPPrec1.specQ = NPVARrec1.specQ) AND
              (VARPREPPrec1.actsubcefs = PREPrec1.subcs) AND
              (VARPREPPrec1.thetapp = pp120) AND
              (VARPREPPrec1.headkey = PREPrec1.key) AND
              (synNP IN VARPREPPrec1.synppefs)

              C11: (synAANNP_THATSENT IN ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood = declarative)
              A11: @

              C12: (synAANNP_QSENT IN ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood IN [whinterrogative, yesnointerrogative])
              A12: @


          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];

      >

   SUBRULE (* 6 *)
      <T1: CNVAR{CNVARrec1}
       T2: SENTENCEVAR{SENTENCEVARrec1}
      >
      <T1: CNVAR{CNVARrec1}
       T2: SENTENCEVAR{SENTENCEVARrec1}
      >

      COMP
         <
          C1: (ADJrec1.adjpatterns * [synAANNP_THATSENT,
                                        synAANNP_QSENT] <> []) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 = { senttype  : subordinateclause
                                   finiteness: finite})

              C11: SENTENCEVARrec1.mood = declarative
              A11: ADJPrec2 := ADJPrec1;
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPPROPrec2.adjpatternefs := [synAANNP_THATSENT];
                   ADJPPROPrec2.adjpatternefs := [synAANNP_THATSENT];
              C12: (SENTENCEVARrec1.mood IN [whinterrogative, yesnointerrogative])
              A12: ADJPrec2 := ADJPrec1;
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPPROPrec2.adjpatternefs := [synAANNP_QSENT];
                   ADJPPROPrec2.adjpatternefs := [synAANNP_QSENT];

          A1: rel1 := complrel;
              VARPREPPrec1 := VARPREPPrecdef;
              VARPREPPrec1.specQ := yesspec;
              VARPREPPrec1.headkey := KEY_aanioprepkey;
              VARPREPPrec1.synppefs := [synNP];
              VARPREPPrec1.thetapp := pp120;
              VARPREPPrec1.actsubcefs := PREPrec1.subcs;
              
              
         >
      DECOMP
         <
          C1: (rel1 = complrel) AND
              (ADJPrec2.adjpatternefs * [synAANNP_THATSENT,
                                             synAANNP_QSENT] 
               <> []) AND
              (ADJPPROPrec2.adjpatternefs * [synAANNP_THATSENT,
                                             synAANNP_QSENT] 
               <> []) AND
              (SENTENCEVARrec1 = { senttype  : subordinateclause
                                   finiteness: finite}) AND
              (PREPrec1.key = KEY_aanioprepkey) AND
              (VARPREPPrec1 = VARPREPPrecdef 
                EXCEPT FOR [synppefs, headkey, thetapp, actsubcefs, specQ]) AND
              (VARPREPPrec1.specQ = yesspec) AND
              (VARPREPPrec1.actsubcefs = PREPrec1.subcs) AND
              (VARPREPPrec1.thetapp = pp120) AND
              (VARPREPPrec1.headkey = PREPrec1.key) AND
              (synNP IN VARPREPPrec1.synppefs)

              C11: (synAANNP_THATSENT IN ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood = declarative)
              A11: @

              C12: (synAANNP_QSENT IN ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood IN [whinterrogative, yesnointerrogative])
              A12: @


          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

>                              
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] TADJPATTERN21
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] AdjpPropFormation
\item[* class:] TC:ADJPATTERNRULES
\item[* date of creation:] 6-AUG-1987 11:27:30  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}

% TRANSFORMATION TADJPATTERN22     (* ik ben x1 x2 verplicht /schuldig,
                                      pim is mij die inspanning waard *)
                                   (* ergative adjs: 
                                      indobj zonder prepositie:
                                      mij duidelijk, ons bekend
                                      empty indirect object: 
                                      bekend, duidelijk
                                    *)
                                                          
< m1: ADJPPROP{ADJPPROPrec1}[ mu1,
                              predrel/ADJP{ADJPrec1}
                                       [ argrel/T1,
                                         argrel/T2,
                                         head/I1::ADJ{ADJrec1}[mu2]
                                       ] 
                               ]
>

< m : ADJPPROP{ADJPPROPrec2}
               [ mu1,
                 predrel/ADJP{ADJPrec2}
		        [ indobjrel/T2,
                          rel1/T1,		          
                          head/I1::ADJ{ADJrec1}[mu2]
		        ] 
	       ]
>

   MATCHCONDITIONS
      <
       I1: ADJrec1.adjpatterns * [synIONP_DONP,
                                  synIONP_OPENOMTESENT,
                                  synIONP_QSENT,
                                  synIONP_THATSENT,
                                  synIOEMPTY_DONP,
                                  synIOEMPTY_OPENOMTESENT,
                                  synIOEMPTY_QSENT,
                                  synIOEMPTY_THATSENT] <> []
      >

<
   SUBRULE(*1a*)      (* ik ben jou een gulden schuldig *)
      <
        T1: NPVAR{NPVARrec1}
        T2: NPVAR{NPVARrec2} 
      >
      < 
        T1: NPVAR{NPVARrec1}
        T2: NPVAR{NPVARrec4} 
      >

      COMP
         <
          C1: (synIONP_DONP IN ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              NPVARrec2.cases = [Nominative]
          A1: rel1 := objrel;
              NPVARrec4 := NPVARrec2;
              NPVARrec4.cases := [Dative];
              ADJPrec2 := ADJPrec1;
              ADJPrec1.adjpatternefs := [ synIONP_DONP];
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPPROPrec1.adjpatternefs := [ synIONP_DONP];
         >
      DECOMP
         <
          C1: (synIONP_DONP IN ADJrec1.adjpatterns) AND
              (synIONP_DONP IN ADJPrec2.adjpatternefs) AND
              (synIONP_DONP IN ADJPPROPrec2.adjpatternefs) AND
              (rel1 = objrel) AND
              Dative IN NPVARrec4.cases
          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
              NPVARrec2 := NPVARrec4;
              NPVARrec2.cases := [Nominative];

         >
   SUBRULE(*1b, variant van 1a *) 
      < T1: CNVAR{CNVARrec1} 
        T2: NPVAR{NPVARrec2} 
      >
      < T1: CNVAR{CNVARrec1}
        T2: NPVAR{NPVARrec4}
      >

      COMP
         <
          C1: (synIONP_DONP IN ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              NPVARrec2.cases = [Nominative]
          A1: rel1 := objrel;
              ADJPrec2 := ADJPrec1;
              ADJPrec1.adjpatternefs := [ synIONP_DONP];
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPPROPrec1.adjpatternefs := [ synIONP_DONP];
              NPVARrec4 := NPVARrec2;
              NPVARrec4.cases := [Dative];

         >
      DECOMP
         <
          C1: (synIONP_DONP IN ADJrec1.adjpatterns) AND
              (synIONP_DONP IN ADJPrec2.adjpatternefs) AND
              (synIONP_DONP IN ADJPPROPrec2.adjpatternefs) AND
              (rel1 = objrel) AND
              Dative IN NPVARrec4.cases
          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
              NPVARrec2 := NPVARrec4;
              NPVARrec2.cases := [Nominative];
         >

   SUBRULE(*1c, variant van 1a *)
      < T1: NPVAR{NPVARrec1} 
        T2: CNVAR{CNVARrec2} 
      >
      < T1: NPVAR{NPVARrec1}
        T2: CNVAR{CNVARrec4}
      >

      COMP
         <
          C1: (synIONP_DONP IN ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              CNVARrec2.cases = [Nominative]
          A1: rel1 := objrel;
              ADJPrec2 := ADJPrec1;
              ADJPrec1.adjpatternefs := [ synIONP_DONP];
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPPROPrec1.adjpatternefs := [ synIONP_DONP];
              CNVARrec4 := CNVARrec2;
              CNVARrec4.cases := [Dative];

         >
      DECOMP
         <
          C1: (synIONP_DONP IN ADJrec1.adjpatterns) AND
              (synIONP_DONP IN ADJPrec2.adjpatternefs) AND
              (synIONP_DONP IN ADJPPROPrec2.adjpatternefs) AND
              (rel1 = objrel) AND
              Dative IN CNVARrec4.cases

          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
              CNVARrec2 := CNVARrec4;
              CNVARrec2.cases := [Nominative];
         >

   SUBRULE(* 1d, variant van 1a *)
      < T1: CNVAR{CNVARrec1} 
        T2: CNVAR{CNVARrec2} 
      >
      < T1: CNVAR{CNVARrec1}
        T2: CNVAR{CNVARrec4}
      >
      COMP
         <
          C1: (synIONP_DONP IN ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              CNVARrec2.cases = [Nominative]
          A1: rel1 := objrel;
              ADJPrec2 := ADJPrec1;
              ADJPrec1.adjpatternefs := [ synIONP_DONP];
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPPROPrec1.adjpatternefs := [ synIONP_DONP];
              CNVARrec4 := CNVARrec2;
              CNVARrec4.cases := [Dative];

         >
      DECOMP
         <
          C1: (synIONP_DONP IN ADJrec1.adjpatterns) AND
              (synIONP_DONP IN ADJPrec2.adjpatternefs) AND
              (synIONP_DONP IN ADJPPROPrec2.adjpatternefs) AND
                    (rel1 = objrel) AND
              Dative IN CNVARrec4.cases

          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
              CNVARrec2 := CNVARrec4;
              CNVARrec2.cases := [Nominative];
         >

   SUBRULE(*2a*)      (* dat is zo'n inspanning wel waard *)
      <
        T1: EMPTYVAR{EMPTYVARrec1}
        T2: NPVAR{NPVARrec2} 
      >
      < 
        T1: EMPTYVAR{EMPTYVARrec1}
        T2: NPVAR{NPVARrec2} 
      >

      COMP
         <
          C1: (synIOEMPTY_DONP IN ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = [])
          A1: rel1 := objrel;
              ADJPrec2 := ADJPrec1;
              ADJPrec1.adjpatternefs := [ synIOEMPTY_DONP];
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPPROPrec1.adjpatternefs := [ synIOEMPTY_DONP];
         >
      DECOMP
         <
          C1: (synIOEMPTY_DONP IN ADJrec1.adjpatterns) AND
              (synIOEMPTY_DONP IN ADJPrec2.adjpatternefs) AND
              (synIOEMPTY_DONP IN ADJPPROPrec2.adjpatternefs) AND
              (rel1 = objrel)
          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

   SUBRULE(*2b*)      (* dat is zo'n inspanning wel waard *)
      <
        T1: EMPTYVAR{EMPTYVARrec1}
        T2: CNVAR{CNVARrec2} 
      >
      < 
        T1: EMPTYVAR{EMPTYVARrec1}
        T2: CNVAR{CNVARrec2} 
      >

      COMP
         <
          C1: (synIOEMPTY_DONP IN ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = [])
          A1: rel1 := objrel;
              ADJPrec2 := ADJPrec1;
              ADJPrec1.adjpatternefs := [ synIOEMPTY_DONP];
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPPROPrec1.adjpatternefs := [ synIOEMPTY_DONP];
         >
      DECOMP
         <
          C1: (synIOEMPTY_DONP IN ADJrec1.adjpatterns) AND
              (synIOEMPTY_DONP IN ADJPrec2.adjpatternefs) AND
              (synIOEMPTY_DONP IN ADJPPROPrec2.adjpatternefs) AND
              (rel1 = objrel)
          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >


   SUBRULE (*3a *) (* ik ben x1 verplicht (om) te ... *)
      <
        T1: SENTENCEVAR{SENTENCEVARrec1}
        T2: NPVAR{NPVARrec2} 
      >
      < 
        T1: SENTENCEVAR{SENTENCEVARrec1}
        T2: NPVAR{NPVARrec3} 
      >

      COMP
         <
          C1: (synIONP_OPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          PROsubject  : true
			 }
              ) AND
              (SENTENCEVARrec1.infsort IN [teinf, omteinf]) AND
              NPVARrec2.cases = [Nominative]

          A1: rel1 := complrel;
              ADJPrec2 := ADJPrec1;
              ADJPrec2.adjpatternefs := [synIONP_OPENOMTESENT];
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPPROPrec2.adjpatternefs := [synIONP_OPENOMTESENT];
              NPVARrec2 := NPVARrec3;
              NPVARrec3.cases := [Nominative];

         >
      DECOMP
         <
          C1: (synIONP_OPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (synIONP_OPENOMTESENT IN ADJPrec2.adjpatternefs) AND
              (synIONP_OPENOMTESENT IN ADJPPROPrec2.adjpatternefs) AND
              (SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          PROsubject  : true
			 }
              ) AND
              (SENTENCEVARrec1.infsort IN [teinf, omteinf]) AND
              (rel1 = complrel) AND
              Dative IN NPVARrec3.cases

 
          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
              NPVARrec2 := NPVARrec3;
              NPVARrec2.cases := [Nominative];
         >

   SUBRULE(*3b,  variant van 3a *)
      <
        T1: SENTENCEVAR{SENTENCEVARrec1}
        T2: CNVAR{CNVARrec2} 
      >
      < 
        T1: SENTENCEVAR{SENTENCEVARrec1}
        T2: CNVAR{CNVARrec3} 
      >
       COMP
         <
          C1: (synIONP_OPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          PROsubject  : true
			 }
              ) AND
              (SENTENCEVARrec1.infsort IN [teinf, omteinf]) AND
              CNVARrec2.cases = [Nominative]

          A1: rel1 := complrel;
              ADJPrec2 := ADJPrec1;
              ADJPrec2.adjpatternefs := [synIONP_OPENOMTESENT];
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPPROPrec2.adjpatternefs := [synIONP_OPENOMTESENT];
              CNVARrec3 := CNVARrec2;
              CNVARrec2.cases := [Nominative]
         >
      DECOMP
         <
          C1: (synIONP_OPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (synIONP_OPENOMTESENT IN ADJPrec2.adjpatternefs) AND
              (synIONP_OPENOMTESENT IN ADJPPROPrec2.adjpatternefs) AND
              (SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          PROsubject  : true
			 }
              ) AND
              (SENTENCEVARrec1.infsort IN [teinf, omteinf]) AND
              (rel1 = complrel) AND
              Dative IN CNVARrec3.cases


          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
              CNVARrec2 := CNVARrec3;
              CNVARrec2.cases := [Nominative];
         >
   


   SUBRULE (* 4 *)
      <T1: NPVAR{NPVARrec1}
       T2: SENTENCEVAR{SENTENCEVARrec1}
      >
      <T1: NPVAR{NPVARrec2}
       T2: SENTENCEVAR{SENTENCEVARrec1}
      >

      COMP
         <
          C1: (ADJrec1.adjpatterns * [synIONP_THATSENT,
                                        synIONP_QSENT] <> []) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 = { senttype  : subordinateclause
                                   finiteness: finite}) AND
              NPVARrec1.cases = [Nominative]

              C11: SENTENCEVARrec1.mood = declarative
              A11: ADJPrec2 := ADJPrec1;
                   ADJPrec2.adjpatternefs := [synIONP_THATSENT];
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPPROPrec2.adjpatternefs := [synIONP_THATSENT];
              C12: (SENTENCEVARrec1.mood IN [whinterrogative, yesnointerrogative])
              A12: ADJPrec2 := ADJPrec1;
                   ADJPrec2.adjpatternefs := [synIONP_QSENT];
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPPROPrec2.adjpatternefs := [synIONP_QSENT];

          A1: rel1 := complrel;
              NPVARrec2 := NPVARrec1;
              NPVARrec2.cases  := [Dative];
         >

      DECOMP
         <
          C1: (rel1 = complrel) AND
              (ADJPPROPrec2.adjpatternefs * [synIONP_THATSENT,
                                                synIONP_QSENT] <> []) AND
              (ADJPrec2.adjpatternefs * [synIONP_THATSENT,
                                                synIONP_QSENT] <> []) AND
              (SENTENCEVARrec1 = { senttype  : subordinateclause
                                   finiteness: finite}) AND
              Dative IN NPVARrec2.cases 

              C11: (synIONP_THATSENT IN ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood = declarative)
              A11: @

              C12: (synIONP_QSENT IN ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood IN [whinterrogative, yesnointerrogative])
              A12: @

          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
              NPVARrec1 := NPVARrec2;
              NPVARrec1.cases  := [Nominative];
         >

   SUBRULE (* 5 *)
      <T1: CNVAR{CNVARrec1}
       T2: SENTENCEVAR{SENTENCEVARrec1}
      >
      <T1: CNVAR{CNVARrec2}
       T2: SENTENCEVAR{SENTENCEVARrec1}
      >

      COMP
         <
          C1: (ADJrec1.adjpatterns * [synIONP_THATSENT,
                                        synIONP_QSENT] <> []) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 = { senttype  : subordinateclause
                                   finiteness: finite}) AND 
              CNVARrec1.cases = [Nominative]

              C11: SENTENCEVARrec1.mood = declarative
              A11: ADJPrec2 := ADJPrec1;
                   ADJPrec2.adjpatternefs := [synIONP_THATSENT];
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPPROPrec2.adjpatternefs := [synIONP_THATSENT];
              C12: (SENTENCEVARrec1.mood IN [whinterrogative, yesnointerrogative])
              A12: ADJPrec2 := ADJPrec1;
                   ADJPrec2.adjpatternefs := [synIONP_QSENT];
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPPROPrec2.adjpatternefs := [synIONP_QSENT];

          A1: rel1 := complrel;
              CNVARrec2 := CNVARrec1;
              CNVARrec2.cases := [Dative];
              
         >
      DECOMP
         <
          C1: (rel1 = complrel) AND
              (ADJPrec2.adjpatternefs * [synIONP_THATSENT,
                                                synIONP_QSENT] <> []) AND
              (ADJPPROPrec2.adjpatternefs * [synIONP_THATSENT,
                                                synIONP_QSENT] <> []) AND
              (SENTENCEVARrec1 = { senttype  : subordinateclause
                                   finiteness: finite}) AND
              Dative IN CNVARrec2.cases

              C11: (synIONP_THATSENT IN ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood = declarative)
              A11: @

              C12: (synIONP_QSENT IN ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood IN [whinterrogative, yesnointerrogative])
              A12: @

          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
              CNVARrec1 := CNVARrec2;
              CNVARrec1.cases := [Nominative]
         >

   SUBRULE (* 6 *)
      <T1: EMPTYVAR{EMPTYVARrec1}
       T2: SENTENCEVAR{SENTENCEVARrec1}
      >
      <T1: EMPTYVAR{EMPTYVARrec1}
       T2: SENTENCEVAR{SENTENCEVARrec1}
      >

      COMP
         <
          C1: (ADJrec1.adjpatterns * [synIOEMPTY_THATSENT,
                                        synIOEMPTY_QSENT] <> []) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 = { senttype  : subordinateclause
                                   finiteness: finite})

              C11: SENTENCEVARrec1.mood = declarative
              A11: ADJPrec2 := ADJPrec1;
                   ADJPrec2.adjpatternefs := [synIOEMPTY_THATSENT];
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPPROPrec2.adjpatternefs := [synIOEMPTY_THATSENT];
              C12: (SENTENCEVARrec1.mood IN [whinterrogative, yesnointerrogative])
              A12: ADJPrec2 := ADJPrec1;
                   ADJPrec2.adjpatternefs := [synIOEMPTY_QSENT];
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPPROPrec2.adjpatternefs := [synIOEMPTY_QSENT];

          A1: rel1 := complrel;
              
         >
      DECOMP
         <
          C1: (rel1 = complrel) AND
              (ADJPrec2.adjpatternefs * [synIOEMPTY_THATSENT,
                                                synIOEMPTY_QSENT] <> []) AND
              (ADJPPROPrec2.adjpatternefs * [synIOEMPTY_THATSENT,
                                                synIOEMPTY_QSENT] <> []) AND
              (SENTENCEVARrec1 = { senttype  : subordinateclause
                                   finiteness: finite})
              C11: (synIOEMPTY_THATSENT IN ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood = declarative)
              A11: @

              C12: (synIOEMPTY_QSENT IN ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood IN [whinterrogative, yesnointerrogative])
              A12: @

          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

>
&
the following subrule can be activated as soon as the 
synpattern is defined in the domain

SUBRULE (*3a *) (* ik ben x1 verplicht (om) te ... *)
      <
        T1: SENTENCEVAR{SENTENCEVARrec1}
        T2: EMPTYVAR{EMPTYVARrec2} 
      >
      < 
        T1: SENTENCEVAR{SENTENCEVARrec1}
        T2: EMPTYVAR{EMPTYVARrec2} 
      >

      COMP
         <
          C1: (synIOEMPTY_OPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          PROsubject  : true
			 }
              ) AND
              (SENTENCEVARrec1.infsort IN [teinf, omteinf])

          A1: rel1 := complrel;
              ADJPrec2 := ADJPrec1;
              ADJPrec2.adjpatternefs := [synIOEMPTY_OPENOMTESENT];
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPPROPrec2.adjpatternefs := [synIOEMPTY_OPENOMTESENT];
         >
      DECOMP
         <
          C1: (synIOEMPTY_OPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (synIOEMPTY_OPENOMTESENT IN ADJPrec2.adjpatternefs) AND
              (synIOEMPTY_OPENOMTESENT IN ADJPPROPrec2.adjpatternefs) AND
              (SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          PROsubject  : true
			 }
              ) AND
              (SENTENCEVARrec1.infsort IN [teinf, omteinf]) AND
              (rel1 = complrel)

          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

\end{verbatim}
\newpage
\begin{description}
\item[* name:] TADJPATTERN22
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] AdjpPropFormation
\item[* class:] TC:ADJPATTERNRULES
\item[* date of creation:] 6-AUG-1987 15:07:05  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}

% TRANSFORMATION TADJPATTERN23    
                  (* ik ben het aan jou verplicht (om) te ... *) 

< m1: ADJPPROP{ADJPPROPrec1}[ mu1,
                                predrel/ADJP{ADJPrec1}
                                       [ argrel/T1,
                                         argrel/SENTENCEVAR{SENTENCEVARrec1},
                                         head/I1::ADJ{ADJrec1}[mu2]
                                       ] 
                               ]
>

< m : ADJPPROP{ADJPPROPrec2}
               [ mu1,
                 predrel/ADJP{ADJPrec2}
		        [ aanobjrel/VARPREPP{VARPREPPrec1}
				[ head/PREP(KEY_aanioprepkey){PREPrec1},
                                  objrel/T1
				],
                          objrel/NP{NPrec1}
                             [head/PERSPRO{PERSPROrec1}
                              [head/BPERSPRO(KEY_hetbpersprokey){BPERSPROrec1}]
                             ],
		          complrel/SENTENCEVAR{SENTENCEVARrec1},
		          head/I1::ADJ{ADJrec1}[mu2]
		        ] 
	       ]
>

   MATCHCONDITIONS
      <
       I1: ADJrec1.adjpatterns * [synAANNP_HETOPENOMTESENT
                                  ] <> []       
      >

<
   SUBRULE (* 1a *)
      <T1: NPVAR{NPVARrec1} >
      <T1: NPVAR{NPVARrec1} >

      COMP
         <
          C1: (synAANNP_HETOPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 =
                         {
                          mood        : declarative
                          senttype    : subordinateclause
                          finiteness  : infinite
                          PROsubject  : true
			 }
              ) AND
              (SENTENCEVARrec1.infsort IN [omteinf, teinf])

          A1: PERSPROrec1 := COPYT_BPERSPROtoPERSPRO(BPERSPROREC1);
              PERSPROrec1.reduced := false;
              NPrec1 := AUX_NPONHetBprspr;
              VARPREPPrec1 := VARPREPPrecdef;
              VARPREPPrec1.specQ := NPVARrec1.specQ;
              VARPREPPrec1.headkey := KEY_aanioprepkey;
              VARPREPPrec1.synppefs := [synNP];
              VARPREPPrec1.thetapp := pp120;
              VARPREPPrec1.actsubcefs := PREPrec1.subcs;
              ADJPrec2 := ADJPrec1;
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPrec2.adjpatternefs := [synAANNP_HETOPENOMTESENT];
              ADJPPROPrec2.adjpatternefs := [synAANNP_HETOPENOMTESENT];
         >
      DECOMP
         <
          C1: (PERSPROrec1 = COPYT_BPERSPROtoPERSPRO(BPERSPROREC1)) 
               AND
              (NPrec1 = AUX_NPONHetBprspr) AND 
              (synAANNP_HETOPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (SENTENCEVARrec1 =
                         {
                          mood        : declarative
                          senttype    : subordinateclause
                          finiteness  : infinite
                          PROsubject  : true
                         }
              ) AND
              (PREPrec1.key = KEY_aanioprepkey) AND
              (VARPREPPrec1 = VARPREPPrecdef 
                EXCEPT FOR [synppefs, headkey, thetapp, actsubcefs, specQ]) AND
              (VARPREPPrec1.specQ = NPVARrec1.specQ) AND
              (VARPREPPrec1.actsubcefs = PREPrec1.subcs) AND
              (VARPREPPrec1.thetapp = pp120) AND
              (VARPREPPrec1.headkey = KEY_aanioprepkey) AND
              (synNP IN VARPREPPrec1.synppefs) AND
              (synAANNP_HETOPENOMTESENT IN ADJPrec2.adjpatternefs) AND
              (synAANNP_HETOPENOMTESENT IN ADJPPROPrec2.adjpatternefs) AND
              (SENTENCEVARrec1.infsort IN [omteinf, teinf])

          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

   SUBRULE (* 1b; variant van 1a *)
      <T1: CNVAR{CNVARrec1} >
      <T1: CNVAR{CNVARrec1} >

      COMP
         <
          C1: (synAANNP_HETOPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 =
                         {
                          mood        : declarative
                          senttype    : subordinateclause
                          finiteness  : infinite
                          PROsubject  : true
			 }
              ) AND
              (SENTENCEVARrec1.infsort IN [omteinf, teinf])

          A1: PERSPROrec1 := COPYT_BPERSPROtoPERSPRO(BPERSPROREC1);
              PERSPROrec1.reduced := false;
              NPrec1 := AUX_NPONHetBprspr;
              VARPREPPrec1 := VARPREPPrecdef;
              VARPREPPrec1.specQ := yesspec;
              VARPREPPrec1.headkey := KEY_aanioprepkey;
              VARPREPPrec1.synppefs := [synNP];
              VARPREPPrec1.thetapp := pp120;
              VARPREPPrec1.actsubcefs := PREPrec1.subcs;
              ADJPrec2 := ADJPrec1;
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPrec2.adjpatternefs := [synAANNP_HETOPENOMTESENT];
              ADJPPROPrec2.adjpatternefs := [synAANNP_HETOPENOMTESENT]
         >
      DECOMP
         <
          C1: (PERSPROrec1 = COPYT_BPERSPROtoPERSPRO(BPERSPROREC1)) 
               AND
              (NPrec1 = AUX_NPONHetBprspr) AND 
              (synAANNP_HETOPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (SENTENCEVARrec1 =
                         {
                          mood        : declarative
                          senttype    : subordinateclause
                          finiteness  : infinite
                          PROsubject  : true
                         }
              ) AND
              (PREPrec1.key = KEY_aanioprepkey) AND
              (VARPREPPrec1 = VARPREPPrecdef 
                EXCEPT FOR [synppefs, headkey, thetapp, actsubcefs, specQ]) AND
              (VARPREPPrec1.actsubcefs = PREPrec1.subcs) AND
              (VARPREPPrec1.thetapp = pp120) AND
              (VARPREPPrec1.headkey = KEY_aanioprepkey) AND
              (VARPREPPrec1.specQ = yesspec) AND
              (synNP IN VARPREPPrec1.synppefs) AND
              (synAANNP_HETOPENOMTESENT IN ADJPrec2.adjpatternefs) AND
              (synAANNP_HETOPENOMTESENT IN ADJPPROPrec2.adjpatternefs) AND
              (SENTENCEVARrec1.infsort IN [omteinf, teinf])

          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] TADJPATTERN23
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] AdjpPropFormation
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 6-AUG-1987 15:20:03  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% TRANSFORMATION TADJPATTERN24    
                      (* jij bent het (ons) verplicht (om) te ... *) 

< m1: ADJPPROP{ADJPPROPrec1}[ mu1,
                                predrel/ADJP{ADJPrec1}
                                       [ argrel/T1,
                                         argrel/SENTENCEVAR{SENTENCEVARrec1},
                                         head/I1::ADJ{ADJrec1}[mu2]
                                       ] 
                               ]
>

< m : ADJPPROP{ADJPPROPrec2}
               [ mu1,
                 predrel/ADJP{ADJPrec2}
		        [ indobjrel/T1,
                          objrel/NP{NPrec1}
                             [head/PERSPRO{PERSPROrec1}
                                   [head/BPERSPRO(KEY_hetbpersprokey){BPERSPROrec1}]
                             ],
		          complrel/SENTENCEVAR{SENTENCEVARrec1},
		          head/I1::ADJ{ADJrec1}[mu2]
		        ] 
	       ]
>

   MATCHCONDITIONS
      <
       I1: ADJrec1.adjpatterns * [synIONP_HETOPENOMTESENT
                                  (* , synIOEMPTY_HETOPENOMTESENT *)
                                 ] <> []
      >


<
   SUBRULE (* 1 *)
      <T1: NPVAR{NPVARrec1} >
      <T1: NPVAR{NPVARrec2} >

      COMP
         <
          C1: (synIONP_HETOPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 =
                         {
                          mood        : declarative
                          senttype    : subordinateclause
                          finiteness  : infinite
                          PROsubject  : true
                         }
              ) AND
              (SENTENCEVARrec1.infsort IN [teinf, omteinf]) AND
              NPVARrec1.cases = [Nominative]



          A1: PERSPROrec1 := COPYT_BPERSPROtoPERSPRO(BPERSPROREC1);
              PERSPROrec1.reduced := false;
              NPrec1 := AUX_NPONHetBprspr; 
              ADJPrec2 := ADJPrec1;
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPrec2.adjpatternefs := [synIONP_HETOPENOMTESENT];
              ADJPPROPrec2.adjpatternefs := [synIONP_HETOPENOMTESENT];
              NPVARrec2 := NPVARrec1;
              NPVARrec2.cases  := [Dative];
         >
      DECOMP
         <
          C1: (PERSPROrec1 = COPYT_BPERSPROtoPERSPRO(BPERSPROREC1)) 
               AND
              (NPrec1 = AUX_NPONHetBprspr ) AND 
              (synIONP_HETOPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (synIONP_HETOPENOMTESENT IN ADJPrec2.adjpatternefs) AND
              (synIONP_HETOPENOMTESENT IN ADJPPROPrec2.adjpatternefs) 
               AND
              (SENTENCEVARrec1 =
                         {
                          mood        : declarative
                          senttype    : subordinateclause
                          finiteness  : infinite
                          PROsubject  : true
                         }
              ) AND
              (SENTENCEVARrec1.infsort IN [omteinf,teinf]) AND
              Dative IN NPVARrec1.cases


          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
              NPVARrec1 := NPVARrec2;
              NPVARrec1.cases := [Nominative];
         >

   SUBRULE (* 2 *)
      <T1: CNVAR{CNVARrec1} >
      <T1: CNVAR{CNVARrec2} >

      COMP
         <
          C1: (synIONP_HETOPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 =
                         {
                          mood        : declarative
                          senttype    : subordinateclause
                          finiteness  : infinite
                          PROsubject  : true
                         }
              ) AND
              (SENTENCEVARrec1.infsort IN [teinf, omteinf]) AND
              CNVARrec1.cases = [Nominative]


          A1: PERSPROrec1 := COPYT_BPERSPROtoPERSPRO(BPERSPROREC1);
              PERSPROrec1.reduced := false;
              NPrec1 := AUX_NPONHetBprspr; 
              ADJPrec2 := ADJPrec1;
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPrec2.adjpatternefs := [synIONP_HETOPENOMTESENT];
              ADJPPROPrec2.adjpatternefs := [synIONP_HETOPENOMTESENT];
              CNVARrec2 := CNVARrec1;
              CNVARrec2.cases  := [Dative];
         >
      DECOMP
         <
          C1: (PERSPROrec1 = COPYT_BPERSPROtoPERSPRO(BPERSPROREC1)) 
               AND
              (NPrec1 = AUX_NPONHetBprspr ) AND 
              (synIONP_HETOPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (synIONP_HETOPENOMTESENT IN ADJPrec2.adjpatternefs) AND
              (synIONP_HETOPENOMTESENT IN ADJPPROPrec2.adjpatternefs) 
               AND
              (SENTENCEVARrec1 =
                         {
                          mood        : declarative
                          senttype    : subordinateclause
                          finiteness  : infinite
                          PROsubject  : true
                         }
              ) AND
              (SENTENCEVARrec1.infsort IN [omteinf,teinf])  AND
              Dative IN CNVARrec2.cases

          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
              CNVARrec1 := CNVARrec2;
              CNVARrec1.cases  := [Nominative];
         >
>
&

the following subrule can be activated as soon as the synpattern 
is defined  in the domain ; NB: matchcondition.

   SUBRULE (* 3 *)
      <T1: EMPTYVAR{EMPTYVARrec1} >
      <T1: EMPTYVAR{EMPTYVARrec1} >

      COMP
         <
          C1: (synIOEMPTY_HETOPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 =
                         {
                          mood        : declarative
                          senttype    : subordinateclause
                          finiteness  : infinite
                          PROsubject  : true
                         }
              ) AND
              (SENTENCEVARrec1.infsort IN [teinf, omteinf])


          A1: PERSPROrec1 := COPYT_BPERSPROtoPERSPRO(BPERSPROREC1);
              PERSPROrec1.reduced := false;
              NPrec1 := AUX_NPONHetBprspr; 
              ADJPrec2 := ADJPrec1;
              ADJPPROPrec2 := ADJPPROPrec1;
              ADJPrec2.adjpatternefs := [synIOEMPTY_HETOPENOMTESENT];
              ADJPPROPrec2.adjpatternefs := [synIOEMPTY_HETOPENOMTESENT];
         >
      DECOMP
         <
          C1: (PERSPROrec1 = COPYT_BPERSPROtoPERSPRO(BPERSPROREC1)) 
               AND
              (NPrec1 = AUX_NPONHetBprspr ) AND 
              (synIOEMPTY_HETOPENOMTESENT IN  ADJrec1.adjpatterns) AND
              (synIOEMPTY_HETOPENOMTESENT IN ADJPrec2.adjpatternefs) AND
              (synIOEMPTY_HETOPENOMTESENT IN ADJPPROPrec2.adjpatternefs) 
               AND
              (SENTENCEVARrec1 =
                         {
                          mood        : declarative
                          senttype    : subordinateclause
                          finiteness  : infinite
                          PROsubject  : true
                         }
              ) AND
              (SENTENCEVARrec1.infsort IN [omteinf,teinf]) 

          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

\end{verbatim}
\newpage
\begin{description}
\item[* name:] TADJPATTERN24
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] AdjpPropFormation
\item[* class:] TC:ADJPATTERRULES
\item[* date of creation:] 6-AUG-1987 16:06:34  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% TRANSFORMATION TADJPATTERN25       (* het is aan x1 bekend/duidelijk
                                        dat/of  .... *)

< m1: ADJPPROP{ADJPPROPrec1}[ predrel/ADJP{ADJPrec1}
                                       [ argrel/T1,
                                         I1:argrel/T2,
                                         head/I3::ADJ{ADJrec1}[mu2]
                                       ] 
                               ]
>

< m : ADJPPROP{ADJPPROPrec2}
               [ predrel/ADJP{ADJPrec2}
                        [aanobjrel/VARPREPP{VARPREPPrec1}
                                [head/PREP(KEY_aanioprepkey){PREPrec1},
                                 I1:objrel/T2
				],
		         objrel/I2::NP{NPrec1}
                                       [head/PERSPRO{PERSPROrec1}
                                             [head/BPERSPRO(KEY_HETBPERSPROkey)
                                                                 {BPERSPROrec1}]
                                       ],
                         complrel/SENTENCEVAR{SENTENCEVARrec1},
                         head/I3::ADJ{ADJrec1}[mu2]
                        ] 
               ]
>

   MATCHCONDITIONS
      < I1: T2.cat IN [NPVAR, CNVAR]
        I2: NPrec1 = AUX_NPONHetBprspr
        I3: ADJrec1.adjpatterns * [synAANNP_HETTHATSENT,
                                   synAANNP_HETQSENT] <> []
      >
<

   SUBRULE (* 1 het is aan x1 bekend dat ... *)
      < T2: NPVAR{NPVARrec1}>
      < T2: NPVAR{NPVARrec1}>

      COMP
         <
          C1: (ADJrec1.adjpatterns * [synAANNP_HETTHATSENT,
                                         synAANNP_HETQSENT
                                        ] <> [] )  AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 = 
                         {
                          senttype    : subordinateclause
                          finiteness  : finite
                         }
              )

              C11: (synAANNP_HETTHATSENT IN  ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood = declarative)
              A11: ADJPrec2.adjpatternefs := [synAANNP_HETTHATSENT];
                   ADJPrec2 := ADJPrec1;
                   ADJPPROPrec2.adjpatternefs := [synAANNP_HETTHATSENT];
                   ADJPPROPrec2 := ADJPPROPrec1;

              C12: (synAANNP_HETQSENT IN  ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood IN 
                      [WHInterrogative, YesNoInterrogative])
              A12: ADJPrec2.adjpatternefs := [synAANNP_HETTHATSENT];
                   ADJPrec2 := ADJPrec1;
                   ADJPPROPrec2.adjpatternefs := [synAANNP_HETQSENT];
                   ADJPPROPrec2 := ADJPPROPrec1;

          A1: VARPREPPrec1 := VARPREPPrecdef;
              VARPREPPrec1.specQ := NPVARrec1.specQ;
              VARPREPPrec1.headkey := KEY_aanioprepkey;
              VARPREPPrec1.synppefs := [synNP];
              VARPREPPrec1.thetapp := pp120;
              VARPREPPrec1.actsubcefs := PREPrec1.subcs;
              NPrec1 := AUX_NPONHetBprspr;

         >
      DECOMP
         <
          C1: (ADJrec1.adjpatterns * [synAANNP_HETTHATSENT,
                                         synAANNP_HETQSENT
                                        ] <> [] )  AND
              (SENTENCEVARrec1 =
                         {
                          senttype    : subordinateclause
                          finiteness  : finite
                         }
              ) AND
              (PREPrec1.key = KEY_aanioprepkey) AND
              (VARPREPPrec1 = VARPREPPrecdef 
                EXCEPT FOR [synppefs, headkey, thetapp, actsubcefs, specQ]) AND
              (VARPREPPrec1.specQ = NPVARrec1.specQ) AND
              (VARPREPPrec1.actsubcefs = PREPrec1.subcs) AND
              (VARPREPPrec1.thetapp = pp120) AND
              (VARPREPPrec1.headkey = KEY_aanioprepkey) AND
              (synNP IN VARPREPPrec1.synppefs)

             C11: (synAANNP_HETTHATSENT IN ADJrec1.adjpatterns) AND
                  (synAANNP_HETTHATSENT IN ADJPrec2.adjpatternefs)  AND
                  (synAANNP_HETTHATSENT IN ADJPPROPrec2.adjpatternefs) 
                   AND
                  SENTENCEVARrec1.mood = declarative

             A11: @



             C12: (synAANNP_HETQSENT IN ADJrec1.adjpatterns) AND
                  (synAANNP_HETQSENT IN ADJPrec2.adjpatternefs)  AND
                  (synAANNP_HETQSENT IN ADJPPROPrec2.adjpatternefs) 
                   AND
                  (SENTENCEVARrec1.mood 
                            IN [WHInterrogative, YesNoInterrogative])
             A12: @

           A1:ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

   SUBRULE(* 2,  variant van 1 *)

      < T2: CNVAR{CNVARrec1}>
      < T2: CNVAR{CNVARrec1}>

      COMP
         <
          C1: (ADJrec1.adjpatterns * [synAANNP_HETTHATSENT,
                                         synAANNP_HETQSENT
                                        ] <> [] )  AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 = 
                         {
                          senttype    : subordinateclause
                          finiteness  : finite
                         }
              )

              C11: (synAANNP_HETTHATSENT IN  ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood = declarative)
              A11: ADJPrec2 := ADJPrec1;
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPrec2.adjpatternefs := [synAANNP_HETTHATSENT];
                   ADJPPROPrec2.adjpatternefs := [synAANNP_HETTHATSENT];

              C12: (synAANNP_HETQSENT IN  ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood IN 
                      [WHInterrogative, YesNoInterrogative])
              A12: ADJPrec2 := ADJPrec1;
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPrec2.adjpatternefs := [synAANNP_HETQSENT];
                   ADJPPROPrec2.adjpatternefs := [synAANNP_HETQSENT];

          A1: VARPREPPrec1 := VARPREPPrecdef;
              VARPREPPrec1.specQ := yesspec;
              VARPREPPrec1.headkey := KEY_aanioprepkey;
              VARPREPPrec1.synppefs := [synNP];
              VARPREPPrec1.thetapp := pp120;
              VARPREPPrec1.actsubcefs := PREPrec1.subcs;
              NPrec1 := AUX_NPONHetBprspr;

         >
      DECOMP
         <
          C1: (ADJrec1.adjpatterns * [synAANNP_HETTHATSENT,
                                         synAANNP_HETQSENT
                                        ] <> [] )  AND
              (SENTENCEVARrec1 =
                         {
                          senttype    : subordinateclause
                          finiteness  : finite
                         }
              ) AND
              (PREPrec1.key = KEY_aanioprepkey) AND
              (VARPREPPrec1 = VARPREPPrecdef 
                EXCEPT FOR [synppefs, headkey, thetapp, actsubcefs, specQ]) AND
              (VARPREPPrec1.specQ = yesspec) AND
              (VARPREPPrec1.actsubcefs = PREPrec1.subcs) AND
              (VARPREPPrec1.thetapp = pp120) AND
              (VARPREPPrec1.headkey = KEY_aanioprepkey) AND
              (synNP IN VARPREPPrec1.synppefs)

             C11: (synAANNP_HETTHATSENT IN ADJrec1.adjpatterns) AND
                  (synAANNP_HETTHATSENT IN ADJPrec2.adjpatternefs)  AND
                  (synAANNP_HETTHATSENT IN ADJPPROPrec2.adjpatternefs) 
                   AND
                  SENTENCEVARrec1.mood = declarative

             A12: @

             C12: (synAANNP_HETQSENT IN ADJrec1.adjpatterns) AND
                  (synAANNP_HETQSENT IN ADJPrec2.adjpatternefs) AND
                  (synAANNP_HETQSENT IN ADJPPROPrec2.adjpatternefs) 
                   AND
                  (SENTENCEVARrec1.mood 
                            IN [WHInterrogative, YesNoInterrogative])
             A12: @

          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >
>                              
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] TADJPATTERN25
\item[* relevant examples:] het is aan x1 bekend/onduidelijk dat/of .........
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] AdjpPropFormation
\item[* class:] TC:ADJPATTERNRULES
\item[* date of creation:] 28-JAN-1988 15:27:10  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
% TRANSFORMATION TADJPATTERN26       (* het is (x1) bekend/duidelijk
                                        dat/of  .... *)

< m1: ADJPPROP{ADJPPROPrec1}[ predrel/ADJP{ADJPrec1}
                                       [ argrel/T1,
                                         argrel/SENTENCEVAR{SENTENCEVARrec1},
                                         head/I3::ADJ{ADJrec1}[mu2]
                                       ] 
                               ]
>

< m : ADJPPROP{ADJPPROPrec2}
               [ predrel/ADJP{ADJPrec2}
                        [I1:indobjrel/T1,
		         objrel/I2::NP{NPrec1}
                                       [head/PERSPRO{PERSPROrec1}
                                             [head/BPERSPRO(KEY_HETBPERSPROkey)
                                                                 {BPERSPROrec1}]
                                       ],
                         complrel/SENTENCEVAR{SENTENCEVARrec1},
                         head/I3::ADJ{ADJrec1}[mu2]
		        ] 
	       ]
>
   MATCHCONDITIONS
      <I1: T1.cat IN [NPVAR,CNVAR,EMPTYVAR]
       I2: NPrec1 = AUX_NPONHetBprspr
       I3: ADJrec1.adjpatterns * [synIONP_HETTHATSENT,
                                  synIONP_HETQSENT,
                                  synIOEMPTY_HETTHATSENT,
                                  synIOEMPTY_HETQSENT] <> []
      >

<
   SUBRULE (* 1 het is  x1 bekend dat ... *)
      < T1: NPVAR{NPVARrec1}>
      < T1: NPVAR{NPVARrec1}>

      COMP
         <
          C1: (ADJrec1.adjpatterns * [synIONP_HETTHATSENT,
                                      synIONP_HETQSENT
                                     ] <> [] )  AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 = 
                        {
                          senttype    : subordinateclause
                          finiteness  : finite
                        }
              )

              C11: (synIONP_HETTHATSENT IN ADJrec1.adjpatterns ) AND
                   (SENTENCEVARrec1.mood = declarative)
              A11: ADJPrec2 := ADJPrec1;
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPrec2.adjpatternefs := [synIONP_HETTHATSENT];
                   ADJPPROPrec2.adjpatternefs := [synIONP_HETTHATSENT];

              C12: synIONP_HETQSENT IN ADJrec1.adjpatterns
                   C111: SENTENCEVARrec1.mood = WHInterrogative
                   A111: @
                   C112: SENTENCEVARrec1.mood = YesNoInterrogative
                   A112: @
              A12: ADJPrec2 := ADJPrec1;
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPrec2.adjpatternefs := [synIONP_HETQSENT];
                   ADJPPROPrec2.adjpatternefs := [synIONP_HETQSENT];

          A1: NPrec1 : = AUX_NPONHetBprspr;
         >
      DECOMP
         <
          C1: (ADJrec1.adjpatterns * [synIONP_HETTHATSENT,
                                         synIONP_HETQSENT
                                        ] <> [] )  AND
              (SENTENCEVARrec1 =
                         {
                          senttype    : subordinateclause
                          finiteness  : finite
                         }
              ) 

              C11: (synIONP_HETTHATSENT IN ADJrec1.adjpatterns) AND
                   (synIONP_HETTHATSENT IN ADJPrec2.adjpatternefs) AND
                   (synIONP_HETTHATSENT IN ADJPPROPrec2.adjpatternefs) AND
                   (SENTENCEVARrec1.mood = declarative)
              A11: @

              C12: (synIONP_HETQSENT IN ADJrec1.adjpatterns) AND
                   (synIONP_HETQSENT IN ADJPrec2.adjpatternefs) AND
                   (synIONP_HETQSENT IN ADJPPROPrec2.adjpatternefs)
                   C111: SENTENCEVARrec1.mood = WHInterrogative
                   A111: @
                   C112: SENTENCEVARrec1.mood = YesNoInterrogative
                   A112: @
              A12: ADJPPROPrec2.adjpatternefs := [synIONP_HETQSENT];


          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

   SUBRULE(* 2,  variant van 1 *)

      < T1: CNVAR{CNVARrec1}>
      < T1: CNVAR{CNVARrec1}>

      COMP
         <
          C1: (ADJrec1.adjpatterns * [synIONP_HETTHATSENT,
                                      synIONP_HETQSENT
                                     ] <> [] )  AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 = 
                         {
                          senttype    : subordinateclause
                          finiteness  : finite
                         }
              )

              C11: (synIONP_HETTHATSENT IN ADJrec1.adjpatterns ) AND
                   (SENTENCEVARrec1.mood = declarative)
              A11: ADJPrec2 := ADJPrec1;
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPrec2.adjpatternefs := [synIONP_HETTHATSENT];
                   ADJPPROPrec2.adjpatternefs := [synIONP_HETTHATSENT];

              C12: (synIONP_HETQSENT IN ADJrec1.adjpatterns)
                   C111: SENTENCEVARrec1.mood = WHInterrogative
                   A111: @
                   C112: SENTENCEVARrec1.mood = YesNoInterrogative
                   A112: @
              A12: ADJPrec2 := ADJPrec1;
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPrec2.adjpatternefs := [synIONP_HETQSENT];
                   ADJPPROPrec2.adjpatternefs := [synIONP_HETQSENT];

          A1: NPrec1 : = AUX_NPONHetBprspr;
         >
      DECOMP
         <
          C1: (ADJrec1.adjpatterns * [synIONP_HETTHATSENT,
                                         synIONP_HETQSENT
                                        ] <> [] )  AND
              (SENTENCEVARrec1 =
                         {
                          senttype    : subordinateclause
                          finiteness  : finite
                         }
              ) 

              C11: (synIONP_HETTHATSENT IN ADJrec1.adjpatterns) AND
                   (synIONP_HETTHATSENT IN ADJPrec2.adjpatternefs) AND
                   (synIONP_HETTHATSENT IN ADJPPROPrec2.adjpatternefs) AND
                   (SENTENCEVARrec1.mood = declarative)
              A11: @

              C12: (synIONP_HETQSENT IN ADJrec1.adjpatterns) AND
                   (synIONP_HETQSENT IN ADJPrec2.adjpatternefs) AND
                   (synIONP_HETQSENT IN ADJPPROPrec2.adjpatternefs)
                   C111: SENTENCEVARrec1.mood = WHInterrogative
                   A111: @
                   C112: SENTENCEVARrec1.mood = YesNoInterrogative
                   A112: @
              A12: @


          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >

   SUBRULE(* 3,  variant van 1 *)

      < T1: EMPTYVAR{EMPTYVARrec1}>
      < T1: EMPTYVAR{EMPTYVARrec1}>

      COMP
         <
          C1: (ADJrec1.adjpatterns * [synIOEMPTY_HETTHATSENT,
                                      synIOEMPTY_HETQSENT
                                     ] <> [] )  AND
              (ADJPrec1.adjpatternefs = []) AND
              (ADJPPROPrec1.adjpatternefs = []) AND
              (SENTENCEVARrec1 = 
                         {
                          senttype    : subordinateclause
                          finiteness  : finite
                         }
              )

              C11: (synIOEMPTY_HETTHATSENT IN ADJrec1.adjpatterns) AND
                   (SENTENCEVARrec1.mood = declarative)
              A11: ADJPrec2 := ADJPrec1;
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPrec2.adjpatternefs := [synIOEMPTY_HETTHATSENT];
                   ADJPPROPrec2.adjpatternefs := [synIOEMPTY_HETTHATSENT];


              C12: (synIOEMPTY_HETQSENT IN ADJrec1.adjpatterns)
                   C111: SENTENCEVARrec1.mood = WHInterrogative
                   A111: @
                   C112: SENTENCEVARrec1.mood = YesNoInterrogative
                   A112: @
              A12: ADJPrec2 := ADJPrec1;
                   ADJPPROPrec2 := ADJPPROPrec1;
                   ADJPrec2.adjpatternefs := [synIOEMPTY_HETQSENT];
                   ADJPPROPrec2.adjpatternefs := [synIOEMPTY_HETQSENT];

          A1: NPrec1 : = AUX_NPONHetBprspr;
         >
      DECOMP
         <
          C1: (ADJrec1.adjpatterns * [synIOEMPTY_HETTHATSENT,
                                         synIOEMPTY_HETQSENT
                                        ] <> [] )  AND
              (SENTENCEVARrec1 =
                         {
                          senttype    : subordinateclause
                          finiteness  : finite
                         }
              ) 

              C11: (synIOEMPTY_HETTHATSENT IN ADJrec1.adjpatterns) AND
                   (synIOEMPTY_HETTHATSENT IN ADJPrec2.adjpatternefs) AND
                   (synIOEMPTY_HETTHATSENT IN ADJPPROPrec2.adjpatternefs) AND
                   (SENTENCEVARrec1.mood = declarative)
              A11: @

              C12: (synIOEMPTY_HETQSENT IN ADJrec1.adjpatterns) AND
                   (synIOEMPTY_HETQSENT IN ADJPrec2.adjpatternefs) AND
                   (synIOEMPTY_HETQSENT IN ADJPPROPrec2.adjpatternefs)
                   C111: SENTENCEVARrec1.mood = WHInterrogative
                   A111: @
                   C112: SENTENCEVARrec1.mood = YesNoInterrogative
                   A112: @
              A12: @

          A1: ADJPrec1 := ADJPrec2;
              ADJPPROPrec1 := ADJPPROPrec2;
              ADJPrec1.adjpatternefs := [];
              ADJPPROPrec1.adjpatternefs := [];
         >


>                              
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] TADJPATTERN26
\item[* relevant examples:] het is (x1) bekend/onduidelijk dat/of .........
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] AdjpPropFormation
\item[* class:] TC:ADJPATTERNRULES
\item[* date of creation:] 28-JAN-1988 16:12:10  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{} 
\begin{enumerate}
\item N.B. most embedded CA-pairs can be collapsed
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
%%
