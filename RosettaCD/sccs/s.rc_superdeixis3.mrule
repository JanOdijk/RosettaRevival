h04317
s 03011/00000/00001
d D 1.2 92/02/21 15:44:42 rous 2 1
c 
e
s 00001/00000/00000
d D 1.1 92/02/11 11:48:22 rous 1 0
c date and time created 92/02/11 11:48:22 by rous
e
u
U
f e 0
t
T
I 2
DUTCH 74
&
\newpage
\begin{verbatim}
%
% RULE RfinpresentsuperdeixisA
< m1:CLAUSE{CLAUSErec1}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I3:rel1/VERB{VERBrec1}
                           [I5:rel2/VERB{VERBrec3}[head/T2],
                            mu6
                           ]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I4:rel1/VERB{VERBrec2}
                           [I6:rel2/VERB{VERBrec4}[head/T2],
                            mu6
                           ]
                   ],
            mu5
           ] 

>
   MATCHCONDITIONS
      <
       I1: QUOTE_temprefnotfound(mu1)
       I2: QUOTE_temprefnotfound(mu2)
       m1: CLAUSErec1.deixis = omegadeixis AND
           CLAUSErec1.finiteness = finite
       I3: VERBrec1.tense = omegatense AND
           VERbrec1.status IN [VV,AuxV]
       I5: VERbrec3.tense = omegatense AND
           VERBrec3.modus = infinitive
       m : CLAUSErec2.finiteness = finite AND
           CLAUSErec2.deixis = omegadeixis
       I4: VERBrec2.tense = presenttense AND
           VERbrec2.status IN [VV, AuxV]
       I6: VERBrec4.tense = presenttense AND
           VERBrec4.modus = omegamodus


      >
<
   SUBRULE (* 1 *)
      <T2: SUBVERB{SUBVERBrec1}[I9:head/BVERB(KEY1){BVERBrec1}] >
      <T2: SUBVERB{SUBVERBrec1}[I9:head/BVERB(KEY1){BVERBrec1}] >

   MATCHCONDITIONS
      <
       I9: KEY1 <> KEY_kanirr1BVERBkey AND
           KEY1 <> KEY_kanirr2BVERBkey AND
           KEY1 <> KEY_moetirr1BVERBkey AND
           KEY1 <> KEY_moetirr2BVERBkey       
      >

<
   SUBRULE
      <sig1: [ ]>
      <sig1: [ ]>

      COMP
         <
          C1: true
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERbrec3;
              VERbrec4.tense := presenttense;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
E 2
I 1
 
I 2
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := omegamodus;

         >

   SUBRULE
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1: (ADVPVARrec1.class = reference) AND
              (ADVPVARrec1.retro = false) AND
              ((ADVPVARrec1.deixis = omegadeixis) OR
               (ADVPVARrec1.deixis = futuredeixis)
              )

      >

      COMP
         <
          C1:true
                   
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERbrec3;
              VERbrec4.tense := presenttense;
              VERBrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1: true

              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := omegamodus;

         >

   SUBRULE
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            ((PREPPVARrec1.deixis = omegadeixis) OR
             (PREPPVARrec1.deixis = futuredeixis)
            ) 
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERbrec3;
              VERbrec4.tense := presenttense;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1: true

              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := omegamodus;
         >

   SUBRULE
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>

   MATCHCONDITIONS
      <
       sig1: (SENTENCErec1.conjclass = reference) AND
             (SENTENCErec1.conjretro = false) AND
             ((SENTENCErec1.conjdeixis = omegadeixis) OR
              (SENTENCErec1.conjdeixis = futuredeixis)
             )
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERbrec3;
              VERbrec4.tense := presenttense;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1: true

              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := omegamodus;
         >
>

   SUBRULE (* 2 *)
      <T2: SUBVERB{SUBVERBrec1}
                  [sig2, head/SUBVERB{SUBVERBrec2}
                       [I9:head/BVERB(KEY1){BVERBrec1}]
                  ]
       >
      <T2: SUBVERB{SUBVERBrec1}
                  [sig2, head/SUBVERB{SUBVERBrec2}
                       [I9:head/BVERB(KEY1){BVERBrec1}]
                  ]
       >

   MATCHCONDITIONS
      <
       I9: KEY1 <> KEY_kanirr1BVERBkey AND
           KEY1 <> KEY_kanirr2BVERBkey AND
           KEY1 <> KEY_moetirr1BVERBkey AND
           KEY1 <> KEY_moetirr2BVERBkey       
      >

<
   SUBRULE
      <sig1: [ ]>
      <sig1: [ ]>

      COMP
         <
          C1:true
                   
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERbrec3;
              VERbrec4.tense := presenttense;
              VERBrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1: true

              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := omegamodus;

         >

   SUBRULE
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1: (ADVPVARrec1.class = reference) AND
              (ADVPVARrec1.retro = false) AND
              ((ADVPVARrec1.deixis = omegadeixis) OR
               (ADVPVARrec1.deixis = futuredeixis)
              )

      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERbrec3;
              VERbrec4.tense := presenttense;
              VERBrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1: true

              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := omegamodus;

         >

   SUBRULE
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            ((PREPPVARrec1.deixis = omegadeixis) OR
             (PREPPVARrec1.deixis = futuredeixis)
            ) 
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERbrec3;
              VERbrec4.tense := presenttense;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1: true

              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := omegamodus;
         >

   SUBRULE
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>

   MATCHCONDITIONS
      <
       sig1: (SENTENCErec1.conjclass = reference) AND
             (SENTENCErec1.conjretro = false) AND
             ((SENTENCErec1.conjdeixis = omegadeixis) OR
              (SENTENCErec1.conjdeixis = futuredeixis)
             )
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERbrec3;
              VERbrec4.tense := presenttense;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1: true

              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := omegamodus;
         >
>
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RfinpresentsuperdeixisA
\item[* relevant examples:] Hij zegt (dat Jan toevallig kan slapen)
                            Hij zegt (dat hij toevallig om 3 uur kan komen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 11-MAR-1990 
\item[* author:] Lisette Appelo
\item[* copied from:] Rfinpresentdeixis
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is simultanuous: PRESENT.
               This rule is for a finite dependent clause.
               The most right verb in the clause gets a present tense.
               The deixis 
value of the possible reference adverbial is checked for 
               omega.
               The clause is marked for present superdeixis.
This rule is for cases with {\em graag} and {\em toevallig} and verb clusters.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different categories of the variables for the 
reference adverbials and the not occurrence of a reference adverbial. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: 
\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rfinpastsuperdeixis1A
< m1:CLAUSE{CLAUSErec1}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I3:rel1/VERB{VERBrec1}
                           [I5:rel2/VERB{VERBrec3}[head/T2],
                            mu6
                           ]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I4:rel1/VERB{VERBrec2}
                           [I6:rel2/VERB{VERBrec4}[head/T2],
                            mu6
                           ]
                   ],
            mu5
           ] 

>
   MATCHCONDITIONS
      <
       I1: QUOTE_temprefnotfound(mu1)
       I2: QUOTE_temprefnotfound(mu2)
       m1: ((CLAUSErec1.aspect = imperfective) OR
            (CLAUSErec1.aspect = habitual) OR
            ((CLAUSErec1.aspect = perfective) AND
             ((CLAUSErec1.aktionsarts * [accomplishment, achievement] <> []) OR
              ((CLAUSErec1.aktionsarts * [activity, stative] <> []) AND
               (NOT (QUOTE_tempdurnotfound(mu2)) OR
                NOT (QUOTE_tempretronotfound(mu2))
               )
              )
             )
            )
           ) AND
           (CLAUSErec1.deixis = omegadeixis) AND
           (CLAUSErec1.finiteness = finite)
       I3: (VERBrec1.tense = omegatense) AND
           (VERBrec1.status IN [VV,AuxV])
       I5: (VERBrec3.tense = omegatense) AND
           (VERBrec3.modus = infinitive)
       m2: ((CLAUSErec2.aspect = imperfective) OR
            (CLAUSErec2.aspect = habitual) OR
            ((CLAUSErec2.aspect = perfective) AND
             ((CLAUSErec2.aktionsarts * [accomplishment, achievement] <> []) OR
              ((CLAUSErec2.aktionsarts * [activity, stative] <> []) AND
               (NOT (QUOTE_tempdurnotfound(mu2)) OR
                NOT (QUOTE_tempretronotfound(mu2))
               )
              )
             )
            )
           ) AND
           (CLAUSErec2.finiteness = finite) AND
           (CLAUSErec2.deixis = omegadeixis)
       I4: (VERBrec2.tense = pasttense) AND
           (VERBrec2.status IN [VV,AuxV])
       I6: (VERBrec4.tense = pasttense) AND
           (VERBrec4.modus = omegamodus)

         
      >
<
   SUBRULE (* 1 *)
      <T2: SUBVERB{SUBVERBrec1}[I9:head/BVERB(KEY1){BVERBrec1}] >
      <T2: SUBVERB{SUBVERBrec1}[I9:head/BVERB(KEY1){BVERBrec1}] >

   MATCHCONDITIONS
      <
       I9: KEY1 <> KEY_kanirr1BVERBkey AND
           KEY1 <> KEY_kanirr2BVERBkey AND
           KEY1 <> KEY_moetirr1BVERBkey AND
           KEY1 <> KEY_moetirr2BVERBkey       
      >

<
   SUBRULE
      <sig1: [ ]>
      <sig1: [ ]>

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERBrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            ((NOT (QUOTE_tempdurnotfound(mu2))) OR
                             (NOT (QUOTE_tempretronotfound(mu2))) OR
                             (VERBrec2.subc = modalverb)
                            )
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             ((NOT (QUOTE_tempretronotfound(mu2))) OR
                              (NOT (QUOTE_tempdurnotfound(mu2)))
                             )
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := infinitive;
         >

   SUBRULE
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            ((ADVPVARrec1.deixis = omegadeixis) OR
             (ADVPVARrec1.deixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
                   
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERBrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1: true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            ((NOT (QUOTE_tempdurnotfound(mu2))) OR
                             (NOT (QUOTE_tempretronotfound(mu2))) OR
                             (VERBrec2.subc = modalverb)
                            )
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             ((NOT (QUOTE_tempdurnotfound(mu2))) OR
                              (NOT (QUOTE_tempretronotfound(mu2))) 
                             )
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @

          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := infinitive;

         >

   SUBRULE
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            ((PREPPVARrec1.deixis = omegadeixis) OR
             (PREPPVARrec1.deixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
                   
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1: true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            ((NOT (QUOTE_tempdurnotfound(mu2))) OR
                             (NOT (QUOTE_tempretronotfound(mu2))) OR
                             (VERBrec2.subc = modalverb)
                            )
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             ((NOT (QUOTE_tempretronotfound(mu2))) OR
                              (NOT (QUOTE_tempdurnotfound(mu2)))
                             )
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := infinitive;
         >

   SUBRULE
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            ((SENTENCErec1.conjdeixis = omegadeixis) OR
             (SENTENCErec1.conjdeixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
                   
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            ((NOT (QUOTE_tempdurnotfound(mu2))) OR
                             (NOT (QUOTE_tempretronotfound(mu2))) OR 
                             (VERBrec2.subc = modalverb)
                            )
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             ((NOT (QUOTE_tempretronotfound(mu2))) OR
                              (NOT (QUOTE_tempdurnotfound(mu2)))
                             )
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := infinitive;
         >
>
   SUBRULE (* 2 *)
      <T2: SUBVERB{SUBVERBrec1}
                  [sig2, head/SUBVERB{SUBVERBrec2}
                       [I9:head/BVERB(KEY1){BVERBrec1}]
                  ]
       >
      <T2: SUBVERB{SUBVERBrec1}
                  [sig2, head/SUBVERB{SUBVERBrec2}
                       [I9:head/BVERB(KEY1){BVERBrec1}]
                  ]
       >

   MATCHCONDITIONS
      <
       I9: KEY1 <> KEY_kanirr1BVERBkey AND
           KEY1 <> KEY_kanirr2BVERBkey AND
           KEY1 <> KEY_moetirr1BVERBkey AND
           KEY1 <> KEY_moetirr2BVERBkey       
      >
<
   SUBRULE
      <sig1: [ ]>
      <sig1: [ ]>

      COMP
         <
          C1:true
                   
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERBrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            ((NOT (QUOTE_tempdurnotfound(mu2))) OR
                             (NOT (QUOTE_tempretronotfound(mu2))) OR
                             (VERBrec2.subc = modalverb)
                            )
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             ((NOT (QUOTE_tempretronotfound(mu2))) OR
                              (NOT (QUOTE_tempdurnotfound(mu2)))
                             )
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := infinitive;

         >

   SUBRULE
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            ((ADVPVARrec1.deixis = omegadeixis) OR
             (ADVPVARrec1.deixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
                   
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERBrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            ((NOT (QUOTE_tempdurnotfound(mu2))) OR
                             (NOT (QUOTE_tempretronotfound(mu2))) OR
                             (VERBrec2.subc = modalverb)
                            )
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             ((NOT (QUOTE_tempretronotfound(mu2))) OR
                              (NOT (QUOTE_tempdurnotfound(mu2)))
                             )
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := infinitive;

         >

   SUBRULE
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>


   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            ((PREPPVARrec1.deixis = omegadeixis) OR
             (PREPPVARrec1.deixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
                   
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            ((NOT (QUOTE_tempdurnotfound(mu2))) OR
                             (NOT (QUOTE_tempretronotfound(mu2))) OR
                             (VERBrec2.subc = modalverb)
                            )
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             ((NOT (QUOTE_tempretronotfound(mu2))) OR
                              (NOT (QUOTE_tempdurnotfound(mu2)))
                             )
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := infinitive;
         >

   SUBRULE
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            ((SENTENCErec1.conjdeixis = omegadeixis) OR
             (SENTENCErec1.conjdeixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
                   
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            ((NOT (QUOTE_tempdurnotfound(mu2))) OR
                             (NOT (QUOTE_tempretronotfound(mu2))) OR
                             (VERBrec2.subc = modalverb)
                            )
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             ((NOT (QUOTE_tempretronotfound(mu2))) OR
                              (NOT (QUOTE_tempdurnotfound(mu2)))
                             )
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERBrec4;
              VERBrec3.tense := omegatense;
              VERBrec3.modus := infinitive;
         >
>
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rfinpastsuperdeixis1A
\item[* relevant examples:] Hij zei (dat Jan toevallig kon slapen)
                            Hij zei (dat hij toevallig om 3 uur kon komen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 11-MAR-1990
\item[* author:] Lisette Appelo
\item[* copied from:] Rfinpastsuperdeixis
\item[* modification:]\mbox{}
\begin{enumerate}
\end{enumerate}
\item[* task:] The relation between Rs and S is before: PAST.
               This rule is for a finite dependent clause.
               The most right verb in the clause gets a past tense.
               The deixis 
value of the possible reference adverbial is checked for 
               omega.
               The clause is marked for past superdeixis.
This rule is for cases with {\em toevallig} and {\em graag} and verb clusters.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different categories of the variables for the 
reference adverbials and the not occurrence of a reference adverbial. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] In analysis a choice is 
made for the efficiency set of aktionsart  values. In generation this is not 
necessary as aktionsart has only one value there. The efficiency set is for 
purposes of analysis.
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: \\
\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rfinpastsuperdeixis2A
< m1:CLAUSE{CLAUSErec1}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I3:rel1/VERB{VERBrec1}
                           [I5:rel2/VERB{VERbrec3}[head/T2],
                            mu6
                           ]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I4:rel1/VERB{VERBrec2}
                           [I6:rel2/VERB{VERBrec4}[head/T2],
                            mu6
                           ]
                   ],
            mu5
           ] 

>
   MATCHCONDITIONS
      <
       I1: QUOTE_temprefnotfound(mu1)
       I2: QUOTE_temprefnotfound(mu2)
       m1: ((CLAUSErec1.aspect = imperfective) OR
            (CLAUSErec1.aspect = habitual) OR
            ((CLAUSErec1.aspect = perfective) AND
             ((CLAUSErec1.aktionsarts * [accomplishment, achievement] <> []) OR
              ((CLAUSErec1.aktionsarts * [activity, stative] <> []) AND
               (NOT (QUOTE_tempdurnotfound(mu2)))
              )
             )
            )
           ) AND
           (CLAUSErec1.deixis = omegadeixis) AND
           (CLAUSErec1.finiteness = finite)

       m : ((CLAUSErec2.aspect = imperfective) OR
            (CLAUSErec2.aspect = habitual) OR
            ((CLAUSErec2.aspect = perfective) AND
             ((CLAUSErec2.aktionsarts * [accomplishment, achievement] <> []) OR
              ((CLAUSErec2.aktionsarts * [activity, stative] <> []) AND
               (NOT (QUOTE_tempdurnotfound(mu2)))
              )
             )
            )
           ) AND
           (CLAUSErec2.finiteness = finite) AND
           (CLAUSErec2.deixis = omegadeixis)
       I3: (VERBrec1.tense = omegatense) AND
           (VERBrec1.status IN [VV, AuxV])
       I5: (VERBrec3.tense = omegatense) AND
           (VERBrec3.modus = infinitive)
       I4: (VERBrec2.tense = pasttense) AND
           (VERBrec2.status IN [VV, AuxV])
       I6: (VERBrec4.tense  = pasttense) AND
           (VERBrec4.modus = omegamodus)


      >

<
   SUBRULE (* 1 *)
      <T2: SUBVERB{SUBVERBrec1}[I9:head/BVERB(KEY1){BVERBrec1}] >
      <T2: SUBVERB{SUBVERBrec1}[I9:head/BVERB(KEY1){BVERBrec1}] >

   MATCHCONDITIONS
      <
       I9: KEY1 <> KEY_kanirr1BVERBkey AND
           KEY1 <> KEY_kanirr2BVERBkey AND
           KEY1 <> KEY_moetirr1BVERBkey AND
           KEY1 <> KEY_moetirr2BVERBkey       
      >

<

   SUBRULE
      <sig1: [ ]>
      <sig1: [ ]>

      COMP
         <
          C1:(NOT (QUOTE_tempdurnotfound(mu2))) 

             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1:(NOT (QUOTE_tempdurnotfound(mu2))) 

              C12: (CLAUSErec2.superdeixis = pastdeixis)
              A12: @

          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3:= VERbrec4;
              VERbrec3.tense := omegatense;
              VERBrec3.modus := infinitive;

         >

   SUBRULE
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            (ADVPVARrec1.deixis = omegadeixis) 
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            NOT (QUOTE_tempdurnotfound(mu2))
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             NOT (QUOTE_tempdurnotfound(mu2))
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3:= VERbrec4;
              VERbrec3.tense := omegatense;
              VERBrec3.modus := infinitive;

         >

   SUBRULE
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            (PREPPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:true
              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            NOT (QUOTE_tempdurnotfound(mu2))
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             NOT (QUOTE_tempdurnotfound(mu2))
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3:= VERbrec4;
              VERbrec3.tense := omegatense;
              VERBrec3.modus := infinitive;
         >

   SUBRULE
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            (SENTENCErec1.conjdeixis = omegadeixis)
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            NOT (QUOTE_tempdurnotfound(mu2))
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             NOT (QUOTE_tempdurnotfound(mu2))
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3:= VERbrec4;
              VERbrec3.tense := omegatense;
              VERBrec3.modus := infinitive;
         >
>
   SUBRULE (* 2 *)
      <T2: SUBVERB{SUBVERBrec1}
                  [sig2, head/SUBVERB{SUBVERBrec2}
                       [I9:head/BVERB(KEY1){BVERBrec1}]
                  ]
       >
      <T2: SUBVERB{SUBVERBrec1}
                  [sig2, head/SUBVERB{SUBVERBrec2}
                       [I9:head/BVERB(KEY1){BVERBrec1}]
                  ]
       >

   MATCHCONDITIONS
      <
       I9: KEY1 <> KEY_kanirr1BVERBkey AND
           KEY1 <> KEY_kanirr2BVERBkey AND
           KEY1 <> KEY_moetirr1BVERBkey AND
           KEY1 <> KEY_moetirr2BVERBkey       
      >
<

   SUBRULE
      <sig1: [ ]>
      <sig1: [ ]>

      COMP
         <
          C1:(NOT (QUOTE_tempdurnotfound(mu2))) 
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1:(NOT (QUOTE_tempdurnotfound(mu2))) 

              C12: (CLAUSErec2.superdeixis = pastdeixis)
              A12: @

          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3:= VERbrec4;
              VERbrec3.tense := omegatense;
              VERBrec3.modus := infinitive;

         >

   SUBRULE
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            (ADVPVARrec1.deixis = omegadeixis) 
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            NOT (QUOTE_tempdurnotfound(mu2))
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             NOT (QUOTE_tempdurnotfound(mu2))
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3:= VERbrec4;
              VERbrec3.tense := omegatense;
              VERBrec3.modus := infinitive;

         >

   SUBRULE
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            (PREPPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            NOT (QUOTE_tempdurnotfound(mu2))
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             NOT (QUOTE_tempdurnotfound(mu2))
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3:= VERbrec4;
              VERbrec3.tense := omegatense;
              VERBrec3.modus := infinitive;
         >

   SUBRULE
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>


   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            (SENTENCErec1.conjdeixis = omegadeixis)
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
                 C121: CLAUSErec2.aspect = perfective
                      C1211:stative IN CLAUSErec2.aktionsarts AND
                            NOT (QUOTE_tempdurnotfound(mu2))
                      A1211: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [stative];
                      C1212: activity IN CLAUSErec2.aktionsarts AND
                             NOT (QUOTE_tempdurnotfound(mu2))
                      A1212: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [activity];
                      C1213: accomplishment IN CLAUSErec2.aktionsarts
                      A1213: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [accomplishment];
                      C1214: achievement IN CLAUSErec2.aktionsarts
                      A1214: CLAUSErec1 := CLAUSErec2;
                             CLAUSErec1.aktionsarts := [achievement];
                 A121: @
                 C122: CLAUSErec2.aspect IN [imperfective, habitual]
                 A122: CLAUSErec1 := CLAUSErec2;

              A12: @
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3:= VERbrec4;
              VERbrec3.tense := omegatense;
              VERBrec3.modus := infinitive;
         >
>
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rfinpastsuperdeixis2A
\item[* relevant examples:] Hij zei (dat hij toevallig om 3 uur kon komen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 11-MAR-1990
\item[* author:] Lisette Appelo
\item[* copied from:] Rfinpastsuperdeixis2
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author: 
\item date: ../../..\ \ \ \ \ author: 
\end{enumerate}
\item[* task:] The indirect relation between Rs and S is before: PAST.
               This rule is for a finite dependent clause.
               The most right verb in the clause gets a past tense.
               The deixis 
value of the reference adverbial is checked for 
               omega.
               The clause is marked for past superdeixis.
This is a special rule for {\em graag, toevallig} cases and verb clusters.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different categories of the variables for the 
reference adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] In analysis a choice is 
made for the efficiency set of aktionsart  values. In generation this is not 
necessary as aktionsart has only one value there. The efficiency set is for 
purposes of analysis.
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:] This rule has the same semantics as 
Rfinpastsuperdeixisspec and Rinfinpastsuperdeixisspec.
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53, 263, 314.
\item[\ \ remarks:]The rule Rfinpastsuperdeixis has been split up into two rules 
Rfinpastsuperdeixis1 and Rfinpastsuperdeixis2. This rule is the new one and 
corresponds to Lpastpastsuperdeixis.

\begin{enumerate}
\item problems:\\

\item modifications: \\
\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE RinfinpresentsuperdeixisA
< m1:CLAUSE{CLAUSErec1}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I3:rel1/VERB{VERBrec1}
                           [I4:rel2/VERB{VERbrec2}[mu4],
                            mu6
                           ]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I3:rel1/VERB{VERBrec1}
                           [I5:rel2/VERB{VERbrec3}[mu4],
                            mu6
                           ]
                   ],
            mu5
           ] 

>
   MATCHCONDITIONS
      <
       I1: QUOTE_temprefnotfound(mu1)
       I2: QUOTE_temprefnotfound(mu2)
       m1: (CLAUSErec1.deixis = omegadeixis) AND
           (CLAUSErec1.finiteness = infinite)
       I3: (VERBrec1.tense = omegatense) AND
           (VERBRec1.status IN [VV, AuxV])
       I4: (VERbrec2.tense = omegatense) AND
           (VERbrec2.modus = infinitive)
       I5: (VERBrec3.tense = omegatense) AND
           (VERBrec3.modus = omegamodus) 
       m : (CLAUSErec2.finiteness = infinite) AND
           (CLAUSErec2.deixis = omegadeixis)

      >

<
   SUBRULE
      <sig1: [ ]>
      <sig1: [ ]>


      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec3 := VERBrec2;
              VERBRec3.modus := omegamodus;
         >
      DECOMP
         <
          C1:true
              
              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec2 := VERBrec3;
              VERBrec2.modus := infinitive;
         >

   SUBRULE
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            ((ADVPVARrec1.deixis = omegadeixis) OR
             (ADVPVARrec1.deixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
                          
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec3 := VERBrec2;
              VERBRec3.modus := omegamodus;

         >
      DECOMP
         <
          C1:true
              
              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec2 := VERBrec3;
              VERBrec2.modus := infinitive;

         >

   SUBRULE
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            ((PREPPVARrec1.deixis = omegadeixis) OR
             (PREPPVARrec1.deixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
                          
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec3 := VERBrec2;
              VERBRec3.modus := omegamodus;

         >
      DECOMP
         <
          C1:true
              
              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec2 := VERBrec3;
              VERBrec2.modus := infinitive;

         >

   SUBRULE
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            ((SENTENCErec1.conjdeixis = omegadeixis) OR
             (SENTENCErec1.conjdeixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
                          
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec3 := VERBrec2;
              VERBRec3.modus := omegamodus;

         >
      DECOMP
         <
          C1:true
              
              C12: (CLAUSErec2.superdeixis = presentdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec2 := VERBrec3;
              VERBrec2.modus := infinitive;

         >
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RinfinpresentsuperdeixisA
\item[* relevant examples:] Hij probeert (graag te kunnen slapen)
                            Hij probeert (toevallig om 3 uur te kunnen komen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 12-MAR-1990 
\item[* author:] Lisette Appelo
\item[* copied from:] Rinfinpresentsuperdeixis
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is simultanuous: PRESENT.
               This rule is for a infinite dependent clause.
               The deixis value of the possible reference adverbial is checked 
               for omega or future.
               The clause is marked for present superdeixis.
               This rule is for cases with {\em graag} and {\em toevallig} and
               verb clusters.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different categories of the variables for the 
reference adverbials and the not occurrence of a reference adverbial. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53, 263, 314, 320
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The superdeixis value also may be presentdeixis in the case 
this sentence is a sentence with {\em graag}\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE RinfinpastsuperdeixisA
< m1:CLAUSE{CLAUSErec1}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I3:rel1/VERB{VERBrec1}
                           [I4:rel2/VERB{VERBrec2}[mu4],
                            mu6
                           ]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I3:rel1/VERB{VERBrec1}
                           [I5:rel2/VERB{VERBrec3}[mu4],
                            mu6
                           ]
                   ],
            mu5
           ] 

>
   MATCHCONDITIONS
      <
       I1: QUOTE_temprefnotfound(mu1)
       I2: QUOTE_temprefnotfound(mu2)
       m1: (CLAUSErec1.deixis = omegadeixis) AND
           (CLAUSErec1.finiteness = infinite)
       I3: (VERBrec1.tense = omegatense) AND
           (VERBrec1.status IN [VV,AuxV])
       m : (CLAUSErec2.finiteness = infinite) AND
           (CLAUSErec2.deixis = omegadeixis)
       I4: VERbrec2.tense = omegatense AND
           VERBrec2.modus = infinitive
       I5: VERbrec3.tense = omegatense AND
           VERBrec3.modus = omegamodus

      >

<
   SUBRULE
      <sig1: [ ]>
      <sig1: [ ]>

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec3 := VERBrec2;
              VERbrec3.modus := omegamodus;
         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
              A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec2 := VERBrec3;
              VERBrec2.modus := infinitive;
         >

   SUBRULE
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            ((ADVPVARrec1.deixis = omegadeixis) OR
             (ADVPVARrec1.deixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec3 := VERBrec2;
              VERbrec3.modus := omegamodus;

         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec2 := VERBrec3;
              VERBrec2.modus := infinitive;

         >

   SUBRULE
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]>

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            ((PREPPVARrec1.deixis = omegadeixis) OR
             (PREPPVARrec1.deixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
          A1: VERBrec3 := VERBrec2;
              VERbrec3.modus := omegamodus;

         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec2 := VERBrec3;
              VERBrec2.modus := infinitive;

         >

   SUBRULE
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]>

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            ((SENTENCErec1.conjdeixis = omegadeixis) OR
             (SENTENCErec1.conjdeixis = futuredeixis)
            )
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec3 := VERBrec2;
              VERbrec3.modus := omegamodus;

         >
      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = pastdeixis)
              A12: CLAUSErec1 := CLAUSErec2;
 
          A1: VERBrec2 := VERBrec3;
              VERBrec2.modus := infinitive;

         >
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RinfinpastsuperdeixisA
\item[* relevant examples:] Hij probeerde (graag te kunnen slapen)
                            Hij probeerde (toevallig om 3 uur te kunnen komen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 12-MAR-1990 
\item[* author:] Lisette Appelo
\item[* copied from:] Rinfinpastsuperdeixis
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is before: PAST.
               This rule is for a finite dependent clause.
               The deixis 
value of the possible reference adverbial is checked for 
               omega or future.
               The clause is marked for past superdeixis.
This rule is for cases with {\em graag } and {\em toevallig} and verb clusters.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different categories of the variables for the 
reference adverbials and the not occurrence of a reference adverbial. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] 
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: \\
\end{enumerate}
\end{description}

\newpage
\begin{verbatim}

% RULE RinfinpastsuperdeixisspecA
< m1:CLAUSE{CLAUSErec1}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                I3:[mu3,
                    I7:head/VERB{VERbrec5}
                           [I4:auxrel/VERB{VERBrec3}
                                     [head/SUBVERB{SUBVERBrec1}
                                          [head/T2] 
                                     ],
                           I5:rel1/VERB{VERBrec1}
                                       [I8:rel2/VERB{VERbrec2}[mu4],
                                        mu6
                                       ]
                           ]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                I3:[mu3,
                    I7:head/VERB{VERbrec5}
                           [I6:auxrel/VERB{VERBrec4}
                                     [head/SUBVERB{SUBVERBrec1}
                                          [head/T2] 
                                     ],
                           I5:rel1/VERB{VERBrec1}
                                       [I8:rel2/VERB{VERbrec2}[mu4],
                                        mu6
                                       ]
                            ]
                    ],
             mu5
           ] 

>
   MATCHCONDITIONS
      <
       I1: QUOTE_temprefnotfound(mu1)
       I2: QUOTE_temprefnotfound(mu2)
       I3: RIGHTTOLEFT
       m1: (CLAUSErec1.deixis = omegadeixis) AND
           (CLAUSErec1.aspect = perfective) AND
           (CLAUSErec1.retro = false) AND
           (CLAUSErec1.finiteness = infinite)
       I4: (VERBrec1.tense = omegatense) AND
           (VERbrec1.status = VV) 
       I8: (VERbrec2.tense = omegatense) AND
           (VERbrec2.modus = infinitive) 
       m : (CLAUSErec2.deixis = omegadeixis) AND
           (CLAUSErec2.aspect = perfective) AND
           (CLAUSErec2.retro = false) AND
           (CLAUSErec2.finiteness = infinite) 
       I5: (VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1)) AND
           (VERBrec3 =
                     {
                      number : omeganumber
                      persons : []
                      eORenForm : NoForm
                      modus : infinitive
                      tense : omegatense
                      status : bareV
                     }
            )
              
              (* other values: default values *)
       I6: (VERBrec4 = COPYT_subverbtoverb(SUBVERBrec1)) AND
           (VERBrec4 =
                     {
                      number : omeganumber
                      persons : []
                      eORenForm : NoForm
                      modus : omegamodus
                      tense : omegatense
                      status : bareV
                     }
            )
              
              (* other values: default values *)
       I7: VERBrec5.status = AuxV
      >

<
   SUBRULE (*1: ADVPVAR, hebben*)
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >
      <
       sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            (ADVPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)

             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
         >

   SUBRULE (*2: ADVPVAR, zijn*)
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >
      <
       sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            (ADVPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
         >

   SUBRULE (*3: PREPPVAR, hebben*)
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >
      <
       sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            (PREPPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
         >

   SUBRULE (*4: PREPPVAR, zijn*)
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >
      <
       sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            (PREPPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
         >

   SUBRULE (*5: SENTENCE, hebben*)
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >
      <
       sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            (SENTENCErec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1))
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
         >

   SUBRULE (*6: SENTENCE, zijn*)
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >
      <
       sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            (SENTENCErec1.conjdeixis = omegadeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
         >


>
&
\end{verbatim}

\newpage
\begin{description}
\item[* name:] RinfinpastsuperdeixisspecA
\item[* relevant examples:] hij dacht (toevallig om 3 uur te kunnen zijn gekomen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 12-MAR-1990
\item[* author:] Lisette Appelo
\item[* copied from:]Rinfinpastsuperdeixisspec
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The `indirect' relation between Rs and S is before: PAST.
               This rule is for a finite dependent clause. This
               is a special rule because the auxiliary verb {\em hebben/zijn} 
               expresses the past. 
The auxiliary verb {\em hebben/zijn
} is requiered with a omega tense.
               The deixis 
value of the reference adverbial is checked for 
               omega.
               The clause is marked for past superdeixis.
This rule is for {\em toevallig} or {\em graag} with verb clusters
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different variable categories for the reference 
adverbials and the not occurrence of an adverbial. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial, perfective aspect rule \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language: This rule has the same semantics as 
Rfinpastsuperdeixis2.\\

\item in other languages: This rule corresponds to the rule for dependent
simple past tense in English and preterito in Spanish. \\

\end{enumerate}
\item[* relevant literature/documents:] doc 53, 263, 314.
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: \\

\end{enumerate}
\end{description}

% RULE RfinpastsuperdeixisspecA
< m1:CLAUSE{CLAUSErec1}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                I3:[mu3,
                    I7:head/VERB{VERbrec5}
                           [I4:auxrel/VERB{VERBrec3}
                                     [head/SUBVERB{SUBVERBrec1}
                                          [head/T2] 
                                     ],
                           I5:rel1/VERB{VERBrec1}
                                       [I8:rel2/VERB{VERbrec2}[mu4],
                                        mu6
                                       ]
                           ]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [I1:mu1,
            sig1,
            I2:mu2,
            predrel/VERBP{VERBPrec1}
                I3:[mu3,
                    I7:head/VERB{VERbrec5}
                           [I6:auxrel/VERB{VERBrec4}
                                     [head/SUBVERB{SUBVERBrec1}
                                          [head/T2] 
                                     ],
                           I5:rel1/VERB{VERBrec1}
                                       [I8:rel2/VERB{VERbrec2}[mu4],
                                        mu6
                                       ]
                           ]
                    ],
             mu5
           ] 

>
   MATCHCONDITIONS
      <
       I1: QUOTE_temprefnotfound(mu1)
       I2: QUOTE_temprefnotfound(mu2)
       I3: RIGHTTOLEFT
       m1: (CLAUSErec1.deixis = omegadeixis) AND
           (CLAUSErec1.aspect = perfective) AND
           (CLAUSErec1.retro = false) AND
           (CLAUSErec1.finiteness = finite)
       I4: (VERBrec1.tense = omegatense) AND
           (VERbrec1.status = VV) 
       I8: (VERbrec2.tense = omegatense) AND
           (VERbrec2.modus = infinitive) 
       m : (CLAUSErec2.deixis = omegadeixis) AND
           (CLAUSErec2.aspect = perfective) AND
           (CLAUSErec2.retro = false) AND
           (CLAUSErec2.finiteness = finite) 
       I5: (VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1)) AND
           (VERBrec3 =
                     {
                      number : omeganumber
                      persons : []
                      eORenForm : NoForm
                      modus : infinitive
                      tense : omegatense
                      status : bareV
                     }
            )
              
              (* other values: default values *)
       I6: (VERBrec4 = COPYT_subverbtoverb(SUBVERBrec1)) AND
           (VERBrec4 =
                     {
                      number : omeganumber
                      persons : []
                      eORenForm : NoForm
                      modus : omegamodus
                      tense : pasttense
                      status : bareV
                     }
            )
              
              (* other values: default values *)
       I7: VERBrec5.status = AuxV 
      >

<
   SUBRULE (*1: ADVPVAR, hebben*)
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >
      <
       sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            (ADVPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)

             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
              VERBrec4.tense := pasttense;
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              VERbrec3.tense := omegatense;
         >

   SUBRULE (*2: ADVPVAR, zijn*)
      <sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >
      <
       sig1: [tempadvrel/ADVPVAR{ADVPVARrec1}[ ]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(ADVPVARrec1.class = reference) AND
            (ADVPVARrec1.retro = false) AND
            (ADVPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
              VERBrec4.tense := pasttense;
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              VERbrec3.tense := omegatense;
         >

   SUBRULE (*3: PREPPVAR, hebben*)
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >
      <
       sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            (PREPPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
              VERBrec4.tense := pasttense;
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              VERbrec3.tense := omegatense;
         >

   SUBRULE (*4: PREPPVAR, zijn*)
      <sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >
      <
       sig1: [tempadvrel/PREPPVAR{PREPPVARrec1}[ ]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(PREPPVARrec1.class = reference) AND
            (PREPPVARrec1.retro = false) AND
            (PREPPVARrec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
              VERBrec4.tense := pasttense;
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              VERbrec3.tense := omegatense;
         >

   SUBRULE (*5: SENTENCE, hebben*)
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >
      <
       sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]
       T2: BVERB(KEY_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            (SENTENCErec1.deixis = omegadeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;

          A1: VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
              VERBrec4.tense := pasttense;
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1))
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              VERbrec3.tense := omegatense;
         >

   SUBRULE (*6: SENTENCE, zijn*)
      <sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >
      <
       sig1: [tempadvrel/SENTENCE{SENTENCErec1}[mu9]]
       T2: BVERB(KEY_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       sig1:(SENTENCErec1.conjclass = reference) AND
            (SENTENCErec1.conjretro = false) AND
            (SENTENCErec1.conjdeixis = omegadeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
              VERBrec4.tense := pasttense;
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
 
             C12: (CLAUSErec2.superdeixis = pastdeixis)
             A12: CLAUSErec1 := CLAUSErec2;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              VERbrec3.tense := omegatense;
         >


>
&
\end{verbatim}

\newpage
\begin{description}
\item[* name:] RfinpastsuperdeixisspecA
\item[* relevant examples:] hij dacht (dat hij toevallig om 3 uur te kon
 zijn gekomen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 12-MAR-1990
\item[* author:] Lisette Appelo
\item[* copied from:]RinfinpastsuperdeixisspecA
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The `indirect' relation between Rs and S is before: PAST.
               This rule is for a finite dependent clause. This
               is a special rule because the auxiliary verb {\em hebben/zijn} 
               expresses the past. 
The auxiliary verb {\em hebben/zijn
} is required with a omega tense.
               The deixis 
value of the reference adverbial is checked for 
               omega.
               The clause is marked for past superdeixis.
This rule is for {\em toevallig} or {\em graag} with verb clusters
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different variable categories for the reference 
adverbials and the not occurrence of an adverbial. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial, perfective aspect rule \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language: This rule has the same semantics as 
Rfinpastsuperdeixis2.\\

\item in other languages: This rule corresponds to the rule for dependent
simple past tense in English and preterito in Spanish. \\

\end{enumerate}
\item[* relevant literature/documents:] doc 53, 263, 314.
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: \\

\end{enumerate}
\end{description}



%%
E 2
E 1
