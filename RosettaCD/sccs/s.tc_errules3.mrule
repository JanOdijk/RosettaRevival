h65381
s 02341/00001/00000
d D 1.2 92/02/21 15:47:04 rous 2 1
c 
e
s 00001/00000/00000
d D 1.1 92/02/11 11:49:10 rous 1 0
c date and time created 92/02/11 11:49:10 by rous
e
u
U
f e 0
t
T
I 1
D 2
 
E 2
I 2
DUTCH 85
&
\newpage
\begin{verbatim}
%
% TRANSFORMATION Terxdeletion1
< m1:SENTENCE{SENTENCErec1}
        [ I1:mu1, 
          erposrel/RADVP{RADVPrec1}
                 [head/RADV(KEY_erRADVkey){RADVrec1}],
          I2:mu2 
        ]
>

< m :SENTENCE{SENTENCErec1}
        [ I1:mu1, 
          I2:mu2 
        ]

>


   MATCHCONDITIONS
      <
       I1: ALL(mu1, I11:rel1/..)                      AND
           (EXIST(mu1, [conjrel/CONJ{}])   OR
            EXIST(mu1, [I12:shiftrel/T1])
           )
           I11: QUOTE_Srelprec(rel1, erposrel) AND 
                [rel1] * [subjrel,erqrel,erposrel] = []
           I12: (T1.CAT IN [PREPP] WITH loc IN T1.REC.actsubcefs) OR
                (T1.CAT IN [ADVP] WITH locadv IN T1.REC.actsubcefs)

       I2: ALL(mu2, I21:rel2/..)
           I21: QUOTE_Srelprec(erposrel, rel2) AND 
                [rel2] * [erqrel,erposrel] = []
      >

<
   SUBRULE
      <mu1: [mu3, shiftrel/PREPP{PREPPrec1}[I4:mu4], mu5 ]>
      <mu1: [mu3, shiftrel/PREPP{PREPPrec2}[I4:mu4], mu5 ]>

   MATCHCONDITIONS
      <
       I4: NOT EXIST(mu4, [errel/..])
      >


      DECOMP
         <
          C1: true
          A1:RADVPrec1 :=
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  };
             PREPPrec1 := PREPPrec2;
             PREPPrec1.actsubcefs := [loc];
         >

   SUBRULE
      <mu1: [mu3, shiftrel/ADVP{ADVPrec1}[mu4], mu5 ]>
      <mu1: [mu3, shiftrel/ADVP{ADVPrec2}[mu4], mu5 ]>

      DECOMP
         <
          C1: true
          A1:RADVPrec1 :=
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  };
             ADVPrec1 := ADVPrec2;
             ADVPrec1.actsubcefs := [locadv];
         >


   SUBRULE
      <mu1: [I3:mu3] 
       mu2: [I4:mu4]
      >
      <mu1: [I3:mu3] 
       mu2: [I4:mu4]
      >

   MATCHCONDITIONS
      <
       I3:NOT EXIST(mu3, [shiftrel/..])
       I4: EXIST(mu4, [extraposrel/..])
      >


      DECOMP
         <
          C1: true
          A1: RADVPrec1 :=
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  };
         >

>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Terxdeletion1
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 24-FEB-1989 13:49:51  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% TRANSFORMATION TPPtoerpos1
< m1:CLAUSE{CLAUSErec1}
           [ I1:mu1,
             I2:mu2,
             predrel/VERBP{VERBPrec1}[mu3],
             mu4 
           ]
>

< m :CLAUSE{CLAUSErec2}
           [ I1:mu1,
             I6:erposrel/VARPREPP{VARPREPPrec1}
                     [ errel/RADVP{RADVPrec1}[mu6],
                       mu7 
                     ],
             I2:mu2,
             predrel/VERBP{VERBPrec1}[mu5],
             mu4 
           ]

>

   MATCHCONDITIONS
      <
       I1: ALL(mu1, I11:rel1/..)
           I11: rel1 IN AUX_preerposrels
       I2: ALL(mu2, I21:rel2/..)
           I21: QUOTE_Srelprec(erposrel, rel2) AND rel2 <> erposrel 
       I6: VARPREPPrec1.mood = wh OR EXIST(mu6,[I61:head/T1])
           I61: (T1.CAT IN [NPVAR] WITH T1.REC.mood 
                    IN [topicxpmood,relativexpmood, wh]) OR
                (T1.CAT IN [CNVAR])
      >

<
   SUBRULE
      <mu3: [ I8:mu8, 
              I7:prepobjrel/VARPREPP{VARPREPPrec1}
                     [ errel/RADVP{RADVPrec1}[mu6],
                       mu7 
                     ],
              I9:mu9
            ]
      >
      <mu5: [I8:mu8,I9:mu9] >

   MATCHCONDITIONS
      <
       I7:VARPREPPrec1.mood = wh OR EXIST(mu6,[I61:head/T1])
           I61: (T1.CAT IN [NPVAR] WITH T1.REC.mood 
                  IN [topicxpmood, relativexpmood, wh]) OR
                (T1.CAT IN [CNVAR])
      I8: ALL(mu8, I81:rel8/..)
          I81: QUOTE_VPrelprec(rel8, prepobjrel) AND 
               [rel8] * [prepobjrel, locargrel, predrel, dirargrel] =[]
      I9: ALL(mu9, I91:rel9/..)
          I91: QUOTE_VPrelprec(prepobjrel, rel9) AND 
               [rel9] * [prepobjrel, locargrel, predrel, dirargrel] =[]
      >


      DECOMP
         <
          C1: CLAUSErec2.synvpefs * AUX_prepobjvps <> []
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * AUX_prepobjvps
         >

   SUBRULE (* locargrel *)
      <mu3: [ I8:mu8, 
              I7:locargrel/VARPREPP{VARPREPPrec1}
                     [ errel/RADVP{RADVPrec1}[mu6],
                       mu7 
                     ],
              I9:mu9
            ]
      >
      <mu5: [I8:mu8,I9:mu9] >

   MATCHCONDITIONS
      <
       I7:VARPREPPrec1.mood = wh OR EXIST(mu6,[I61:head/T1])
           I61: (T1.CAT IN [NPVAR] WITH T1.REC.mood 
                  IN [topicxpmood, relativexpmood, wh]) OR
                (T1.CAT IN [CNVAR])
      I8: ALL(mu8, I81:rel8/..)
          I81: QUOTE_VPrelprec(rel8, locargrel) AND 
               [rel8] * [prepobjrel, locargrel, predrel, dirargrel] =[]
      I9: ALL(mu9, I91:rel9/..)
          I91: QUOTE_VPrelprec(locargrel, rel9) AND 
               [rel9] * [prepobjrel, locargrel, predrel, dirargrel] =[]
      >


      DECOMP
         <
          C11: CLAUSErec2.synvpefs * AUX_locargvps <> []
          A11: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * AUX_locargvps
          C12: CLAUSErec2.adjuncts * [locadjunct] <> []
          A12: CLAUSErec1 := CLAUSErec2;
         >


>

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] TPPtoerpos1
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 24-FEB-1989 15:52:56  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% TRANSFORMATION Tertoerpos1
< m1:CLAUSE{CLAUSErec1}
           [ I1:mu1,
             I2:sig1,
             I3:mu2,
             predrel/VERBP{VERBPrec1}
                    [ mu3,
                      I4:rel1/T3,
                       I6:sig2,
                       head/T2,
                       mu6
                    ] ,
             mu7
           ]
>

< m :CLAUSE{CLAUSErec1}
           [ I1:mu1,
             I5:sig3,
             I3:mu2,
             predrel/VERBP{VERBPrec1}
                    [ mu3,
                      I4:rel1/I7::PREPP{PREPPrec2}
                             [ mu4,
                               head/T1,
                               mu8
                             ],
                       I6:sig2,
                       head/T2,
                       mu6
                    ] ,
             mu7
           ]

>


   MATCHCONDITIONS
      <
       I1: ALL(mu1, I11:rel2/..) 
           I11: QUOTE_Srelprec(rel2, erposrel) AND rel2 <> erposrel
       I2: ALL(sig1, erposrel/..)
       I3: ALL(mu2, I21:rel3/..) 
           I21: QUOTE_Srelprec(erposrel, rel3) AND rel3 <> erposrel
       I4: rel1 IN [prepobjrel, locargrel, dirargrel]
       I5: ALL(sig3, erposrel/..)
       I6: ALL(sig2, strandedrel/..)
       I7: PREPPrec2.stranded = true
      >

<
   SUBRULE
      <sig1: []
       T3: VARPREPP{VARPREPPrec1}
                             [ mu4,
                               errel/RADVP{RADVPrec1}[I8:mu5],
                               head/T1,
                               mu8
                             ] 
      >
      <sig3: [erposrel/RADVP{RADVPrec2}[I8:mu5]]>

   MATCHCONDITIONS
      <
       I8: EXIST(mu5,[I81:../T4])
           I81: T4.CAT IN AUX_VARCATSET
      >


      COMP
         <
          C1: Pk IN RADVPrec1.kindefs AND
              VARPREPPrec1.stranded = false AND
              QUOTE_Cpspecq(VARPREPPrec1.specq, mu5)
              C11: EXIST(mu5,[../CNVAR{}]) AND
                   VARPREPPrec1.mood = relativexpmood
              A11: PREPPrec2 := VARPREPPrec1;
                   PREPPrec2.stranded := true;
                   PREPPrec2.mood := declxpmood;
                   PREPPrec2.specq := nospec;
              C12: NOT EXIST(mu5,[../CNVAR{}]) AND
                   VARPREPPrec1.mood = RADVPrec1.mood
              A12: PREPPrec2 := VARPREPPrec1;
                   PREPPrec2.stranded := true;
                   PREPPrec2.mood := declxpmood;
                   PREPPrec2.specq := nospec;
          A1: RADVPrec2 := RADVPrec1; 
         >
      DECOMP
         <
          C1: Pk IN RADVPrec2.kindefs 
              C11: EXIST(mu5,[../CNVAR{}]) AND
                   PREPPrec2.stranded = true AND
                   PREPPrec2.mood = declxpmood AND
                   PREPPrec2.specq = nospec
              A11: VARPREPPrec1 := PREPPrec2;
                   VARPREPPrec1.mood := relativexpmood;
              C12: NOT EXIST(mu5,[../CNVAR{}]) AND
                   PREPPrec2.stranded = true AND
                   PREPPrec2.mood = declxpmood AND
                   PREPPrec2.specq = nospec
              A12: VARPREPPrec1 := PREPPrec2;
                   VARPREPPrec1.mood := RADVPrec2.mood;
          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              VARPREPPrec1.stranded := false;
              QUOTE_assSpecq(VARPREPPrec1.specq, mu5);
         >


   SUBRULE
      <sig1: [erposrel/RADVP{RADVPrec3}[head/RADV(KEY_erRADVkey){RADVrec1} ]] 
       T3: VARPREPP{VARPREPPrec1}
                             [ mu4,
                               errel/RADVP{RADVPrec1}[I8:mu5],
                               head/T1,
                               mu8
                             ] 
      >
      <sig3: [erposrel/RADVP{RADVPrec2}[mu5]]>

   MATCHCONDITIONS
      <
       I8: EXIST(mu5,[I81:../T4])
           I81: T4.CAT IN AUX_VARCATSET
      >

      COMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              Pk IN RADVPrec1.kindefs AND
              VARPREPPrec1.stranded = false AND
              RADVPrec3 = 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  } AND
              QUOTE_Cpspecq(VARPREPPrec1.specq, mu5)
              C11: EXIST(mu5,[../CNVAR{}]) AND
                   VARPREPPrec1.mood = relativexpmood
              A11: PREPPrec2 := VARPREPPrec1;
                   PREPPrec2.stranded := true;
                   PREPPrec2.mood := declxpmood;
                   PREPPrec2.specq := nospec;
              C12: NOT EXIST(mu5,[../CNVAR{}]) AND
                   VARPREPPrec1.mood = RADVPrec1.mood
              A12: PREPPrec2 := VARPREPPrec1;
                   PREPPrec2.stranded := true;
                   PREPPrec2.mood := declxpmood;
                   PREPPrec2.specq := nospec;
          A1: RADVPrec2 := RADVPrec1; 
              RADVPrec2.kindefs := [XPk];
         >
      DECOMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              XPk IN RADVPrec2.kindefs 
              C11: EXIST(mu5,[../CNVAR{}]) AND
                   PREPPrec2.stranded = true AND
                   PREPPrec2.mood = declxpmood AND
                   PREPPrec2.specq = nospec
              A11: VARPREPPrec1 := PREPPrec2;
                   VARPREPPrec1.mood := relativexpmood;
              C12: NOT EXIST(mu5,[../CNVAR{}]) AND
                   PREPPrec2.stranded = true AND
                   PREPPrec2.mood = declxpmood AND
                   PREPPrec2.specq = nospec
              A12: VARPREPPrec1 := PREPPrec2;
                   VARPREPPrec1.mood := RADVPrec2.mood;
          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              VARPREPPrec1.stranded := false;
              RADVPrec3 := 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  };
              QUOTE_assSpecq(VARPREPPrec1.specq, mu5);
         >

   SUBRULE
      <sig1: []
       T3: PREPP{PREPPrec1}
                             [ mu4,
                               errel/RADVP{RADVPrec1}[I8:mu5],
                               head/T1,
                               mu8
                             ] 
      >
      <sig3: [erposrel/RADVP{RADVPrec2}[I8:mu5]]>

   MATCHCONDITIONS
      <
       I8: NOT EXIST(mu5,[I81:../T4])
           I81: T4.CAT IN AUX_VARCATSET
      >


      COMP
         <
          C1: Pk IN RADVPrec1.kindefs AND
              PREPPrec1.stranded = false  AND
              PREPPrec1.mood = RADVPrec1.mood AND
              QUOTE_Cpspecq(PREPPrec1.specq, mu5)
          A1: RADVPrec2 := RADVPrec1; 
              PREPPrec2 := PREPPrec1;
              PREPPrec2.stranded := true;
              PREPPrec2.mood := declxpmood;
              PREPPrec2.specq := nospec;
         >
      DECOMP
         <
          C1: Pk IN RADVPrec2.kindefs AND
              PREPPrec2.stranded = true AND
              PREPPrec2.mood = declxpmood AND
              PREPPrec2.specq = nospec
          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              PREPPrec1 := PREPPrec2;
              PREPPrec1.stranded := false;
              PREPPrec1.mood := RADVPrec2.mood;
              QUOTE_assSpecq(PREPPrec1.specq, mu5);
         >


   SUBRULE
      <sig1: [erposrel/RADVP{RADVPrec3}[head/RADV(KEY_erRADVkey){RADVrec1} ]] 
       T3: PREPP{PREPPrec1}
                             [ mu4,
                               errel/RADVP{RADVPrec1}[I8:mu5],
                               head/T1,
                               mu8
                             ] 
      >
      <sig3: [erposrel/RADVP{RADVPrec2}[mu5]]>

   MATCHCONDITIONS
      <
       I8: NOT EXIST(mu5,[I81:../T4])
           I81: T4.CAT IN AUX_VARCATSET
      >

      COMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              Pk IN RADVPrec1.kindefs AND
              PREPPrec1.stranded = false AND
              RADVPrec3 = 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  }  AND
              PREPPrec1.mood = RADVPrec1.mood AND
              QUOTE_Cpspecq(PREPPrec1.specq, mu5)
          A1: RADVPrec2 := RADVPrec1; 
              RADVPrec2.kindefs := [XPk];
              PREPPrec2 := PREPPrec1;
              PREPPrec2.stranded := true;
              PREPPrec2.mood := declxpmood;
              PREPPrec2.specq := nospec;
         >
      DECOMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              XPk IN RADVPrec2.kindefs AND
              PREPPrec2.stranded = true AND
              PREPPrec2.mood = declxpmood AND
              PREPPrec2.specq = nospec
          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              PREPPrec1 := PREPPrec2;
              PREPPrec1.stranded := false;
              PREPPrec1.mood := RADVPrec2.mood;
              RADVPrec3 := 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  };
              QUOTE_assSpecq(PREPPrec1.specq, mu5);
         >
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Tertoerpos1
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 27-MAY-1988 10:10:17  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% FILTER Fertoerpos12
< m :CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu3,
                      I4:rel1/N1
                             [ mu4,
                               errel/RADVP{RADVPrec1}[mu5],
                               head/T1,
                               mu8
                             ],
                       mu6
                    ] ,
             mu7
           ]
>



   MATCHCONDITIONS
      <
       I4: rel1 IN [prepobjrel, locargrel, dirargrel, aanobjrel, voorobjrel,
                    byobjrel, vpadvrel ] AND 
           N1.CAT IN [VARPREPP, PREPP]
      >

         <
          C1: true
          A1: @
         >

  
&
\end{verbatim}
  \newpage
\begin{description}
\item[* name:] Fertoerpos1
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 7-JUL-1988 10:02:23  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}



\newpage
\begin{verbatim}
% TRANSFORMATION Tertoerpos2
< m1:CLAUSE{CLAUSErec1}
           [ I1:mu1,
             I2:sig1,
             I3:mu2,
             predrel/VERBP{VERBPrec1}
                      [ mu3,
                        head/T2,
                        mu6
                      ] ,
             mu7
           ]
>

< m :CLAUSE{CLAUSErec2}
           [ I1:mu1,
             I5:sig3,
             I3:mu2,
             predrel/VERBP{VERBPrec1}
                    [ mu3,
                      head/T2,
                      mu6
                    ] ,
             mu7
           ]

>


   MATCHCONDITIONS
      <
       I1: ALL(mu1, I11:rel2/..) 
           I11: QUOTE_Srelprec(rel2, erposrel) AND rel2 <> erposrel
       I2: ALL(sig1, erposrel/..)
       I3: ALL(mu2, I21:rel3/..) 
           I21: QUOTE_Srelprec(erposrel, rel3) AND rel3 <> erposrel
       I5: ALL(sig3, erposrel/..)
      >

< (* begin subrules *)

   SUBRULE (* aanobjrel *)
      <mu3: [ I6:mu8, aanobjrel/VARPREPP{VARPREPPrec1}
                             [ errel/RADVP{RADVPrec1}[mu5],
                               head/PREP(KEY_aanioPREPkey){PREPrec1}
                             ],
              I7:mu9
            ]
      >
      <mu3: [I6:mu8, I7:mu9, strandedrel/PREP(KEY_aanioPREPkey){PREPrec1}]
      >

   MATCHCONDITIONS
      <
       I6: ALL(mu8, I61:rel8/..)
           I61: QUOTE_VPrelprec(rel8, aanobjrel) AND 
                [rel8] * [aanobjrel, voorobjrel, indobjrel] =[]
       I7: ALL(mu9, I71:rel9/..)
           I71: QUOTE_VPrelprec(aanobjrel, rel9) AND 
                [rel9] * [aanobjrel, voorobjrel, indobjrel] = []
      >

< (* begin aanobjrel subrules *)
   SUBRULE (* aanobjrel, no erx *)
      <sig1: [] >
      <sig3: [erposrel/RADVP{RADVPrec2}[mu5]]>

      COMP
         <
          C1: CLAUSErec1.synvpefs * AUX_aanobjvps <> [] AND
              Pk IN RADVPrec1.kindefs AND
              VARPREPPrec1 = AUX_PREPPonaanio  
          A1: CLAUSErec2 := CLAUSErec1;
              RADVPrec2 := RADVPrec1; 
         >
      DECOMP
         <
          C1: CLAUSErec2.synvpefs * AUX_aanobjvps <> [] AND
              Pk IN RADVPrec2.kindefs 
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * AUX_aanobjvps ;
              RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              VARPREPPrec1 := AUX_PREPPonaanio;
         >


   SUBRULE (* aanobjrel, erx *)
      <sig1: [erposrel/RADVP{RADVPrec3}[head/RADV(KEY_erRADVkey){RADVrec1} ]] >
      <sig3: [erposrel/RADVP{RADVPrec2}[mu5]]>

      COMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              CLAUSErec1.synvpefs * AUX_aanobjvps <> [] AND
              Pk IN RADVPrec1.kindefs AND
              VARPREPPrec1 = AUX_PREPPonaanio  AND
              RADVPrec3 = 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  }
          A1: CLAUSErec2 := CLAUSErec1;
              RADVPrec2 := RADVPrec1; 
              RADVPrec2.kindefs := [XPk];
         >
      DECOMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              XPk IN RADVPrec2.kindefs AND
              CLAUSErec2.synvpefs * AUX_aanobjvps <> [] 
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * AUX_aanobjvps ;
              RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              VARPREPPrec1 := AUX_PREPPONaanio;
              RADVPrec3 := 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  }
         >
> (* end aanobjrel subrules *)

   SUBRULE (* voorobjrel *)
      <mu3: [ I6:mu8, voorobjrel/VARPREPP{VARPREPPrec1}
                             [ errel/RADVP{RADVPrec1}[mu5],
                               head/PREP(KEY_voorioPREPkey){PREPrec1}
                             ],
              I7:mu9
            ]
      >
      <mu3: [I6:mu8, I7:mu9, strandedrel/PREP(KEY_voorioPREPkey){PREPrec1}]
      >

   MATCHCONDITIONS
      <
       I6: ALL(mu8, I61:rel8/..)
           I61: QUOTE_VPrelprec(rel8, voorobjrel) AND 
                [rel8] * [aanobjrel, voorobjrel, indobjrel] =[]
       I7: ALL(mu9, I71:rel9/..)
           I71: QUOTE_VPrelprec(voorobjrel, rel9) AND 
                [rel9] * [aanobjrel, voorobjrel, indobjrel] = []
      >

< (* begin voorobjrel subrules *)
   SUBRULE (* voorobjrel, no erx *)
      <sig1: [] >
      <sig3: [erposrel/RADVP{RADVPrec2}[mu5]]>

      COMP
         <
          C1: CLAUSErec1.synvpefs * AUX_voorobjvps <> [] AND
              Pk IN RADVPrec1.kindefs AND
              VARPREPPrec1 = AUX_PREPPonvoorio  
          A1: CLAUSErec2 := CLAUSErec1;
              RADVPrec2 := RADVPrec1; 
         >
      DECOMP
         <
          C1: CLAUSErec2.synvpefs * AUX_voorobjvps <> [] AND
              Pk IN RADVPrec2.kindefs 
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * AUX_voorobjvps ;
              RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              VARPREPPrec1 := AUX_PREPPonvoorio;
         >


   SUBRULE (* voorobjrel, erx *)
      <sig1: [erposrel/RADVP{RADVPrec3}[head/RADV(KEY_erRADVkey){RADVrec1} ]] >
      <sig3: [erposrel/RADVP{RADVPrec2}[mu5]]>

      COMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              CLAUSErec1.synvpefs * AUX_voorobjvps <> [] AND
              Pk IN RADVPrec1.kindefs AND
              VARPREPPrec1 = AUX_PREPPonvoorio  AND
              RADVPrec3 = 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  }
          A1: CLAUSErec2 := CLAUSErec1;
              RADVPrec2 := RADVPrec1; 
              RADVPrec2.kindefs := [XPk];
         >
      DECOMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              XPk IN RADVPrec2.kindefs AND
              CLAUSErec2.synvpefs * AUX_voorobjvps <> [] 
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * AUX_voorobjvps ;
              RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              VARPREPPrec1 := AUX_PREPPONvoorio;
              RADVPrec3 := 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  }
         >
> (* end voorobjrel subrules *)

   SUBRULE (* byobjrel *)
      <mu3: [ I6:mu8, byobjrel/VARPREPP{VARPREPPrec1}
                             [ errel/RADVP{RADVPrec1}[mu5],
                               head/PREP(KEY_doorbyPREPkey){PREPrec1}
                             ],
              I7:mu9
            ]
      >
      <mu3: [I6:mu8, I7:mu9, strandedrel/PREP(KEY_doorbyPREPkey){PREPrec1}]
      >

   MATCHCONDITIONS
      <
       I6: ALL(mu8, I61:rel8/..)
           I61: QUOTE_VPrelprec(rel8, byobjrel) AND 
                [rel8] * [byobjrel] =[]
       I7: ALL(mu9, I71:rel9/..)
           I71: QUOTE_VPrelprec(byobjrel, rel9) AND 
                [rel9] * [byobjrel] = []
      >

< (* begin byobjrel subrules *)
   SUBRULE (* byobjrel, no erx *)
      <sig1: [] >
      <sig3: [erposrel/RADVP{RADVPrec2}[mu5]]>

      COMP
         <
          C1: CLAUSErec1.voice IN [Passive, DoorActive] AND
              Pk IN RADVPrec1.kindefs AND
              VARPREPPrec1 = AUX_PREPPondoorby
          A1: CLAUSErec2 := CLAUSErec1;
              RADVPrec2 := RADVPrec1; 
         >
      DECOMP
         <
          C1: CLAUSErec2.voice IN [Passive, DoorActive] AND
              Pk IN RADVPrec2.kindefs 
          A1: CLAUSErec1 := CLAUSErec2;
              RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              VARPREPPrec1 := AUX_PREPPondoorby;
         >


   SUBRULE (* byobjrel, erx *)
      <sig1: [erposrel/RADVP{RADVPrec3}[head/RADV(KEY_erRADVkey){RADVrec1} ]] >
      <sig3: [erposrel/RADVP{RADVPrec2}[mu5]]>

      COMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              CLAUSErec1.voice IN [Passive]  AND
              Pk IN RADVPrec1.kindefs AND
              VARPREPPrec1 = AUX_PREPPondoorby  AND
              RADVPrec3 = 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  }
          A1: CLAUSErec2 := CLAUSErec1;
              RADVPrec2 := RADVPrec1; 
              RADVPrec2.kindefs := [XPk];
         >
      DECOMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              XPk IN RADVPrec2.kindefs AND
              CLAUSErec2.voice IN [Passive] 
          A1: CLAUSErec1 := CLAUSErec2;
              RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              VARPREPPrec1 := AUX_PREPPONdoorby;
              RADVPrec3 := 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  }
         >
> (* end byobjrel subrules *)

   SUBRULE (* vpadvrel *)
      <mu3: [ I6:mu8, vpadvrel/VARPREPP{VARPREPPrec1}
                             [ errel/RADVP{RADVPrec1}[mu5],
                               head/PREP(KEY_meePREPkey){PREPrec1}
                             ],
              I7:mu9
            ]
      >
      <mu3: [I6:mu8, I7:mu9, strandedrel/PREP(KEY_meePREPkey){PREPrec1}]
      >

   MATCHCONDITIONS
      <
       I6: ALL(mu8, I61:rel8/..)
           I61: QUOTE_VPrelprec(rel8, vpadvrel) 
       I7: ALL(mu9, I71:rel9/..)
           I71: QUOTE_VPrelprec(vpadvrel, rel9)
      >

< (* begin vpadvrel subrules *)
   SUBRULE (* vpadvrel, no erx *)
      <sig1: [] >
      <sig3: [erposrel/RADVP{RADVPrec2}[mu5]]>

      COMP
         <
          C1: Pk IN RADVPrec1.kindefs AND
              VARPREPPrec1 = AUX_PREPPonmee
          A1: CLAUSErec2 := CLAUSErec1;
              RADVPrec2 := RADVPrec1; 
         >
      DECOMP
         <
          C1: Pk IN RADVPrec2.kindefs 
          A1: CLAUSErec1 := CLAUSErec2;
              RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              VARPREPPrec1 := AUX_PREPPonmee;
         >


   SUBRULE (* vpadvrel, erx *)
      <sig1: [erposrel/RADVP{RADVPrec3}[head/RADV(KEY_erRADVkey){RADVrec1} ]] >
      <sig3: [erposrel/RADVP{RADVPrec2}[mu5]]>

      COMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              Pk IN RADVPrec1.kindefs AND
              VARPREPPrec1 = AUX_PREPPonmee  AND
              RADVPrec3 = 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  }
          A1: CLAUSErec2 := CLAUSErec1;
              RADVPrec2 := RADVPrec1; 
              RADVPrec2.kindefs := [XPk];
         >
      DECOMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              XPk IN RADVPrec2.kindefs 
          A1: CLAUSErec1 := CLAUSErec2;
              RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              VARPREPPrec1 := AUX_PREPPONmee;
              RADVPrec3 := 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  }
         >

> (* end vpadvrel subrules *)
> (* end subrules *)
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Tertoerpos2
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 27-MAY-1988 10:37:22  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% FILTER PFpreertoerpos
< m :CLAUSE{CLAUSErec1}[mu1, erposrel/RADVP{RADVPrec1}[mu2], mu3]
>
  
         <
          C1: RADVPrec1.kindefs - [Pk, XPk, QPk, XPQk] = [] AND
              CLAUSErec1.synvpefs * AUX_VRvps = []
          A1: @
         >

&
\end{verbatim}
  \newpage
\begin{description}
\item[* name:] Fpreertoerpos
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 7-JUL-1988 10:30:29  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% TRANSFORMATION Tadjhettoer1
< m1:I3::CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu5,
                      predrel/ADJP{ADJPrec1}
                         [ mu7, 
                           I1:rel1/T1,
                           mu9
                         ],
                      mu4
                    ],
              mu6
           ]
>

< m :I3::CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu5, 
                      predrel/ADJP{ADJPrec1}
                         [ mu7, 
                           I2:rel1/T2,
                           mu9
                         ],
                      mu4
                    ],
              mu6
           ]
>

   MATCHCONDITIONS
      <
       I1: rel1 IN [locargrel, prepobjrel, dirargrel, predrel, aanobjrel,
                    voorobjrel, paprepobjrel]
       I2: rel1 IN [locargrel, prepobjrel, dirargrel, predrel, aanobjrel,
                    voorobjrel, paprepobjrel]
           AND QUOTE_errelinpp(T2)  
       I3: synzijn IN CLAUSErec1.synvpefs
      >

<
   SUBRULE
      <T1: VARPREPP{VARPREPPrec1}
                             [ mu2,
                               head/PREP{PREPrec1},
                               objrel/NPVAR{NPVARrec1},
                               mu3 
                              ]
      >
      <T2: VARPREPP{VARPREPPrec2}
                             [ mu2,
                               errel/RADVP{RADVPrec1}[ head/NPVAR{NPVARrec2}],
                               head/PREP{PREPrec1},
                               mu3 
                              ]
      >

      COMP
         <
          C1: PREPrec1.postform = both AND
              NPVARrec1.possRform = true AND
              NPVARrec1.cases = [Accusative] 
          A1: RADVPrec1.mood := NPVARrec1.mood;
              RADVPrec1.req := NPVARrec1.req;
              RADVPrec1.env := NPVARrec1.env;
              RADVPrec1.kindefs := [Pk];
              NPVARrec2 := NPVARrec1;
              NPVARrec2.cases := [Rcase];
              VARPREPPrec2 := VARPREPPrec1;
         >
      DECOMP
         <
          C1: PREPrec1.postform = both AND
              NPVARrec2.possRform = true AND
              Rcase IN NPVARrec2.cases AND
              RADVPrec1.mood = NPVARrec2.mood AND
              RADVPrec1.req = NPVARrec2.req AND
              RADVPrec1.env = NPVARrec2.env AND
              Pk IN RADVPrec1.kindefs 
          A1: NPVARrec1 := NPVARrec2;
              NPVARrec1.cases := [Accusative];
              VARPREPPrec1 := VARPREPPrec2;
         >

   SUBRULE
         <T1: VARPREPP{VARPREPPrec1}
                             [ mu2,
                               head/PREP{PREPrec1},
                               objrel/CNVAR{CNVARrec1},
                               mu3 
                              ]
      >
      <T2: VARPREPP{VARPREPPrec2}
                             [ mu2,
                               errel/RADVP{RADVPrec1}[ head/CNVAR{CNVARrec2}],
                               head/PREP{PREPrec1},
                               mu3 
                             ]
      >


      COMP
         <
          C1: PREPrec1.postform = both AND
              CNVARrec1.cases = [Accusative] AND
              CNVARrec1.human = nohuman
          A1: RADVPrec1.mood := declxpmood;
              RADVPrec1.req := [pospol, negpol, omegapol];
              RADVPrec1.env := [pospol, negpol, omegapol];
              RADVPrec1.kindefs := [Pk];
              RADVPrec1.radvkey := 0;
              CNVARrec2 := CNVARrec1;
              CNVARrec2.cases := [Rcase];
              VARPREPPrec2 := VARPREPPrec1;
         >
      DECOMP
         <
          C1: PREPrec1.postform = both AND
              Rcase IN CNVARrec2.cases AND
(* intentionally no check on humanness of CNVAR in analysis *) 
              RADVPrec1 =
               {
                 mood       : declxpmood
                 req        : [pospol, negpol, omegapol]
                 env        : [pospol, negpol, omegapol]
                 kindefs    NI Pk
                 radvkey    : 0
               }
          A1: CNVARrec1 := CNVARrec2;
              CNVARrec1.cases := [Accusative];
              VARPREPPrec1 := VARPREPPrec2;

         >

   SUBRULE (* NP *)
      <T1: PREPP{PREPPrec1}
                             [ mu2,
                               head/PREP{PREPrec1},
                               objrel/NP{NPrec1}[mu8],
                               mu3 
                              ]
      >
      <T2: PREPP{PREPPrec2}
                             [ mu2,
                               errel/RADVP{RADVPrec1}[ head/NP{NPrec2}[mu10]],
                               head/PREP{PREPrec1},
                               mu3 
                              ]
      >

      COMP
         <
          C1: PREPrec1.postform = both AND
              NPrec1.cases  = [Accusative] AND
              NPrec1.possRform = true 
          A1: RADVPrec1 := 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : NPrec1.mood
		  kindefs : [Pk]
		  radvkey : 0
		  };
              QUOTE_Assigncase(NPrec1, mu8, NPrec2, mu10, [Rcase]);
              PREPPrec2 := PREPPrec1;

         >
      DECOMP
         <
          C1: PREPrec1.postform = both AND
              Rcase IN NPrec2.cases AND
              NPrec2.possRform =true AND
              RADVPrec1 = 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : NPrec2.mood
		  kindefs NI Pk
		  radvkey : 0
		  } 
          A1: 
              QUOTE_Assigncase(NPrec2, mu10, NPrec1, mu8, [accusative]);
              PREPPrec1 := PREPPrec2;
         >

>




&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Tadjhettoer1
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 3-MAR-1989 16:36:22  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% TRANSFORMATION Tadjhettoer2
< m1:I3::CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu5, 
                      predrel/ADJP{ADJPrec1}
                         [ mu7, 
                           I1:rel1/T1,
                           mu9
                         ],
                      mu4
                    ],
              mu6
           ]
>

< m :I3::CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu5, 
                      predrel/ADJP{ADJPrec1}
                         [ mu7, 
                           I2:rel1/T2,
                           mu9
                         ],
                      mu4
                    ],
              mu6
           ]
>

   MATCHCONDITIONS
      <
       I1: rel1 IN [locargrel, prepobjrel, dirargrel, predrel, aanobjrel,
                    voorobjrel, paprepobjrel]
       I2: rel1 IN [locargrel, prepobjrel, dirargrel, predrel, aanobjrel,
                    voorobjrel, paprepobjrel]
           AND QUOTE_errelinpp(T2)
       I3: synzijn IN CLAUSErec1.synvpefs  
      >


<
   SUBRULE
      <T1: VARPREPP{VARPREPPrec1}
                             [ mu2,
                               head/PREP(KEY1){PREPrec1},
                               objrel/NPVAR{NPVARrec1},
                               mu3 
                              ]
      >
      <T2: VARPREPP{VARPREPPrec2}
                             [ mu2,
                               errel/RADVP{RADVPrec1}[ head/NPVAR{NPVARrec2}],
                               head/PREP(KEY2){PREPrec2},
                               mu3 
                              ]
     >

      COMP
         <
          C1: NPVARrec1.possRform = true AND
              NPVARrec1.cases = [Accusative]
              C11: KEY1 = KEY_metPREPkey  AND
                   VARPREPPrec1.headkey = KEY_metPREPkey
              A11: KEY2 := KEY_meePREPkey;
                   VARPREPPrec2 := VARPREPPrec1;
                   VARPREPPrec2.headkey := KEY_meePREPkey;
              C12: KEY1 = KEY_totPREPkey   AND
                   VARPREPPrec1.headkey = KEY_totPREPkey
              A12: KEY2 := KEY_toePREPkey;
                   VARPREPPrec2 := VARPREPPrec1;
                   VARPREPPrec2.headkey := KEY_toePREPkey;
          A1: RADVPrec1.mood := NPVARrec1.mood;
              RADVPrec1.req := NPVARrec1.req;
              RADVPrec1.env := NPVARrec1.env;
              RADVPrec1.kindefs := [Pk];
              NPVARrec2 := NPVARrec1;
              NPVARrec2.cases := [Rcase];
         >
      DECOMP
         <
          C1: NPVARrec2.possRform = true AND
              Rcase IN NPVARrec2.cases AND
              RADVPrec1.mood = NPVARrec2.mood AND
              RADVPrec1.req = NPVARrec2.req AND
              RADVPrec1.env = NPVARrec2.env AND
              Pk IN RADVPrec1.kindefs 
              C11: KEY2 = KEY_meePREPkey AND
                   VARPREPPrec2.headkey = KEY_meePREPkey  
              A11: KEY1 := KEY_metPREPkey;
                   VARPREPPrec1 := VARPREPPrec2;
                   VARPREPPrec1.headkey := KEY_metPREPkey;
              C12: KEY2 = KEY_toePREPkey AND
                   VARPREPPrec2.headkey = KEY_toePREPkey
              A12: KEY1 := KEY_totPREPkey;
                   VARPREPPrec1 := VARPREPPrec2;
                   VARPREPPrec1.headkey := KEY_totPREPkey;
          A1: NPVARrec1 := NPVARrec2;
              NPVARrec1.cases := [Accusative];
         >

   SUBRULE
         <T1: VARPREPP{VARPREPPrec1}
                             [ mu2,
                               head/PREP(KEY1){PREPrec1},
                               objrel/CNVAR{CNVARrec1},
                               mu3 
                              ]
      >
      <T2: VARPREPP{VARPREPPrec2}
                             [ mu2,
                               errel/RADVP{RADVPrec1}[ head/CNVAR{CNVARrec2}],
                               head/PREP(KEY2){PREPrec2},
                               mu3 
                              ]
     >


      COMP
         <
          C1: CNVARrec1.cases = [Accusative] AND
              CNVARrec1.human = nohuman
              C11: KEY1 = KEY_metPREPkey   AND
                   VARPREPPrec1.headkey = KEY_metPREPkey
              A11: KEY2 := KEY_meePREPkey; 
                   VARPREPPrec2 := VARPREPPrec1;
                   VARPREPPrec2.headkey := KEY_meePREPkey;
              C12: KEY1 = KEY_totPREPkey    AND
                   VARPREPPrec1.headkey = KEY_totPREPkey
              A12: KEY2 := KEY_toePREPkey;
                   VARPREPPrec2 := VARPREPPrec1;
                   VARPREPPrec2.headkey := KEY_toePREPkey;
          A1: RADVPrec1.mood := declxpmood;
              RADVPrec1.req := [pospol, negpol, omegapol];
              RADVPrec1.env := [pospol, negpol, omegapol];
              RADVPrec1.kindefs := [Pk];
              RADVPrec1.radvkey := 0;
              CNVARrec2 := CNVARrec1;
              CNVARrec2.cases := [Rcase];

         >
      DECOMP
         <
          C1: Rcase IN CNVARrec2.cases AND
(* intentionally no check on human in analysis *)
              RADVPrec1 =
               {
                 mood       : declxpmood
                 req        : [pospol, negpol, omegapol]
                 env        : [pospol, negpol, omegapol]
                 kindefs    NI Pk
                 radvkey    : 0
               } 
              C11: KEY2 = KEY_meePREPkey AND
                   VARPREPPrec2.headkey = KEY_meePREPkey
              A11: KEY1 := KEY_metPREPkey;
                   VARPREPPrec1 := VARPREPPrec2;
                   VARPREPPrec1.headkey := KEY_metPREPkey;
              C12: KEY2 = KEY_toePREPkey  AND
                   VARPREPPrec2.headkey = KEY_toePREPkey
              A12: KEY1 := KEY_totPREPkey;
                   VARPREPPrec1 := VARPREPPrec2;
                   VARPREPPrec1.headkey := KEY_totPREPkey;
          A1: CNVARrec1 := CNVARrec2;
              CNVARrec1.cases := [Accusative];
         >

   SUBRULE (* NP *)
      <T1: PREPP{PREPPrec1}
                             [ mu2,
                               head/PREP(KEY1){PREPrec1},
                               objrel/NP{NPrec1}[mu8],
                               mu3 
                              ]
      >
      <T2: PREPP{PREPPrec2}
                             [ mu2,
                               errel/RADVP{RADVPrec1}[ head/NP{NPrec2}[mu10]],
                               head/PREP(KEY2){PREPrec2},
                               mu3 
                              ]
     >

      COMP
         <
          C1: NPrec1.cases  = [Accusative] AND
              NPrec1.possRform = true 
              C11: KEY1 = KEY_metPREPkey   AND
                   PREPPrec1.headkey = KEY_metPREPkey
              A11: KEY2 := KEY_meePREPkey;
                   PREPPrec2 := PREPPrec1;
                   PREPPrec2.headkey := KEY_meePREPkey;
              C12: KEY1 = KEY_totPREPkey    AND
                   PREPPrec1.headkey = KEY_totPREPkey
              A12: KEY2 := KEY_toePREPkey;
                   PREPPrec2 := PREPPrec1;
                   PREPPrec2.headkey := KEY_toePREPkey;
          A1: RADVPrec1 := 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : NPrec1.mood
		  kindefs : [Pk]
		  radvkey : 0
		  };
              QUOTE_Assigncase(NPrec1, mu8, NPrec2, mu10, [Rcase]);
         >
      DECOMP
         <
          C1: Rcase IN NPrec2.cases AND
              NPrec2.possRform =true AND
              RADVPrec1 = 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : NPrec2.mood
		  kindefs NI Pk
		  radvkey : 0
		  } 
              C11: KEY2 = KEY_meePREPkey AND
                   PREPPrec2.headkey = KEY_meePREPkey
              A11: KEY1 := KEY_metPREPkey;
                   PREPPrec1 := PREPPrec2;
                   PREPPrec1.headkey := KEY_metPREPkey;
              C12: KEY2 = KEY_toePREPkey  AND
                   PREPPrec2.headkey = KEY_toePREPkey
              A12: KEY1 := KEY_totPREPkey;
                   PREPPrec1 := PREPPrec2;
                   PREPPrec1.headkey := KEY_totPREPkey;
          A1: 
              QUOTE_Assigncase(NPrec2, mu10, NPrec1, mu8, [accusative]);
         >

>




&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Tadjhettoer2
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 3-MAR-1989 16:45:51  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% FILTER Fadjhettoer12
< m :CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu5, 
                      predrel/ADJP{ADJPrec1}
                        [ mu7, 
                          I1:rel1/N1
                             [ mu2,
                               head/PREP{PREPrec1},
                               I2:objrel/T1,
                               mu3 
                              ],
                          mu8
                        ],
                      mu4
                    ],
              mu6
           ]
>


   MATCHCONDITIONS
      <
       I1: rel1 IN [locargrel, prepobjrel, aanobjrel,
                    voorobjrel, paprepobjrel, postadjrel] AND 
           N1.CAT IN [VARPREPP, PREPP]
       I2: (T1.CAT IN [NP, NPVAR] WITH T1.REC.possRform = true) OR
           (T1.CAT IN [CNVAR] WITH T1.REC.human = nohuman)
      >

         <
          C1: true
          A1: @
         >

&
\end{verbatim}
  \newpage
\begin{description}
\item[* name:] Fadjhettoer12
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 6-MAR-1989 08:38:09  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% TRANSFORMATION Tadjertoerpos1
< m1:CLAUSE{CLAUSErec1}
           [ I1:mu1,
             I2:sig1,
             I3:mu2,
             predrel/VERBP{VERBPrec1}
                    [ mu3,
                      predrel/ADJP{ADJPrec1}
                         [ mu9,
                           I4:rel1/T3,
                           I9:sig4
                         ],
                       I6:sig2,
                       head/T2,
                       mu6
                    ] ,
             mu7
           ]
>

< m :CLAUSE{CLAUSErec1}
           [ I1:mu1,
             I5:sig3,
             I3:mu2,
             predrel/VERBP{VERBPrec1}
                    [ mu3,
                      predrel/ADJP{ADJPrec1}
                         [ mu9,
                           I4:rel1/I7::PREPP{PREPPrec2}
                               [ mu4,
                                 head/T1,
                                 mu8
                               ],
                           I9:sig4
                         ],
                       I6:sig2,
                       head/T2,
                       mu6
                    ] ,
             mu7
           ]

>


   MATCHCONDITIONS
      <
       I1: ALL(mu1, I11:rel2/..) 
           I11: QUOTE_Srelprec(rel2, erposrel) AND rel2 <> erposrel
       I2: ALL(sig1, erposrel/..)
       I3: ALL(mu2, I21:rel3/..) 
           I21: QUOTE_Srelprec(erposrel, rel3) AND rel3 <> erposrel
       I4: rel1 IN [prepobjrel, locargrel, dirargrel, paprepobjrel]
       I5: ALL(sig3, erposrel/..)
       I6: ALL(sig2, strandedrel/..)
       I7: PREPPrec2.stranded = true
       I9: ALL(sig4, head/ADJ{ADJrec1}[mu10])
      >

<
   SUBRULE
      <sig1: []
       T3: VARPREPP{VARPREPPrec1}
                             [ mu4,
                               errel/RADVP{RADVPrec1}[I8:mu5],
                               head/T1,
                               mu8
                             ] 
      >
      <sig3: [erposrel/RADVP{RADVPrec2}[I8:mu5]]>

   MATCHCONDITIONS
      <
       I8: EXIST(mu5,[I81:../T4])
           I81: T4.CAT IN AUX_VARCATSET
      >


      COMP
         <
          C1: Pk IN RADVPrec1.kindefs AND
              VARPREPPrec1.stranded = false AND
              QUOTE_Cpspecq(VARPREPPrec1.specq, mu5)
              C11: EXIST(mu5,[../CNVAR{}]) AND
                   VARPREPPrec1.mood = relativexpmood
              A11: PREPPrec2 := VARPREPPrec1;
                   PREPPrec2.stranded := true;
                   PREPPrec2.mood := declxpmood;
                   PREPPrec2.specq := nospec;
              C12: NOT EXIST(mu5,[../CNVAR{}]) AND
                   VARPREPPrec1.mood = RADVPrec1.mood
              A12: PREPPrec2 := VARPREPPrec1;
                   PREPPrec2.stranded := true;
                   PREPPrec2.mood := declxpmood;
                   PREPPrec2.specq := nospec;
          A1: RADVPrec2 := RADVPrec1; 
         >
      DECOMP
         <
          C1: Pk IN RADVPrec2.kindefs 
              C11: EXIST(mu5,[../CNVAR{}]) AND
                   PREPPrec2.stranded = true AND
                   PREPPrec2.mood = declxpmood AND
                   PREPPrec2.specq = nospec
              A11: VARPREPPrec1 := PREPPrec2;
                   VARPREPPrec1.mood := relativexpmood;
              C12: NOT EXIST(mu5,[../CNVAR{}]) AND
                   PREPPrec2.stranded = true AND
                   PREPPrec2.mood = declxpmood AND
                   PREPPrec2.specq = nospec
              A12: VARPREPPrec1 := PREPPrec2;
                   VARPREPPrec1.mood := RADVPrec2.mood;
          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              VARPREPPrec1.stranded := false;
              QUOTE_assSpecq(VARPREPPrec1.specq, mu5);
         >


   SUBRULE
      <sig1: [erposrel/RADVP{RADVPrec3}[head/RADV(KEY_erRADVkey){RADVrec1} ]] 
       T3: VARPREPP{VARPREPPrec1}
                             [ mu4,
                               errel/RADVP{RADVPrec1}[I8:mu5],
                               head/T1,
                               mu8
                             ] 
      >
      <sig3: [erposrel/RADVP{RADVPrec2}[mu5]]>

   MATCHCONDITIONS
      <
       I8: EXIST(mu5,[I81:../T4])
           I81: T4.CAT IN AUX_VARCATSET
      >

      COMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              Pk IN RADVPrec1.kindefs AND
              VARPREPPrec1.stranded = false AND
              RADVPrec3 = 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  } AND
              QUOTE_Cpspecq(VARPREPPrec1.specq, mu5)
              C11: EXIST(mu5,[../CNVAR{}]) AND
                   VARPREPPrec1.mood = relativexpmood
              A11: PREPPrec2 := VARPREPPrec1;
                   PREPPrec2.stranded := true;
                   PREPPrec2.mood := declxpmood;
                   PREPPrec2.specq := nospec;
              C12: NOT EXIST(mu5,[../CNVAR{}]) AND
                   VARPREPPrec1.mood = RADVPrec1.mood
              A12: PREPPrec2 := VARPREPPrec1;
                   PREPPrec2.stranded := true;
                   PREPPrec2.mood := declxpmood;
                   PREPPrec2.specq := nospec;
          A1: RADVPrec2 := RADVPrec1; 
              RADVPrec2.kindefs := [XPk];
         >
      DECOMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              XPk IN RADVPrec2.kindefs 
              C11: EXIST(mu5,[../CNVAR{}]) AND
                   PREPPrec2.stranded = true AND
                   PREPPrec2.mood = declxpmood AND
                   PREPPrec2.specq = nospec
              A11: VARPREPPrec1 := PREPPrec2;
                   VARPREPPrec1.mood := relativexpmood;
              C12: NOT EXIST(mu5,[../CNVAR{}]) AND
                   PREPPrec2.stranded = true AND
                   PREPPrec2.mood = declxpmood AND
                   PREPPrec2.specq = nospec
              A12: VARPREPPrec1 := PREPPrec2;
                   VARPREPPrec1.mood := RADVPrec2.mood;
          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              VARPREPPrec1.stranded := false;
              RADVPrec3 := 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  };
              QUOTE_assSpecq(VARPREPPrec1.specq, mu5);
         >

   SUBRULE
      <sig1: []
       T3: PREPP{PREPPrec1}
                             [ mu4,
                               errel/RADVP{RADVPrec1}[I8:mu5],
                               head/T1,
                               mu8
                             ] 
      >
      <sig3: [erposrel/RADVP{RADVPrec2}[I8:mu5]]>

   MATCHCONDITIONS
      <
       I8: NOT EXIST(mu5,[I81:../T4])
           I81: T4.CAT IN AUX_VARCATSET
      >


      COMP
         <
          C1: Pk IN RADVPrec1.kindefs AND
              PREPPrec1.stranded = false  AND
              PREPPrec1.mood = RADVPrec1.mood AND
              QUOTE_Cpspecq(PREPPrec1.specq, mu5)
          A1: RADVPrec2 := RADVPrec1; 
              PREPPrec2 := PREPPrec1;
              PREPPrec2.stranded := true;
              PREPPrec2.mood := declxpmood;
              PREPPrec2.specq := nospec;
         >
      DECOMP
         <
          C1: Pk IN RADVPrec2.kindefs AND
              PREPPrec2.stranded = true AND
              PREPPrec2.mood = declxpmood AND
              PREPPrec2.specq = nospec
          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              PREPPrec1 := PREPPrec2;
              PREPPrec1.stranded := false;
              PREPPrec1.mood := RADVPrec2.mood;
              QUOTE_assSpecq(PREPPrec1.specq, mu5);
         >


   SUBRULE
      <sig1: [erposrel/RADVP{RADVPrec3}[head/RADV(KEY_erRADVkey){RADVrec1} ]] 
       T3: PREPP{PREPPrec1}
                             [ mu4,
                               errel/RADVP{RADVPrec1}[I8:mu5],
                               head/T1,
                               mu8
                             ] 
      >
      <sig3: [erposrel/RADVP{RADVPrec2}[mu5]]>

   MATCHCONDITIONS
      <
       I8: NOT EXIST(mu5,[I81:../T4])
           I81: T4.CAT IN AUX_VARCATSET
      >

      COMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              Pk IN RADVPrec1.kindefs AND
              PREPPrec1.stranded = false AND
              RADVPrec3 = 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  }  AND
              PREPPrec1.mood = RADVPrec1.mood AND
              QUOTE_Cpspecq(PREPPrec1.specq, mu5)
          A1: RADVPrec2 := RADVPrec1; 
              RADVPrec2.kindefs := [XPk];
              PREPPrec2 := PREPPrec1;
              PREPPrec2.stranded := true;
              PREPPrec2.mood := declxpmood;
              PREPPrec2.specq := nospec;
         >
      DECOMP
         <
          C1: NOT EXIST(mu1, [subjrel/..]) AND
              XPk IN RADVPrec2.kindefs AND
              PREPPrec2.stranded = true AND
              PREPPrec2.mood = declxpmood AND
              PREPPrec2.specq = nospec
          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.kindefs := [Pk];
              PREPPrec1 := PREPPrec2;
              PREPPrec1.stranded := false;
              PREPPrec1.mood := RADVPrec2.mood;
              RADVPrec3 := 
		  {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : declxpmood
		  kindefs : [Xk]
		  radvkey : KEY_erRADVkey
		  };
              QUOTE_assSpecq(PREPPrec1.specq, mu5);
         >
>

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Tadjertoerpos1
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 6-MAR-1989 08:40:36  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% FILTER Fadjertoerpos12
< m :CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu3,
                      predrel/ADJP{ADJPrec1}
                          [ mu9,
                            I4:rel1/N1
                              [ mu4,
                                errel/RADVP{RADVPrec1}[mu5],
                                head/T1,
                                mu8
                              ],
                            mu10
                          ],
                       mu6
                    ] ,
             mu7
           ]
>



   MATCHCONDITIONS
      <
       I4: rel1 IN [prepobjrel, locargrel, dirargrel, aanobjrel, voorobjrel,
            paprepobjrel] 
           AND N1.CAT IN [VARPREPP, PREPP]
      >

         <
          C1: true
          A1: @
         >

  
&
\end{verbatim}
  \newpage
\begin{description}
\item[* name:] adjertoerpos12
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 6-MAR-1989 08:50:29  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

%%
E 2
E 1
