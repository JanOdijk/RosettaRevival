DUTCH 71
&
\newpage
\begin{verbatim}
%
% RULE Rinfinpresentdeixis 
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I1:rel1/VERB{VERBrec1}[head/T2]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I1:rel1/VERB{VERBrec1}[head/T2]
                   ],
            mu5
           ] 

>
   MATCHCONDITIONS
      <
       m1:(CLAUSErec1.deixis = omegadeixis) AND
          (CLAUSErec1.aspect = perfective) AND
          (CLAUSErec1.finiteness = infinite)
       m :(CLAUSErec2.finiteness = infinite) AND
          (CLAUSErec2.aspect = perfective) AND
          (CLAUSErec2.deixis = presentdeixis)
       I1:(VERBrec1.tense = omegatense) 
      >

<
   SUBRULE (* 1 *)
      <T2: SUBVERB{SUBVERBrec1}[I2: head/BVERB(KEY1){BVERBrec1}] >
      <T2: SUBVERB{SUBVERBrec1}[I2: head/BVERB(KEY1){BVERBrec1}] >

   MATCHCONDITIONS
      <
       I2: KEY1 <> KEY_kanirr1BVERBkey AND
           KEY1 <> KEY_kanirr2BVERBkey AND
           KEY1 <> KEY_moetirr1BVERBkey AND
           KEY1 <> KEY_moetirr2BVERBkey 
      >

<
   SUBRULE (* 1a *)
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <T1: ADVPVAR{ADVPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          (ADVPVARrec1.deixis IN [presentdeixis, futuredeixis])
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;

         >
      DECOMP
         <
          C1: true
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: CLAUSErec1.deixis := omegadeixis;

         >

   SUBRULE (* 1b *)
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <T1: PREPPVAR{PREPPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          (PREPPVARrec1.deixis IN [presentdeixis, futuredeixis])
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
            >

      DECOMP
         <
          C1:true
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (* 1c *)
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <T1: SENTENCE{SENTENCErec1}[mu9]>

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          (SENTENCErec1.conjdeixis IN [presentdeixis, futuredeixis])
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
         >

      DECOMP
         <
          C1:true
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: CLAUSErec1.deixis := omegadeixis;
         >
>

   SUBRULE (* 1 *)
      <T2: SUBVERB{SUBVERBrec1}
                  [sig1, head/SUBVERB{SUBVERBrec2}
                             [I2: head/BVERB(KEY1){BVERBrec1}]
                  ]
      >
      <T2: SUBVERB{SUBVERBrec1}
                  [sig1, head/SUBVERB{SUBVERBrec2}
                             [I2: head/BVERB(KEY1){BVERBrec1}]
                  ]
      >

   MATCHCONDITIONS
      <
       I2: KEY1 <> KEY_kanirr1BVERBkey AND
           KEY1 <> KEY_kanirr2BVERBkey AND
           KEY1 <> KEY_moetirr1BVERBkey AND
           KEY1 <> KEY_moetirr2BVERBkey 
      >

<
   SUBRULE (* 2a *)
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <T1: ADVPVAR{ADVPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          (ADVPVARrec1.deixis IN [presentdeixis, futuredeixis])
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;

         >
      DECOMP
         <
          C1: true
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: CLAUSErec1.deixis := omegadeixis;

         >

   SUBRULE (* 2b *)
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <T1: PREPPVAR{PREPPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          (PREPPVARrec1.deixis IN [presentdeixis, futuredeixis])
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
            >

      DECOMP
         <
          C1:true
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (* 2c *)
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <T1: SENTENCE{SENTENCErec1}[mu9]>

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          (SENTENCErec1.conjdeixis IN [presentdeixis, futuredeixis])
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
         >

      DECOMP
         <
          C1:true
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: CLAUSErec1.deixis := omegadeixis;
         >
>
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rinfinpresentdeixis
\item[* relevant examples:] Jan beweert (vandaag te komen)
De (vandaag/morgen te lezen) boeken zijn gisteren pas aangekomen
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 19-FEB-1988 
\item[* author:] Lisette Appelo
\item[* copied from:] Rfinpresentdeixis
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 22/01/90\ \ \ \ \ author: Lisette Appelo\\
Added conditions on perfective aspect, futuredeixis adverbial and modal verb 
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is simultanuous: PRESENT.
               This rule is for a infinite independent clause.
               The most right verb in the clause remains omega tense.
               The deixis 
value of the reference adverbial is checked for 
               present.
               The clause is marked for present deixis.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different categories of the variables for the 
reference adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The superdeixis value also may be presentdeixis in the case 
this sentence is a sentence with {\em graag}\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% RULE Rinfinpastdeixisspec
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                I1:[mu3,
                    I2:rel1/VERB{VERBrec1}[mu4]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                I1:[mu3,
                    I3:rel1/VERB{VERBrec2}[mu4],
                    I4:auxrel/VERB{VERBrec3}
                          [head/SUBVERB{SUBVERBrec1}
                               [head/T2] 
                          ],
                    mu5
                   ]
           ] 

>
   MATCHCONDITIONS
      <
       I1: RIGHTTOLEFT
       m1:(CLAUSErec1.deixis = omegadeixis) AND
          (CLAUSErec1.aspect = perfective) AND
          (CLAUSErec1.retro = false) AND
          (CLAUSErec1.finiteness = infinite) 
       I2:(VERBrec1.tense = omegatense) 
       m :(CLAUSErec2.deixis = pastdeixis) AND
          (CLAUSErec2.aspect = perfective) AND
          (CLAUSErec2.retro = false) AND
          (CLAUSErec2.finiteness = infinite) 
       I3:(VERBrec2.modus = pastpart) 
       I4:(VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1)) AND
          (VERBrec3 =
                     {
                      number : omeganumber
                      persons : []
                      eORenForm : NoForm
                      modus : omegamodus
                      tense : omegatense
                      status : bareV
                     }
          )
          (* other values: default values *)

      >

<
   SUBRULE (*1: ADVPVAR, hebben*)
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <
       T1: ADVPVAR{ADVPVARrec1}[ ]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          (ADVPVARrec1.deixis = pastdeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:((hebaux IN VERBrec2.perfauxs) AND
              (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             )
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*2: ADVPVAR, zijn*)
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <
       T1: ADVPVAR{ADVPVARrec1}[ ]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          (ADVPVARrec1.deixis = pastdeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*3: PREPPVAR, hebben*)
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <
       T1: PREPPVAR{PREPPVARrec1}[ ]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          (PREPPVARrec1.deixis = pastdeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*4: PREPPVAR, zijn*)
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <
       T1: PREPPVAR{PREPPVARrec1}[ ]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          (PREPPVARrec1.deixis = pastdeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
         >
   SUBRULE (*5: SENTENCE, hebben*)
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <
       T1: SENTENCE{SENTENCErec1}[mu9]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          (SENTENCErec1.conjdeixis = pastdeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*6: SENTENCE, zijn*)
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <
       T1: SENTENCE{SENTENCErec1}[mu9]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          (SENTENCErec1.conjdeixis = pastdeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
         >
>
&
\end{verbatim}

\newpage
\begin{description}
\item[* name:] Rinfinpastdeixisspec
\item[* relevant examples:] hij zegt (gisteren geslapen te hebben)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 19-FEB-1988 
\item[* author:] Lisette Appelo
\item[* copied from:]Rfinpastdeixisspec
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author: 
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is before: PAST.
               This rule is for a infinite independent clause. This
               is a special rule,because past is expressed by the auxiliary 
               verb {\em have/zijn}. 
               The most right verb in the clause (input generative rule)
gets modus of a past particle.
The auxiliary verb {\em hebben/zijn
} is introduced with a omega tense.
               The deixis 
value of the reference adverbial is checked for 
               past.
               The clause is marked for past deixis.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different variable categories for the reference 
adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial, perfective aspect rule \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language: This rule has the same semantics as 
Rfinpastdeixis.\\

\item in other languages: \\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The superdeixis value also may be pastdeixis in the case 
this sentence is a sentence with {\em graag}\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rimpdeixis
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            predrel/VERBP{VERBPrec1}
                   [mu2
                   ],
            mu3
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [mu1,
            predrel/VERBP{VERBPrec1}
                   [mu2
                   ],
            mu3
           ] 

>


<
   SUBRULE
      <mu1: [I1: mu4]>
      <mu1: [I1: mu4]>

   MATCHCONDITIONS
      <
       I1: QUOTE_temprefnotfound(mu4)
      >

      COMP
         <
          C1:((CLAUSErec1.deixis = omegadeixis) AND
              (CLAUSErec1.superdeixis = omegadeixis) AND
              (CLAUSErec1.finiteness = finite) AND
              (CLAUSErec1.aspect = perfective) AND
              (CLAUSErec1.retro = false) AND
              (CLAUSErec1.modus = omegamodus)
             )

          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.modus := imperative;
              CLAUSERec2.deixis := presentdeixis;

         >

      DECOMP
         <
          C1:((CLAUSErec2.deixis = presentdeixis) AND
              (CLAUSErec2.superdeixis = omegadeixis) AND
              (CLAUSErec2.finiteness = finite) AND
              (CLAUSErec2.aspect = perfective) AND
              (CLAUSErec2.retro = false) AND
              (CLAUSErec2.modus = imperative) 
             )
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE
      <mu1:[mu4, I1: tempadvrel/ADVPVAR{ADVPVARrec1}[ ], mu5]>
      <mu1:[mu4, I1: tempadvrel/ADVPVAR{ADVPVARrec1}[ ], mu5]>

   MATCHCONDITIONS
      <
       I1: (ADVPVARrec1.class = reference) AND
           (ADVPVARrec1.retro = false) AND
           ((ADVPVARrec1.deixis = presentdeixis) OR
            (ADVPVARrec1.deixis = omegadeixis) OR
            (ADVPVARrec1.deixis = futuredeixis)
           )
      >

      COMP
         <
          C1:((CLAUSErec1.deixis = omegadeixis) AND
              (CLAUSErec1.superdeixis = omegadeixis) AND
              (CLAUSErec1.finiteness = finite) AND
              (CLAUSErec1.aspect = perfective) AND
              (CLAUSErec1.retro = false) AND
              (CLAUSErec1.modus = omegamodus)
             )

          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.modus := imperative;
              CLAUSERec2.deixis := presentdeixis;

         >

      DECOMP
         <
          C1:((CLAUSErec2.deixis = presentdeixis) AND
              (CLAUSErec2.superdeixis = omegadeixis) AND
              (CLAUSErec2.finiteness = finite) AND
              (CLAUSErec2.aspect = perfective) AND
              (CLAUSErec2.retro = false) AND
              (CLAUSErec2.modus = imperative) 
             )
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
          
         >

   SUBRULE
      <mu1:[mu4, I1: tempadvrel/PREPPVAR{PREPPVARrec1}[ ], mu5]>
      <mu1:[mu4, I1: tempadvrel/PREPPVAR{PREPPVARrec1}[ ], mu5]>

   MATCHCONDITIONS
      <
       I1: (PREPPVARrec1.class = reference) AND
           (PREPPVARrec1.retro = false) AND
           ((PREPPVARrec1.deixis = presentdeixis) OR
            (PREPPVARrec1.deixis = omegadeixis) OR
            (PREPPVARrec1.deixis = futuredeixis)
           )
      >

      COMP
         <
          C1:((CLAUSErec1.deixis = omegadeixis) AND
              (CLAUSErec1.superdeixis = omegadeixis) AND
              (CLAUSErec1.finiteness = finite) AND
              (CLAUSErec1.aspect = perfective) AND
              (CLAUSErec1.retro = false) AND
              (CLAUSErec1.modus = omegamodus)
             )

          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.modus := imperative;
              CLAUSERec2.deixis := presentdeixis;

         >

      DECOMP
         <
          C1:((CLAUSErec2.deixis = presentdeixis) AND
              (CLAUSErec2.superdeixis = omegadeixis) AND
              (CLAUSErec2.finiteness = finite) AND
              (CLAUSErec2.aspect = perfective) AND
              (CLAUSErec2.retro = false) AND
              (CLAUSErec2.modus = imperative) 
             )
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
          
         >

   SUBRULE
      <mu1:[mu4, I1: tempadvrel/SENTENCE{SENTENCErec1}[mu9], mu5]>
      <mu1:[mu4, I1: tempadvrel/SENTENCE{SENTENCErec1}[mu9], mu5]>

   MATCHCONDITIONS
      <
       I1: (SENTENCErec1.conjclass = reference) AND
           (SENTENCErec1.conjretro = false) AND
           ((SENTENCErec1.conjdeixis = presentdeixis) OR
            (SENTENCErec1.conjdeixis = omegadeixis) OR
            (SENTENCErec1.conjdeixis = futuredeixis)
           )
      >

      COMP
         <
          C1:((CLAUSErec1.deixis = omegadeixis) AND
              (CLAUSErec1.superdeixis = omegadeixis) AND
              (CLAUSErec1.finiteness = finite) AND
              (CLAUSErec1.aspect = perfective) AND
              (CLAUSErec1.retro = false) AND
              (CLAUSErec1.modus = omegamodus)
             )

          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.modus := imperative;
              CLAUSERec2.deixis := presentdeixis;

         >

      DECOMP
         <
          C1:((CLAUSErec2.deixis = presentdeixis) AND
              (CLAUSErec2.superdeixis = omegadeixis) AND
              (CLAUSErec2.finiteness = finite) AND
              (CLAUSErec2.aspect = perfective) AND
              (CLAUSErec2.retro = false) AND
              (CLAUSErec2.modus = imperative) 
             )
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
          
         >
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rimpdeixis
\item[* relevant examples:] Kom (morgen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 30-MAR-1988 
\item[* author:] Lisette Appelo
\item[* copied from:] Rinfinpresentdeixis
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 19/05/89\ \ \ \ \ author: Lisette Appelo\\
Added condition on futuredeixis adverbial. 
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between S and Rs is not relevant.
               This rule is for a finite independent (main) clause that will 
get mood {\em imperative or latenmood} in the mood rules..
               The deixis 
value of the reference adverbial is checked for 
               present or omega.
               The clause is marked for presentdeixis.
               The clause is marked with modus = imperative.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different categories of (the variables for) the 
possible reference adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: \\
\end{enumerate}
\end{description}

\newpage
\begin{verbatim}

% RULE Rfinirrmodaldeixis
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    head/VERB{VERBrec1}
                        [head/SUBVERB{SUBVERBrec1}
                             [I2:head/BVERB(KEY1){BVERBrec1}]
                        ]
                   ],
            mu4
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    head/VERB{VERBrec2}
                         [head/SUBVERB{SUBVERBrec1}
                              [I2:head/BVERB(KEY1){BVERBrec1}]
                         ]
                   ],
              mu4
           ] 

>
   MATCHCONDITIONS
      <
       I2: KEY1 = KEY_kanirr1BVERBkey OR
           KEY1 = KEY_kanirr2BVERBkey OR
           KEY1 = KEY_moetirr1BVERBkey OR
           KEY1 = KEY_moetirr2BVERBkey 
      >

<
   SUBRULE (*1: ADVPVAR*)
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <T1: ADVPVAR{ADVPVARrec1}[ ]>

      COMP
         <
          C1:((ADVPVARrec1.class = reference) AND
              (ADVPVARrec1.retro = false) AND
              (ADVPVARrec1.deixis = pastdeixis) AND
              (CLAUSErec1.deixis = omegadeixis) AND
              (CLAUSErec1.aspect = perfective) AND
              (VERBrec1.tense = omegatense) AND
              (CLAUSErec1.retro = false) AND
              (CLAUSErec1.finiteness = finite) AND
              (VERBrec1.modus = omegamodus) 
             )
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
               (* other values retain their default values *)
             
         >
      DECOMP
         <
          C1:((ADVPVARrec1.class = reference) AND
              (ADVPVARrec1.retro = false) AND
              (ADVPVARrec1.deixis = pastdeixis) AND
              (CLAUSErec2.deixis = pastdeixis) AND
              (CLAUSErec2.aspect = perfective) AND
              (CLAUSErec2.retro = false) AND
              (CLAUSErec2.finiteness = finite) AND
              (VERBrec2.tense = pasttense)
              (* other values: default values *)
             )
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >


   SUBRULE (*2: PREPPVAR*)
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <T1: PREPPVAR{PREPPVARrec1}[ ]>

      COMP
         <
          C1:((PREPPVARrec1.class = reference) AND
              (PREPPVARrec1.retro = false) AND
              (PREPPVARrec1.deixis = pastdeixis) AND
              (CLAUSErec1.deixis = omegadeixis) AND
              (CLAUSErec1.aspect = perfective) AND
              (VERBrec1.tense = omegatense) AND
              (CLAUSErec1.retro = false) AND
              (CLAUSErec1.finiteness = finite) AND
              (VERBrec1.modus = omegamodus) 
             )
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
               (* other values retain their default values *)
             
         >
      DECOMP
         <
          C1:((PREPPVARrec1.class = reference) AND
              (PREPPVARrec1.retro = false) AND
              (PREPPVARrec1.deixis = pastdeixis) AND
              (CLAUSErec2.deixis = pastdeixis) AND
              (CLAUSErec2.aspect = perfective) AND
              (CLAUSErec2.retro = false) AND
              (CLAUSErec2.finiteness = finite) AND
              (VERBrec2.tense = pasttense)
              
              (* other values: default values *)
             )
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >


   SUBRULE (*3: SENTENCE*)
      <T1: SENTENCE{SENTENCErec2}[mu10]>
      <T1: SENTENCE{SENTENCErec2}[mu10]>

      COMP
         <
          C1:((SENTENCErec2.conjclass = reference) AND
              (SENTENCErec2.conjretro = false) AND
              (SENTENCErec2.conjdeixis = pastdeixis) AND
              (CLAUSErec1.deixis = omegadeixis) AND
              (CLAUSErec1.aspect = perfective) AND
              (VERBrec1.tense = omegatense) AND
              (CLAUSErec1.retro = false) AND
              (CLAUSErec1.finiteness = finite) AND
              (VERBrec1.modus = omegamodus) 
             )
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
               (* other values retain their default values *)
             
         >

      DECOMP
         <
          C1:((SENTENCErec2.conjclass = reference) AND
              (SENTENCErec2.conjretro = false) AND
              (SENTENCErec2.deixis = pastdeixis) AND
              (CLAUSErec2.deixis = pastdeixis) AND
              (CLAUSErec2.aspect = perfective) AND
              (CLAUSErec2.retro = false) AND
              (CLAUSErec2.finiteness = finite) AND
              (VERBrec2.tense = pasttense)
              
              (* other values: default values *)
             )
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >


>
&
\end{verbatim}

\newpage
\begin{description}
\item[* name:] Rfinirrmodaldeixis
\item[* relevant examples:] hij komen kunnen $rightarrow$ hij kunnen komen zou\\
hij komen moeten $rightarrow$ hij moeten komen zou
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 07-OCT-1988 
\item[* author:] Lisette Appelo
\item[* copied from:]Rinfinpastdeixisspec
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 09/01/90\ \ \ \ \ author: Lisette Appelo\\
Changed rule completely. {\em Zou} will be inserted in Tzouinsertion. The modal
verbs have an abstract version (skey) to account for this case. 
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Irrealis construction of modals {\em kunnen} and {\em moeten}.
               This rule is for a finite independent clause. This
               is a special rule,because irrealis is expressed by the auxiliary 
               verb {\em zou}. 
               The deixis 
value of the reference adverbial is checked for past deixis.
               The clause is marked for past deixis.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different variable categories for the reference 
adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial, perfective aspect rule \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language: \\

\item in other languages: \\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The superdeixis value also may be pastdeixis in the case 
this sentence is a sentence with {\em graag}\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% RULE RinfinpresentdeixisA 
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I1:rel1/VERB{VERBrec1}
                           [I3:rel2/VERB{VERbrec3}[head/T2]
                           ]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I1:rel1/VERB{VERBrec1}
                           [I4:rel2/VERB{VERbrec4}[head/T2]
                           ]
                   ],
            mu5
           ] 

>
   MATCHCONDITIONS
      <
       m1:(CLAUSErec1.deixis = omegadeixis) AND
          (CLAUSErec1.aspect = perfective) AND
          (CLAUSErec1.finiteness = infinite)
       m :(CLAUSErec2.finiteness = infinite) AND
          (CLAUSErec2.aspect = perfective) AND
          (CLAUSErec2.deixis = presentdeixis)
       I1:(VERBrec1.tense = omegatense) AND
          (VERBrec1.status = VV)
       I3: VERbrec3.tense = omegatense AND
           VERBrec3.modus = infinitive
       I4: VERBrec4.tense = omegatense AND
           VERBrec4.modus = omegamodus
      >

<
   SUBRULE (* 1 *)
      <T2: SUBVERB{SUBVERBrec1}[I2: head/BVERB(KEY1){BVERBrec1}] >
      <T2: SUBVERB{SUBVERBrec1}[I2: head/BVERB(KEY1){BVERBrec1}] >

   MATCHCONDITIONS
      <
       I2: KEY1 <> KEY_kanirr1BVERBkey AND
           KEY1 <> KEY_kanirr2BVERBkey AND
           KEY1 <> KEY_moetirr1BVERBkey AND
           KEY1 <> KEY_moetirr2BVERBkey 
      >

<
   SUBRULE (* 1a *)
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <T1: ADVPVAR{ADVPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          (ADVPVARrec1.deixis IN [presentdeixis, futuredeixis])
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec4 := VERbrec3;
              VERBrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1: true

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: CLAUSErec1.deixis := omegadeixis;
              VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;

         >

   SUBRULE (* 1b *)
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <T1: PREPPVAR{PREPPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          (PREPPVARrec1.deixis IN [presentdeixis, futuredeixis])
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec4 := VERbrec3;
              VERBrec4.modus := omegamodus;
            >

      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: CLAUSErec1.deixis := omegadeixis;
              VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
         >

   SUBRULE (* 1c *)
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <T1: SENTENCE{SENTENCErec1}[mu9]>

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          (SENTENCErec1.conjdeixis IN [presentdeixis, futuredeixis])
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec4 := VERbrec3;
              VERBrec4.modus := omegamodus;
         >

      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: CLAUSErec1.deixis := omegadeixis;
              VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
         >
>

   SUBRULE (* 1 *)
      <T2: SUBVERB{SUBVERBrec1}
                  [sig1, head/SUBVERB{SUBVERBrec2}
                             [I2: head/BVERB(KEY1){BVERBrec1}]
                  ]
      >
      <T2: SUBVERB{SUBVERBrec1}
                  [sig1, head/SUBVERB{SUBVERBrec2}
                             [I2: head/BVERB(KEY1){BVERBrec1}]
                  ]
      >

   MATCHCONDITIONS
      <
       I2: KEY1 <> KEY_kanirr1BVERBkey AND
           KEY1 <> KEY_kanirr2BVERBkey AND
           KEY1 <> KEY_moetirr1BVERBkey AND
           KEY1 <> KEY_moetirr2BVERBkey 
      >

<
   SUBRULE (* 2a *)
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <T1: ADVPVAR{ADVPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          (ADVPVARrec1.deixis IN [presentdeixis, futuredeixis])
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec4 := VERbrec3;
              VERBrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1: true

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: CLAUSErec1.deixis := omegadeixis;
              VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;

         >

   SUBRULE (* 2b *)
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <T1: PREPPVAR{PREPPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          (PREPPVARrec1.deixis IN [presentdeixis, futuredeixis])
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec4 := VERbrec3;
              VERBrec4.modus := omegamodus;
            >

      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: CLAUSErec1.deixis := omegadeixis;
              VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
         >

   SUBRULE (* 2c *)
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <T1: SENTENCE{SENTENCErec1}[mu9]>

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          (SENTENCErec1.conjdeixis IN [presentdeixis, futuredeixis])
      >

      COMP
         <
          C1:true
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec4 := VERbrec3;
              VERBrec4.modus := omegamodus;
         >

      DECOMP
         <
          C1:true

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: CLAUSErec1.deixis := omegadeixis;
              VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
         >
>
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RinfinpresentdeixisA
\item[* relevant examples:] Jan beweert (toevallig vandaag te kunnen komen)
De (vandaag/morgen toevallig te .... lezen) boeken zijn gisteren pas aangekomen
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 07-MAR-1990 
\item[* author:] Lisette Appelo
\item[* copied from:] Rinfinpresentdeixis
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is simultanuous: PRESENT.
               This rule is for a infinite independent clause.
               The most right verb in the clause remains omega tense.
               The deixis 
value of the reference adverbial is checked for 
               present.
               The clause is marked for present deixis.
               This rule is for cases with {\em graag and toevallig} in 
combination with verb clusters.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different categories of the variables for the 
reference adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: \\
\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE RinfinpastdeixisspecA
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                I1:[mu3,
                    I6:head/VERB{VERbrec5}
                        [I4:auxrel/VERB{VERBrec3}
                                  [head/SUBVERB{SUBVERBrec1}
                                       [head/T2] 
                                  ],
                        I2:rel1/VERB{VERBrec1}
                                    [I3:head/VERB{VERbrec2}[mu4],
                                     mu6
                                    ]
                       ]
                    ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                I1:[mu3,
                    I6:head/VERB{VERBrec5}
                        [I5:auxrel/VERB{VERBrec4}
                                  [head/SUBVERB{SUBVERBrec1}
                                       [head/T2] 
                                  ],
                         I2:rel1/VERB{VERBrec1}
                                [I3:head/VERB{VERBrec2}[mu4],
                                 mu6
                                ]
                        ]
                   ],
            mu5
           ] 

>
   MATCHCONDITIONS
      <
       I1: RIGHTTOLEFT
       m1:(CLAUSErec1.deixis = omegadeixis) AND
          (CLAUSErec1.aspect = perfective) AND
          (CLAUSErec1.retro = false) AND
          (CLAUSErec1.finiteness = infinite) 
       I2:(VERBrec1.tense = omegatense) AND
          (VERbrec1.status = VV)
       m :(CLAUSErec2.deixis = pastdeixis) AND
          (CLAUSErec2.aspect = perfective) AND
          (CLAUSErec2.retro = false) AND
          (CLAUSErec2.finiteness = infinite) 
       I3:(VERBrec2.modus = infinitive) AND
          (VERbrec2.tense = omegatense) 
       I4:(VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1)) AND
          (VERBrec3 =
                     {
                      number : omeganumber
                      persons : []
                      eORenForm : NoForm
                      modus : infinitive
                      tense : omegatense
                      status : bareV
                     }
          )
          (* other values: default values *)
       I5:(VERBrec4 = COPYT_subverbtoverb(SUBVERBrec1)) AND
          (VERBrec4 =
                     {
                      number : omeganumber
                      persons : []
                      eORenForm : NoForm
                      modus : omegamodus
                      tense : omegatense
                      status : bareV
                     }
          )
          (* other values: default values *)
       I6: VERbrec5.status = AuxV
      >

<
   SUBRULE (*1: ADVPVAR, hebben*)
      <T1: ADVPVAR{ADVPVARrec1}[ ]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >
      <
       T1: ADVPVAR{ADVPVARrec1}[ ]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          (ADVPVARrec1.deixis = pastdeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs) AND
              SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)

             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec4 := VERbrec3;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:((hebaux IN VERBrec2.perfauxs) AND
              (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             )
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*2: ADVPVAR, zijn*)
      <T1: ADVPVAR{ADVPVARrec1}[ ]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >
      <
       T1: ADVPVAR{ADVPVARrec1}[ ]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          (ADVPVARrec1.deixis = pastdeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs) AND
              SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)

             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*3: PREPPVAR, hebben*)
      <T1: PREPPVAR{PREPPVARrec1}[ ]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >
      <
       T1: PREPPVAR{PREPPVARrec1}[ ]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          (PREPPVARrec1.deixis = pastdeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs) AND
              SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*4: PREPPVAR, zijn*)
      <T1: PREPPVAR{PREPPVARrec1}[ ]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >
      <
       T1: PREPPVAR{PREPPVARrec1}[ ]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          (PREPPVARrec1.deixis = pastdeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs) AND
              SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
              
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;
         >
   SUBRULE (*5: SENTENCE, hebben*)
      <T1: SENTENCE{SENTENCErec1}[mu9]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >
      <
       T1: SENTENCE{SENTENCErec1}[mu9]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          (SENTENCErec1.conjdeixis = pastdeixis)
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs) AND
              SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(hebaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*6: SENTENCE, zijn*)
      <T1: SENTENCE{SENTENCErec1}[mu9]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >
      <
       T1: SENTENCE{SENTENCErec1}[mu9]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          (SENTENCErec1.conjdeixis = pastdeixis)
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs) AND
              SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec4 := VERBrec3;
              VERBrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(isaux IN VERBrec2.perfauxs) AND
             (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;
         >
>
&
\end{verbatim}

\newpage
\begin{description}
\item[* name:] RinfinpastdeixisspecA
\item[* relevant examples:] hij zegt (gisteren toevallig geprobeerd te hebben 
te slapen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 08-MAR-1990 
\item[* author:] Lisette Appelo
\item[* copied from:]Rinfinpastdeixisspec
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author: 
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is before: PAST.
               This rule is for a infinite independent clause. This
               is a special rule,because past is expressed by the auxiliary 
               verb {\em have/zijn}. 
               The deixis 
value of the reference adverbial is checked for 
               past.
               The clause is marked for past deixis.
This rule is meant for cases with graag or toevallig and verb clusters.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different variable categories for the reference 
adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial, perfective aspect rule \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language: This rule has the same semantics as 
Rfinpastdeixis.\\

\item in other languages: \\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The superdeixis value also may be pastdeixis in the case 
this sentence is a sentence with {\em graag}\\

\end{enumerate}
\end{description}

%
%
