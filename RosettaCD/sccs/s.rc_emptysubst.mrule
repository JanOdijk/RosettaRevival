h03417
s 01858/00000/00001
d D 1.2 92/02/21 15:43:23 rous 2 1
c 
e
s 00001/00000/00000
d D 1.1 92/02/11 11:47:47 rous 1 0
c date and time created 92/02/11 11:47:47 by rous
e
u
U
f e 0
t
T
I 2
DUTCH 17

&
\newpage
\begin{verbatim}
%
% RULE REmptysubstitution1
                               (* subst in a by-phrase *)
< m1: I1::CLAUSE{CLAUSErec1}
            [ mu1,
              predrel/VERBP{VERBPrec1}
                  I8:[ I2:mu2,
                       byobjrel/VARPREPP{VARPREPPrec1}
                             [ head/PREP(AUX_doorbyprepkey){PREPrec1},
                               objrel/EMPTYVAR{EMPTYVARrec1}
                             ],
                       I3:mu3
                     ],
              mu4 
            ]
SUBST:
  m2:EMPTY(AUX_menemptykey){EMPTYrec1}                (*substituent*) 
>

< m :I1::CLAUSE{CLAUSErec1}
            [ mu1,
              predrel/VERBP{VERBPrec1}
                  I8:[ I2:mu2,
                       I5:mu3
                     ],
              mu4 
            ]
>

   MATCHCONDITIONS
      <
       I1: CLAUSErec1.voice IN [Passive, DoorActive] 
       I2: ALL(mu2, I4:rel1/..)
       I3: (ALL(mu3, I6:rel2/..)) AND (NOT EXIST(mu3, [byobjrel/..]) )
       I4: rel1 IN AUX_InsideVPAdvRels
       I5: (ALL(mu3, I6:rel2/..)) AND (NOT EXIST(mu3, [byobjrel/..])) AND
           ( (NOT EXIST(mu3,[../EMPTYVAR{}]) ) AND
             (NOT EXIST(mu3,[../VARPREPP{}[I7:mu5]]))
           )   (* substordercond *)
       I6: rel2 IN AUX_InsideVPArgandVRels
       I7: EXIST(mu5, [../EMPTYVAR{}])
       I8: RIGHTTOLEFT
      >

   PARAMETERS
      <
       LEVEL
      >


(* *)
      COMP
         <
          C1: (EMPTYVARrec1.index = LEVEL) AND
               EMPTYVARrec1 =
                 { 
                  person  : 3
                  number  : singular
                 }                            AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                  actsubcefs : [doorby]
                 } 
          A1: @
         >
      DECOMP
         <
          C1: true
          A1: WBONUS -1;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
                 { 
                  person  : 3
                  number  : singular
                 };
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : [doorby]
                  specq      : yesspec
                  mood       : declxpmood
                  actsubcefs : [doorby]
                 };

(* rest default values *)

         >
&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] REmptysubstitution1
\item[* relevant examples:]
x2 [door x1] gelezen werd $\rightarrow$ x2 gelezen\\
( Het boek werd gelezen )
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] (name of rule, transformation or filter class) RC: EMPTY 
substitution
\item[* date of creation:] 12-MAR-1987 15:46:59  
\item[* author:] Jan Odijk
\item[* copied from:]--
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To substitute EMPTYs as the obj of a byobjrel/..
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]dna
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In analysis there is a check on the substitution order, which does not exist
in generation.
The check does not exist in generation because the relevant languages 
may differ w.r.t order of substitution, cf. e.g.
\begin{description}
   \item[DUTCH]  door x1 objrel/x2 gegeven werd 
   \item{ENGLISH] was given objrel/x2 by x1 .
\end{enumerate},
though this difference in substitution never has any consequences for 
the meaning.
In analysis a check on substitution order is made to avoid superfluous 
ambiguities, i.e. to avoid many derivations to which only one meaning 
corresponds. 
\item[\  \ suggested semantics:] Existential Quantification,
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% RULE REmptysubstitution2
                               (*subst of EMPTY as a objrel/..*)
< m1: I1::CLAUSE{CLAUSErec1}
                [ mu1,
                  predrel/VERBP{VERBPrec1}
                      I8:[ I2:mu2,
                           objrel/I10::EMPTYVAR{EMPTYVARrec1},
                           I3:mu3
                         ],
                  mu4 
                ]
SUBST:
  m2: EMPTY(AUX_zeroemptykey){EMPTYrec1}            (*substituent*)
>

< m : I9::CLAUSE{CLAUSErec2}
                [ mu1,
                  predrel/VERBP{VERBPrec1}
                      I8:[ I2:mu2,
                           I5:mu3 
                         ],
                  mu4
                ]
>

   MATCHCONDITIONS
      <
       I1: CLAUSErec1.synvpefs * AUX_emptyobjvps <> []
       I2: ALL(mu2, I4:rel1/..)
       I3: ALL(mu3, I6:rel2/..) AND NOT EXIST(mu3, [objrel/..])
       I4: rel1 IN AUX_preobjrels
       I5: ALL(mu3, I6:rel2/..) AND NOT EXIST(mu3, [objrel/..]) AND
           ( (NOT EXIST(mu3,[../EMPTYVAR{}]) ) AND
             (NOT EXIST(mu3,[../VARPREPP{}[I7:mu5]]))
           )   (* substordercond *)
       I6: rel2 IN AUX_InsideVPArgandVrels
       I7: EXIST(mu5,[../EMPTYVAR{}])
       I8: RIGHTTOLEFT
       I9: CLAUSErec2.synvpefs * AUX_emptyobjvps <> []
       I10: EMPTYVARrec1.index = LEVEL 
      >


   PARAMETERS
      <
       LEVEL
      >



      COMP
         <
          C1: EMPTYVARrec1 =
                  { person : 2
                    number : singular
                  }                     
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.synvpefs := CLAUSErec1.synvpefs * AUX_emptyobjvps
         >
      DECOMP
         <
          C1: true
          A1: WBONUS -1;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
                  { person : 2
                    number : singular
                  };
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * AUX_emptyobjvps
         >


&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] REmptysubstitution2
\item[* relevant examples:]
x1 x2 at $\rightarrow$ x1 at
(Hij at)
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoClause
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 16-MAR-1987 09:52:41  
\item[* author:] Jan Odijk
\item[* copied from:]--
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To substitute EMPTYs as objrel/..
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] dna
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In analysis there is a check on the substitution order, which does not exist
in generation.
The check does not exist in generation because the relevant languages 
may differ w.r.t order of substitution, though this difference in substitution
never has any consequences for the meaning. 
In analysis a check on substitution order is made to avoid superfluous 
ambiguities, i.e. to avoid many derivations to which only one meaning 
corresponds. 
\item[\  \ suggested semantics:] Existential Quantification
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% RULE REmptysubstitution3
                               (*subst of EMPTY as an indobjrel/..*)
< m1: I1::CLAUSE{CLAUSErec1}
                [ mu1,
                  predrel/VERBP{VERBPrec1}
                      I8:[ I2:mu2,
                           indobjrel/I10::EMPTYVAR{EMPTYVARrec1},
                           I3:mu3
                         ],
                  mu4 
                ]
SUBST:
  m2: EMPTY(AUX_zeroemptykey){EMPTYrec1}            (*substituent*)
>

< m : I9::CLAUSE{CLAUSErec2}
                [ mu1,
                  predrel/VERBP{VERBPrec1}
                      I8:[ I2:mu2,
                           I5:mu3 
                         ],
                  mu4
                ]
>

   MATCHCONDITIONS
      <
       I1: CLAUSErec1.synvpefs * AUX_emptyindobjvps <> []
       I2: ALL(mu2, I4:rel1/..)
       I3: ALL(mu3, I6:rel2/..) AND NOT EXIST(mu3, [indobjrel/..])
       I4: rel1 IN AUX_preindobjrels
       I5: ALL(mu3, I6:rel2/..) AND NOT EXIST(mu3, [indobjrel/..]) AND
           ( (NOT EXIST(mu3,[../EMPTYVAR{}]) ) AND
             (NOT EXIST(mu3,[../VARPREPP{}[I7:mu5]]))
           )   (* substordercond *)
       I6: rel2 IN AUX_InsideVPArgandVrels
       I7: EXIST(mu5,[../EMPTYVAR{}])
       I8: RIGHTTOLEFT
       I9: CLAUSErec2.synvpefs * AUX_emptyindobjvps <> []
       I10:EMPTYVARrec1.index = LEVEL 
      >

   PARAMETERS
      <
       LEVEL
      >




      COMP
         <
          C1: EMPTYVARrec1 =
                  { person : 2
                    number : singular
                  }                     
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.synvpefs := CLAUSErec1.synvpefs * AUX_emptyindobjvps
         >
      DECOMP
         <
          C1: true
          A1: WBONUS -1;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
                  { person : 2
                    number : singular
                  };
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * AUX_emptyindobjvps
         >


&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] REmptysubstitution3
\item[* relevant examples:]
x1 x2 x3 gaf  $\rightarrow$ x1 x3 gaf
(Piet gaf een boek)
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoClause
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:]  16-MAR-1987 10:20:53 
\item[* author:] Jan Odijk
\item[* copied from:] REmptysubstitution2
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To substitute EMPTYs as indobjrel/..
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] dna
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In analysis there is a check on the substitution order, which does not exist
in generation.
The check does not exist in generation because the relevant languages 
may differ w.r.t order of substitution, though this difference in substitution
never has any consequences for the meaning. 
In analysis a check on substitution order is made to avoid superfluous 
ambiguities, i.e. to avoid many derivations to which only one meaning 
corresponds. 
\item[\  \ suggested semantics:] Existential Quantification
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% RULE REMPTYsubstitution4
                               (* subst in a aan-phrase in AanActives *)
< m1: I1::CLAUSE{CLAUSErec1}
            [ mu1,
              predrel/VERBP{VERBPrec1}
                  I8:[ I2:mu2,
                       aanobjrel/VARPREPP{VARPREPPrec1}
                             [ head/PREP(AUX_aanioprepkey){PREPrec1},
                               objrel/I9::EMPTYVAR{EMPTYVARrec1}
                             ],
                       I3:mu3
                     ],
              mu4 
            ]
SUBST:
  m2:EMPTY(AUX_menemptykey){EMPTYrec1}                (*substituent*) 
>

< m :I1::CLAUSE{CLAUSErec1}
            [ mu1,
              predrel/VERBP{VERBPrec1}
                  I8:[ I2:mu2,
                       I5:mu3
                     ],
              mu4 
            ]
>

   MATCHCONDITIONS
      <
       I1: CLAUSErec1.voice IN [AanActive] 
       I2: ALL(mu2, I4:rel1/..)
       I3: (ALL(mu3, I6:rel2/..)) AND (NOT EXIST(mu3, [aanobjrel/..]) )
       I4: rel1 IN AUX_InsideVPAdvRels
       I5: (ALL(mu3, I6:rel2/..)) AND (NOT EXIST(mu3, [aanobjrel/..])) AND
           ( (NOT EXIST(mu3,[../EMPTYVAR{}]) ) AND
             (NOT EXIST(mu3,[../VARPREPP{}[I7:mu5]]))
           )   (* substordercond *)
       I6: rel2 IN AUX_InsideVPArgandVRels
       I7: EXIST(mu5, [../EMPTYVAR{}])
       I8: RIGHTTOLEFT
       I9: EMPTYVARrec1.index = LEVEL
      >

   PARAMETERS
      <
       LEVEL
      >



(* *)
      COMP
         <
          C1: EMPTYVARrec1 =
                  { person : 3
                    number : singular
                  }                     AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                  actsubcefs : [aan]
                 } 
          A1: @
         >
      DECOMP
         <
          C1: true
          A1: WBONUS -1;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
                  { person : 3
                    number : singular
                  };
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : [aan]
                  specq      : yesspec
                  mood       : declxpmood
E 2
I 1
 
I 2
                 };


              (* all other attributes retain their default values *)
         >
&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] REMPTYsubstitution4
\item[* relevant examples:]
x2 [aan x1] zien (liet) $\rightarrow$ x2 zien (liet)\\
( Piet liet het boek zien)
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] (name of rule, transformation or filter class) RC: EMPTY 
substitution
\item[* date of creation:]  16-MAR-1987 10:24:17 
\item[* author:] Jan Odijk
\item[* copied from:] REmptysubstitution1
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To substitute EMPTYs as the obj of a aanobjrel/..
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]dna
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In analysis there is a check on the substitution order, which does not exist
in generation.
The check does not exist in generation because the relevant languages 
may differ w.r.t order of substitution, though this difference in substitution
never has any consequences for the meaning. 
In analysis a check on substitution order is made to avoid superfluous 
ambiguities, i.e. to avoid many derivations to which only one meaning 
corresponds. 
\item[\  \ suggested semantics:] Existential Quantification,
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% RULE REmptysubstitution5
                               (*subst of menEMPTY as a subjrel/..*)
< m1: CLAUSE{CLAUSErec1}
	    [ mu1,
	      subjrel/I4::EMPTYVAR{EMPTYVARrec1},
	      mu2
	    ]
SUBST:
  m2: EMPTY(AUX_menemptykey){EMPTYrec1}            (*substituent*)
>

< m : CLAUSE{CLAUSErec1}
            [ mu1,
              subjrel/NP{NPrec1}
                        [head/INDEFPRO{INDEFPROrec1}
                            [head/BINDEFPRO(AUX_MenBIndefprokey){BINDEFPROrec1}]
                        ],
              I2:mu2
            ]
>

   MATCHCONDITIONS
      <
       (* I2: ( (NOT EXIST(mu2,[../EMPTYVAR{}]) ) AND
             (NOT EXIST(mu2,[../VARPREPP{}[I3:mu5]]))
           ) *)   (* substordercond *)
       (* I3: EXIST(mu5, [../EMPTYVAR{}]) *)
       I4: EMPTYVARrec1.index = LEVEL
      >

   PARAMETERS
      <
       LEVEL
      >



      COMP
         <
          C1: EMPTYVARrec1 =
                  { person : 3
                    number : singular
                  }                     AND
              CLAUSErec1.finiteness = finite
          A1: INDEFPROrec1 := AUX_INDEFPROonmen;
              NPrec1 := AUX_NPonmenNDFPR
         >
(*      DECOMP
         <
          C1: INDEFPROrec1 = AUX_INDEFPROonmen AND
              NPrec1 = AUX_NPonmenNDFPR AND
              CLAUSErec1.finiteness = finite 
          A1: WBONUS -1;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
                  { person : 3
                    number : singular
                  };
         >
*)

&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] REmptysubstitution5
\item[* relevant examples:]
x1 viel $\rightarrow$ ze vielen\\
x1 te vallen $\rightarrow$ ze te vallen
These cases will occur if an EMPTY occurs of a subject in some other
language, and the relevant verb cannot be passivized in Dutch.
Example: The beans were spilled $\rightarrow$ ze praatten hun mond voorbij
This is the only case, if the DECOMP part of this rule is removed. 
This rule cannot be motivated by considerations internal to Dutch,
so removing the DECOMP part seems a reasonable step. (not done yet)
The choice for spelling out the EMPTY as {\em ze} is
a rather arbitrary one. Notice that there are potentially problems with
reflexive spelling (How do you know at the moment of spelling out {\em
zich }, how the EMPTY antecedent is going to be spelled out?).
If the EMPTY can be spelled out in more than one way, a problem will arise!
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoClause
\item[* class:] (name of rule, transformation or filter class) RC:Empty 
substitution
\item[* date of creation:]  16-MAR-1987 10:32:12 
\item[* author:] Jan Odijk
\item[* copied from:] REmptysubstitution2
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 13/10/89\ \ \ \ \ author: Lisette Appelo\\
Deleted DECOMP part.
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To substitute EMPTYs as subjrel/..
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] One for finite
clauses, and one for infinitival clauses.
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In analysis there is a check on the substitution order, which does not exist
in generation.
The check does not exist in generation because the relevant languages 
may differ w.r.t order of substitution, though this difference in substitution
never has any consequences for the meaning. 
In analysis a check on substitution order is made to avoid superfluous 
ambiguities, i.e. to avoid many derivations to which only one meaning 
corresponds. 
\item[\  \ suggested semantics:] Existential Quantification
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rprepemptysubst1
< m1:I1::CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                   [ mu2,
                     prepobjrel/VARPREPP{VARPREPPrec1}
                               [ head/PREP(KEY1){PREPrec1},
                                 objrel/I3::EMPTYVAR{EMPTYVARrec1} 
                               ],
                     head/VERB{VERBrec1}[mu3],
                     mu4
                   ],
             mu5
           ] 
SUBST:
m2: EMPTY(AUX_zeroEMPTYkey){EMPTYrec1}
>

< m :I4::CLAUSE{CLAUSErec2}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                   [ mu2,
                     head/VERB{VERBrec1}[mu3],
                     I5:mu4
                   ],
             mu5
           ] 

>

   MATCHCONDITIONS
      <
       I1: CLAUSErec1.synvpefs * AUX_prepEMPTYvps <> []
       m : EXIST(mu2,[prepobjrel/..]) -> 
           CLAUSErec2.synvpefs * AUX_twoprepobjvps <> []  
       m1: EXIST(mu2,[prepobjrel/..]) -> 
           CLAUSErec1.synvpefs * AUX_twoprepobjvps <> []  
       I3: EMPTYVARrec1.index = LEVEL
       I4: CLAUSErec2.synvpefs * AUX_prepEMPTYvps <> []
       I5: NOT EXIST(mu4, [../EMPTYVAR{}]) AND
           NOT EXIST(mu4, [../VARPREPP{}[I51:mu6]])
       I51: EXIST(mu6, [../EMPTYVAR{}])
      >

   PARAMETERS
      <
       LEVEL
      >


<
   SUBRULE
      <mu2: [mu9]>
      <mu2: [mu9]>

   MATCHCONDITIONS
      <
       mu2: NOT EXIST(mu2,[prepobjrel/..])
      >

      COMP
         <
          C1: EMPTYVARrec1 =
               { 
                 person  :  2
                 number  :  singular
               }                         AND
              VARPREPPrec1 =
		  {
		  req          : [pospol,negpol,omegapol]
		  env          : [pospol,negpol,omegapol]
		  mood         : declxpmood
		  actsubcefs   : PREPrec1.subcs
		  synppefs     : [synNP]
		  thetapp      : PREPrec1.thetapp
		  headkey      : PREPrec1.key
		  class        : PREPrec1.class
		  deixis       : PREPrec1.deixis
		  aspect       : PREPrec1.Aspect
		  retro        : PREPrec1.retro
		  superdeixis  : omegadeixis
		  radvkey      : 0
		  stranded     : false
                  specq        : yesspec
		  }                        AND
              KEY1 = VERBrec1.prepkey1 AND
              VERBrec1.prepkey1 <> 0
          A1: CLAUSErec2 := CLAUSErec1;
         >
      DECOMP
         <
          C1: VERBrec1.prepkey1 <> 0
          A1: WBONUS -1;
              KEY1 := VERBrec1.prepkey1;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
               { 
                 person  :  2
                 number  :  singular
               };
              VARPREPPrec1 :=
		  {
		  req          : [pospol,negpol,omegapol]
		  env          : [pospol,negpol,omegapol]
		  mood         : declxpmood
		  actsubcefs   : PREPrec1.subcs
		  synppefs     : [synNP]
		  thetapp      : PREPrec1.thetapp
		  headkey      : PREPrec1.key
		  class        : PREPrec1.class
		  deixis       : PREPrec1.deixis
		  aspect       : PREPrec1.Aspect
		  retro        : PREPrec1.retro
		  superdeixis  : omegadeixis
		  radvkey      : 0
		  stranded     : false
                  specq        : yesspec
		  };
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * AUX_prepemptyvps;

         >
   SUBRULE
      <mu2: [I9:mu9,prepobjrel/T1,I7:mu7]>
      <mu2: [I9:mu9,prepobjrel/T1,I7:mu7]>

   MATCHCONDITIONS
      <
       I9: NOT EXIST(mu9,[prepobjrel/..])
       I7: NOT EXIST(mu7,[prepobjrel/..])
      >

      COMP
         <
          C1: EMPTYVARrec1 =
               { 
                 person  :  2
                 number  :  singular
               }                         AND
              VARPREPPrec1 =
		  {
		  req          : [pospol,negpol,omegapol]
		  env          : [pospol,negpol,omegapol]
		  mood         : declxpmood
		  actsubcefs   : PREPrec1.subcs
		  synppefs     : [synNP]
		  thetapp      : PREPrec1.thetapp
		  headkey      : PREPrec1.key
		  class        : PREPrec1.class
		  deixis       : PREPrec1.deixis
		  aspect       : PREPrec1.Aspect
		  retro        : PREPrec1.retro
		  superdeixis  : omegadeixis
		  radvkey      : 0
		  stranded     : false
                  specq        : yesspec
		  }                        AND
              KEY1 = VERBrec1.prepkey2 AND
              VERBrec1.prepkey2 <> 0
          A1: CLAUSErec2 := CLAUSErec1;
         >
      DECOMP
         <
          C1: VERBrec1.prepkey2 <> 0
          A1: WBONUS -1;
              KEY1 := VERBrec1.prepkey2;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
               { 
                 person  :  2
                 number  :  singular
               };
              VARPREPPrec1 :=
		  {
		  req          : [pospol,negpol,omegapol]
		  env          : [pospol,negpol,omegapol]
		  mood         : declxpmood
		  actsubcefs   : PREPrec1.subcs
		  synppefs     : [synNP]
		  thetapp      : PREPrec1.thetapp
		  headkey      : PREPrec1.key
		  class        : PREPrec1.class
		  deixis       : PREPrec1.deixis
		  aspect       : PREPrec1.Aspect
		  retro        : PREPrec1.retro
		  superdeixis  : omegadeixis
		  radvkey      : 0
		  stranded     : false
                  specq        : yesspec
		  };
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * 
                          (AUX_prepemptyvps * AUX_twoprepobjvps);

         >

>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rprepemptysubst1
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 1-JUL-1988 10:12:01  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rprepemptysubst2
< m1:I1::CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                   [ I2:mu2,
                     prepobjrel/VARPREPP{VARPREPPrec1}
                               [ head/PREP(KEY1){PREPrec1},
                                 objrel/I3::EMPTYVAR{EMPTYVARrec1} 
                               ],
                     prepobjrel/T1,
                     head/VERB{VERBrec1}[mu3],
                     mu4
                   ],
             mu5
           ] 
SUBST:
m2: EMPTY(AUX_zeroEMPTYkey){EMPTYrec1}
>

< m :I4::CLAUSE{CLAUSErec2}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                   [ I2:mu2,
                     prepobjrel/T1,
                     head/VERB{VERBrec1}[mu3],
                     I5:mu4
                   ],
             mu5
           ] 

>

   MATCHCONDITIONS
      <
       I1: CLAUSErec1.synvpefs * AUX_prepEMPTYvps <> []   AND
           CLAUSErec1.synvpefs * AUX_twoprepobjvps <> []  
       I2: NOT EXIST(mu2,[prepobjrel/..])
       I3: EMPTYVARrec1.index = LEVEL
       I4: CLAUSErec2.synvpefs * AUX_prepEMPTYvps <> []   AND
           CLAUSErec2.synvpefs * AUX_twoprepobjvps <> []  
       I5: NOT EXIST(mu4, [../EMPTYVAR{}]) AND
           NOT EXIST(mu4, [../VARPREPP{}[I51:mu6]])
       I51: EXIST(mu6, [../EMPTYVAR{}])
      >

   PARAMETERS
      <
       LEVEL
      >


      COMP
         <
          C1: EMPTYVARrec1 =
               { 
                 person  :  2
                 number  :  singular
               }                         AND
              VARPREPPrec1 =
		  {
		  req          : [pospol,negpol,omegapol]
		  env          : [pospol,negpol,omegapol]
		  mood         : declxpmood
		  actsubcefs   : PREPrec1.subcs
		  synppefs     : [synNP]
		  thetapp      : PREPrec1.thetapp
		  headkey      : PREPrec1.key
		  class        : PREPrec1.class
		  deixis       : PREPrec1.deixis
		  aspect       : PREPrec1.Aspect
		  retro        : PREPrec1.retro
		  superdeixis  : omegadeixis
		  radvkey      : 0
		  stranded     : false
                  specq        : yesspec
		  }                        AND
              KEY1 = VERBrec1.prepkey1 AND
              VERBrec1.prepkey1 <> 0
          A1: CLAUSErec2 := CLAUSErec1;
         >
      DECOMP
         <
          C1: VERBrec1.prepkey1 <> 0
          A1: WBONUS -1;
              KEY1 := VERBrec1.prepkey1;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
               { 
                 person  :  2
                 number  :  singular
               };
              VARPREPPrec1 :=
		  {
		  req          : [pospol,negpol,omegapol]
		  env          : [pospol,negpol,omegapol]
		  mood         : declxpmood
		  actsubcefs   : PREPrec1.subcs
		  synppefs     : [synNP]
		  thetapp      : PREPrec1.thetapp
		  headkey      : PREPrec1.key
		  class        : PREPrec1.class
		  deixis       : PREPrec1.deixis
		  aspect       : PREPrec1.Aspect
		  retro        : PREPrec1.retro
		  superdeixis  : omegadeixis
		  radvkey      : 0
		  stranded     : false
                  specq        : yesspec
		  };
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * 
                              (AUX_prepemptyvps * AUX_twoprepobjvps);

         >

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rprepemptysubst2
\item[* relevant examples:]
hij sprak met emptyvar over x1 -> hij sprak over x1
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 18-JUN-1990 13:09:43  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rdiremptysubst1
< m1:I1::CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                   [ I2:mu2,
                     dirargrel/EMPTYVAR{EMPTYVARrec1},
                     head/VERB{VERBrec1}[mu3],
                     mu4
                   ],
             mu5
           ] 
SUBST:
m2: EMPTY(AUX_zeroEMPTYkey){EMPTYrec1}
>

< m :I4::CLAUSE{CLAUSErec2}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                   [ I2:mu2,
                     head/VERB{VERBrec1}[mu3],
                     I5:mu4
                   ],
             mu5
           ] 

>

   MATCHCONDITIONS
      <
       I1: CLAUSErec1.synvpefs * AUX_dirEMPTYvps <> []
       I2: NOT EXIST(mu2,[dirargrel/..])
       I3: EMPTYVARrec1.index = LEVEL
       I4: CLAUSErec2.synvpefs * AUX_dirEMPTYvps <> []
       I5: NOT EXIST(mu4, [../EMPTYVAR{}]) AND
           NOT EXIST(mu4, [../VARPREPP{}[I51:mu6]])
       I51: EXIST(mu6, [../EMPTYVAR{}])
      >

   PARAMETERS
      <
       LEVEL
      >


      COMP
         <
          C1: EMPTYVARrec1 =
               { 
                 person  :  2
                 number  :  singular
               }                        
          A1: CLAUSErec2 := CLAUSErec1;
         >
      DECOMP
         <
          C1: true
          A1: WBONUS -1;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
               { 
                 person  :  2
                 number  :  singular
               };
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * AUX_diremptyvps;
         >

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rdiremptysubst1
\item[* relevant examples:]
hij bracht het boek EMPTY $\rightarrow$\\
hij bracht het boek
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 1-JUL-1988 10:34:44  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rzeemptysubst
                               (*subst of zeEMPTY as a subjrel/..*)
< m1: CLAUSE{CLAUSErec1}
	    [ mu1,
	      subjrel/I4::EMPTYVAR{EMPTYVARrec1},
	      mu2
	    ]
SUBST:
  m2: EMPTY(AUX_zeemptykey){EMPTYrec1}            (*substituent*)
>

< m : CLAUSE{CLAUSErec1}
            [ mu1,
              subjrel/NP{NPrec1}
                        [head/PERSPRO{PERSPROrec1}
                             [head/BPERSPRO(AUX_ZegenBpersprokey){BPERSPROrec1}]
                        ],
              I2:mu2
            ]
>

   MATCHCONDITIONS
      <
(*       I2: ( (NOT EXIST(mu2,[../EMPTYVAR{}]) ) AND
             (NOT EXIST(mu2,[../VARPREPP{}[I3:mu5]]))
           ) *)   (* substordercond *)
(*       I3: EXIST(mu5, [../EMPTYVAR{}]) *)
       I4: EMPTYVARrec1.index = LEVEL
      >

   PARAMETERS
      <
       LEVEL
      >

      COMP
         <
          C1: EMPTYVARrec1 =
                  { person : 3
                    number : plural
                  }                     
          A1: PERSPROrec1 := AUX_PERSPROOnZegenB;
              NPrec1 := AUX_NPonZegenBprspr
         >
(*      DECOMP
         <
          C1: PERSPROrec1 = AUX_PERSPROonZegenB AND
              NPrec1 = AUX_NPonZegenBprspr 
          A1: WBONUS -1;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
                  { person : 3
                    number : plural
                  };
         >
*)

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rzeemptysubst
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 1-JUL-1988 10:46:29  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 13/10/89\ \ \ \ \ author: Lisette Appelo\\
Deleted DECOMP part.
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}



\newpage
\begin{verbatim}
% RULE RIDEMPTYsubstitution1
                               (* subst in a aan-phrase in AanActives in a 
                                  subordinate clause*)
< m1: I1::CLAUSE{CLAUSErec1}
            [ mu1,
              predrel/VERBP{VERBPrec1}
                  [mu9,
                   complrel/SENTENCE{SENTENCErec1}
                      I8:[ I2:mu2,
                           aanobjrel/VARPREPP{VARPREPPrec1}
                             [ head/PREP(AUX_aanioprepkey){PREPrec1},
                               objrel/I9::EMPTYVAR{EMPTYVARrec1}
                             ],
                            I3:mu3
                         ],
                   mu4 
                  ],
              mu8
            ]
SUBST:
  m2:EMPTY(AUX_menemptykey){EMPTYrec1}                (*substituent*) 
>

< m1: I11::CLAUSE{CLAUSErec2}
            [ mu1,
              predrel/VERBP{VERBPrec1}
                  [mu9,
                   complrel/SENTENCE{SENTENCErec1}
                    I8:[ I2:mu2,
                         I5:mu3
                       ],
                   mu4 
                  ],
              mu8
            ]
>

   MATCHCONDITIONS
      <
       I1: CLAUSErec1.synvpefs * AUX_AanActivevps <> []
       I2: ALL(mu2, I4:rel1/..)
       I3: ALL(mu3, I6:rel2/..)   AND 
           NOT EXIST(mu3, [aanobjrel/..]) 
       I4: rel1 IN AUX_InsideVPAdvRels OR
           QUOTE_srelprec(rel1,predrel)
       I5: ALL(mu3, I10:rel3/..)   AND 
           NOT EXIST(mu3, [aanobjrel/..]) AND
           ( (NOT EXIST(mu3,[../EMPTYVAR{}]) ) AND
             (NOT EXIST(mu3,[../VARPREPP{}[I7:mu5]]))
           )   (* substordercond *)
       I6: rel2 IN AUX_InsideVPArgandVRels OR
           QUOTE_srelprec(predrel,rel2)
       I7: EXIST(mu5, [../EMPTYVAR{}])
       I8: RIGHTTOLEFT
       I9: EMPTYVARrec1.index = LEVEL
       I10: rel3 IN AUX_InsideVPArgandVRels OR
            QUOTE_Srelprec(rel3,predrel)
       I11: CLAUSErec2.synvpefs * AUX_AanActinsubordidvps <> []
      >

   PARAMETERS
      <
       LEVEL
      >



(* *)
      COMP
         <
          C1: EMPTYVARrec1 =
                  { person : 3
                    number : singular
                  }                     AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                  actsubcefs : [aan]
                 }
          A1: CLAUSErec2 := CLAUSErec1;
         >
      DECOMP
         <
          C1: true
          A1: WBONUS -1;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
                  { person : 3
                    number : singular
                  };
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : [aan]
                  specq      : yesspec
                  mood       : declxpmood
 
                 };
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs :=
                    CLAUSErec2.synvpefs * AUX_AanActinsubordidvps;

              (* all other attributes retain their default values *)
         >
&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RIDEMPTYsubstitution1
\item[* relevant examples:]
x2 [[aan x1] zien] (liet) $\rightarrow$ x2 zien (liet)\\
( Piet liet het boek zien)
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] (name of rule, transformation or filter class) RC: EMPTY 
substitution
\item[* date of creation:]  16-MAR-1987 10:24:17 
\item[* author:] Jan Odijk
\item[* copied from:] REmptysubstitution1
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To substitute EMPTYs as the obj of a aanobjrel/..
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]dna
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In analysis there is a check on the substitution order, which does not exist
in generation.
The check does not exist in generation because the relevant languages 
may differ w.r.t order of substitution, though this difference in substitution
never has any consequences for the meaning. 
In analysis a check on substitution order is made to avoid superfluous 
ambiguities, i.e. to avoid many derivations to which only one meaning 
corresponds. 
\item[\  \ suggested semantics:] Existential Quantification,
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% RULE Rsadjemptysubst
                               (*subst of EMPTY as a objrel/..*)
< m1: I1::CLAUSE{CLAUSErec1}
                [ mu1,
                  predrel/VERBP{VERBPrec1}
                         [ mu7, 
                           rel4/ADJP{ADJPrec1}[mu5],
                           mu8
                         ],
                  mu4 
                ]
SUBST:
  m2: EMPTY(AUX_zeroemptykey){EMPTYrec1}            (*substituent*)
>

< m : I9::CLAUSE{CLAUSErec2}
                [ mu1,
                  predrel/VERBP{VERBPrec1}
                         [ mu7, 
                           rel4/ADJP{ADJPrec2}[mu6],
                           mu8
                         ],
                  mu4
                ]
>

   MATCHCONDITIONS
      <
       I1: synzijn  IN CLAUSErec1.synvpefs 
       I9: synzijn IN CLAUSErec2.synvpefs 
      >


   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE
      < mu5: [ I2:mu2, prepobjrel/I10::EMPTYVAR{EMPTYVARrec1}, I3:mu3] >
      < mu6: [ I2:mu2, I5:mu3]>

   MATCHCONDITIONS
      <
       I2: ALL(mu2, I21:rel1/..)
           I21: QUOTE_ADJPrelprec(rel1,prepobjrel) AND rel1 <> prepobjrel
       I3: ALL(mu3, I31:rel2/..)       
       I5: ALL(mu3, I31:rel2/..) AND
           ( (NOT EXIST(mu3,[../EMPTYVAR{}]) ) AND
             (NOT EXIST(mu3,[../VARPREPP{}[I7:mu9]]))
           )   (* substordercond *)
           I31: QUOTE_ADJPrelprec(prepobjrel,rel2) AND rel2 <> prepobjrel
       I7: EXIST(mu9,[../EMPTYVAR{}])
       mu6: RIGHTTOLEFT
       I10: EMPTYVARrec1.index = LEVEL 
      >

      COMP
         <
          C1: ADJPrec1.adjpatternefs * AUX_prepemptyvps <> [] AND
              EMPTYVARrec1 =
                  { person : 2
                    number : singular
                  }                     
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.synvpefs := CLAUSErec1.synvpefs * [synzijn];
              ADJPrec2 := ADJPrec1;
              ADJPrec2.adjpatternefs := 
                       ADJPrec1.adjpatternefs * AUX_prepemptyvps;
         >
      DECOMP
         <
          C1: ADJPrec2.adjpatternefs * AUX_prepemptyvps <> [] 
          A1: WBONUS -1;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
                  { person : 2
                    number : singular
                  };
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * [synzijn];
              ADJPrec1 := ADJPrec2;
              ADJPrec1.adjpatternefs := 
                       ADJPrec2.adjpatternefs * AUX_prepemptyvps;
         >

   SUBRULE (* indobjrel *)
      < mu5: [ I2:mu2, indobjrel/I10::EMPTYVAR{EMPTYVARrec1}, I3:mu3] >
      < mu6: [ I2:mu2, I5:mu3]>

   MATCHCONDITIONS
      <
       I2: ALL(mu2, I21:rel1/..)
           I21: QUOTE_ADJPrelprec(rel1,indobjrel) AND rel1 <> indobjrel
       I3: ALL(mu3, I31:rel2/..)       
       I5: ALL(mu3, I31:rel2/..) AND
           ( (NOT EXIST(mu3,[../EMPTYVAR{}]) ) AND
             (NOT EXIST(mu3,[../VARPREPP{}[I7:mu9]]))
           )   (* substordercond *)
           I31: QUOTE_ADJPrelprec(indobjrel,rel2) AND rel2 <> indobjrel
       I7: EXIST(mu9,[../EMPTYVAR{}])
       mu6: RIGHTTOLEFT
       I10: EMPTYVARrec1.index = LEVEL 
      >

      COMP
         <
          C1: ADJPrec1.adjpatternefs * AUX_emptyindobjvps <> [] AND
              EMPTYVARrec1 =
                  { person : 2
                    number : singular
                  }                     
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.synvpefs := CLAUSErec1.synvpefs * [synzijn];
              ADJPrec2 := ADJPrec1;
              ADJPrec2.adjpatternefs := 
                       ADJPrec1.adjpatternefs * AUX_emptyindobjvps;
         >
      DECOMP
         <
          C1: ADJPrec2.adjpatternefs * AUX_emptyindobjvps <> [] 
          A1: WBONUS -1;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
                  { person : 2
                    number : singular
                  };
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * [synzijn];
              ADJPrec1 := ADJPrec2;
              ADJPrec1.adjpatternefs := 
                       ADJPrec2.adjpatternefs * AUX_emptyindobjvps;
         >

   SUBRULE (* locargrel *)
      < mu5: [ I2:mu2, locargrel/I10::EMPTYVAR{EMPTYVARrec1}, I3:mu3] >
      < mu6: [ I2:mu2, I5:mu3]>

   MATCHCONDITIONS
      <
       I2: ALL(mu2, I21:rel1/..)
           I21: QUOTE_ADJPrelprec(rel1,locargrel) AND rel1 <> locargrel
       I3: ALL(mu3, I31:rel2/..)       
       I5: ALL(mu3, I31:rel2/..) AND
           ( (NOT EXIST(mu3,[../EMPTYVAR{}]) ) AND
             (NOT EXIST(mu3,[../VARPREPP{}[I7:mu9]]))
           )   (* substordercond *)
           I31: QUOTE_ADJPrelprec(locargrel,rel2) AND rel2 <> locargrel
       I7: EXIST(mu9,[../EMPTYVAR{}])
       mu6: RIGHTTOLEFT
       I10: EMPTYVARrec1.index = LEVEL 
      >

      COMP
         <
          C1: ADJPrec1.adjpatternefs * [synLOCEMPTY] <> [] AND
              EMPTYVARrec1 =
                  { person : 2
                    number : singular
                  }                     
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.synvpefs := CLAUSErec1.synvpefs * [synzijn];
              ADJPrec2 := ADJPrec1;
              ADJPrec2.adjpatternefs := 
                       ADJPrec1.adjpatternefs * [synLOCEMPTY];
         >
      DECOMP
         <
          C1: ADJPrec2.adjpatternefs * [synLOCEMPTY] <> [] 
          A1: WBONUS -1;
              EMPTYVARrec1.index := LEVEL;
              EMPTYVARrec1 :=
                  { person : 2
                    number : singular
                  };
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * [synzijn];
              ADJPrec1 := ADJPrec2;
              ADJPrec1.adjpatternefs := 
                       ADJPrec2.adjpatternefs * [synLOCEMPTY];
         >

>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rsadjemptysubst
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 18-FEB-1989 14:01:39  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

%%
E 2
E 1
