
\documentstyle{Rosetta}
\begin{document}
   \RosTopic{General}
   \RosTitle{Notulen linguistenbijeenkomst d.d. 5-11-1987}
   \RosAuthor{Harm Smit}
   \RosDocNr{0239}
   \RosDate{10/11/1987}
   \RosStatus{concept}
   \RosSupersedes{-}
   \RosDistribution{Linguists, Joep Rous}
   \RosClearance{Project}
   \RosKeywords{notulen}
   \MakeRosTitle
%
%

\begin{itemize}
  \item {\bf aanwezig}: Andr\'{e} Schenk, 
             Jan Odijk, Franciska de Jong, 
             Elly van Munster, Harm Smit, Lisette Appelo, Margreet Sanders.
  \item {\bf afwezig}: -.
\end{itemize}

\section{Domein}

\begin{itemize}
  \item Jan O. heeft wijzigingen in het domein aangebracht. Bij CONJSENT is 
        het niveau SENTENCE weg; onder een CONJSENT hangt een CONJ en een 
        CLAUSE, en eventueel een PREP. Het record van een CONJSENT is gelijk 
        aan dat van een SENTENCE, op enkele attributen na, die alleen bij de 
        CONJSENT voorkomen. Deze zijn te herkennen aan de prefigering `conj'. 
  \item Voegwoorden hebben standaard de waarde {\em true} bij het attribuut 
        {\em adverbial}, op {\em dat, om} en {\em of} na, die {\em false}
        zijn.
  \item Franciska heeft m.b.t. de adjectieven nog wat veranderd (n.a.v. de 
        discussie over ergativiteit), en zij heeft nog twee relaties 
        toegevoegd. 
  \item M.b.t. de software-kant wordt opgemerkt dat het wenselijk zou zijn dat
        het systeem bij o.a. {\em laser}opdrachten ook vermeld of het domein 
        al door iemand ge{\em grabbed} is, zodat de gebruiker weet of hij de 
        laatste versie heeft.
\end{itemize}

\section{Verwijzen naar elementen uit de gesloten klassen}

Het zou een stuk prettiger werken wanneer -bij het schrijven van regels- 
stringconstantes konden worden gebruikt. Nu moet vaak naar {\em keys} van
woorden uit de gesloten klassen, zoals PREP, worden 
gezocht.

\section{Gebrek van PASCAL}

Jan O. heeft wederom last gehad van een gebrek van PASCAL: er kan niet met 
{\em sets van sets} worden gewerkt. Dit probleem speelt o.a. bij de
behandeling van {\em er}, waarvan er meerdere samengeklapt kunnen worden. Zo'n 
{\em er} heeft dan een combinatie van de waarden {\em X, P, Q} en {\em L}. Er 
zijn 11 combinaties mogelijk.

Het probleem is op te lossen door alle (in dit geval 11) mogelijke sets als
primitieve waarden te beschouwen, en een functie van {\em primitieve waarde} 
naar {\em set} en een van {\em set} naar  {\em primitieve waarde} te 
defini\"{e}ren.  

\section{Inherente waarden bij NPVAR}

Naast NPVAR lijkt er behoefte aan de categorie BNPVAR (of: NPBVAR), waarbij op 
het ene niveau (BNPVAR) niet en op het andere (NPVAR) wel in de 
attribuutwaarden veranderd mag worden, zodat het BNPVAR een min of meer 
{\em lexicale} status krijgt. Dit betekent wel dat er een hoop veranderd moet 
worden. Lisette oppert dat het misschien beter is alle inherente attributen te 
markeren d.m.v. een prefigering in de attribuut-naam. Dat zou een 
meer principi\"{e}le oplossing zijn voor het algemene probleem dat inherente en 
niet-inherente attributen slecht van elkaar te onderscheiden zijn.

\section{Latex conversie van lijsten met verbpatterns e.d.}

Jan O. heeft een editor gemaakt om lijsten met verpatterns e.d. ook mooi op de 
laserprinter te kunnen krijgen.

\section{Testwoordenboek}

Het testwoordenboek wordt gesplitst in files met verschillende categorie\"{e}n,
zoals: adjectieven, adverbia, nouns, verbs, preposities, particles, etc.

Er zijn taalafhankelijke constraints mogelijk op het woordenboek. Deze zijn 
aan te roepen met: {\em grab dutch:testrecord.pas} en: 
{\em modify dutch:testrecord.pas}.
In deze constraints is gebruik gemaakt van een drietal logische bewerkingen:
\begin{itemize}
   \item IMPLIES ($<$nr$>$,...,...), 
   \item PECULIAR ($<$nr$>$,...), 
   \item MUSTHOLD ($<$nr$>$,...).
\end{itemize}
Met $<$nr$>$ wordt elke constraint uniek benoemd, zodat het programma kan 
aangeven aan welke constraint {\em niet} wordt voldaan.

\section{Automatische Test Procedure}

Jan O. en Harm hebben een automatische test bedacht, zodat bij veranderingen 
aan regels snel kan worden geverifieerd of de aangebrachte verandering op de
juiste gevallen `werkt'. Hiervoor moet het mogelijk zijn de in- en output van 
een testsessie op te slaan. Na het veranderen van de regels kan men dezelfde 
input nogmaals gebruiken en middels het commando {\em diff} kijken of
de nieuwe output verschilt van de oorspronkelijke.

Indien gewenst kan na zo'n vergelijking de nieuwe output opgeslagen worden als 
nieuw resultaat van de testinput.

\end{document}
