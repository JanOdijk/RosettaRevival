$FL 12
$PL 274,16
$LD 5
$OP SH=S,HY=1,la=E,ph=r,pn=c,AN=C
$NP 
$UC _
$SC &%
$AC @
$XC ~`

   

            Project ROSETTA : Machine Translation


            Topic     :  Rosetta3.formalism

    ---------------------------------------------------------







         Title        :  CF Control grammars: Definition of M-PARSER and
                         M-GENERATOR.

         Author       :  J. Rous









         Doc.Nr       :  180

         Date         :  3/3/87

         Status       :  concept

         Supersedes   :  ...

         Distribution :  project

         Clearance    :  project

         Keywords     :  subgrammar, control grammar.
$fn 7

   ---------------------------------------------------------
    
    Philips Research Laboratories

    Copyright (c) Nederlandse Philips Bedrijven B.V.

$ph Rosetta          Doc.nr: 180                       date:3/3/87
$LD 4
$Np 1
$QM
$C1 Preface
The draft for this document has been made almost half a year ago. I postponed
the distribution of the document because I wanted to incorporate the 
formalization of some of the notions described in Lisette/Carel(67),
viz. nested subgrammars and
lexically triggered subgrammars. The fact that I now do distribute the document
does not imply that I have formalized these notions; I merely decided to 
distribute the document without these formalizations.
$NL
The title may suggest that the document is ment as a Rosetta3 proposal for the 
implementation of the notion "Controled M-Grammar". That,
however, is certainly not my intention. The reason for distribution is that 
the idea
of context free control grammars was original ( at least at the time of
invention ) and that it will never be of any use if it remains somewhere
in a dark corner of one of my directories.
$NL 1
There are some major differences between context free control grammars and
control expressions, two of the differences are of a practical nature, whereas
the other one is a theoretical difference. 
The first practical difference is that control expressions are a more 
transparent way
of defining the order of rule applications on the projection path of a
subgrammar than CF control grammars. The set of production rules that defines 
a control grammar is
very difficult to grasp, whereas a control expression can be taken in at 
a glance. The second practical difference is that the definitions of M-PARSER
and M-GENERATOR are simpler and easier to understand in case of
CF control grammars and no new concepts like open derivation trees are needed.
A more theoretical difference is the fact that a control 
expression only defines the order of rule applications within one particular 
subgrammar, whereas a control grammar also establishes links between the 
various subgrammars.
$C1 Introduction
This document is a successor of the documents Joep(40) and Joep(90). In Joep(40)
context free control grammars are introduced. In Joep(90) the subgrammar 
approach as described in Lisette/Carel(67) was incorporated by means of an
extension of the definition of context free control grammars. The consequence
of this approach for the definitions of M-PARSER and M-GENERATOR will be 
treated in this document.
$NL
$C1 CF Control-grammars
As described in Joep(40), a control-grammar can be derived from each arbitrary
M-grammar. Such a control-grammar defines a set of 
syntactic derivation trees of which
the set of well-formed syntactic derivation trees is a subset. 
The production rules of these control-grammars are comparable with the 
so-called
"derivational strategy" described in Lisette/Carel(67). Meanwhile it is
accepted that this
derivational strategy is or should be a part of the top-down design of a 
grammar. The question about how rules work together should be settled _before_ 
the actual rules are written. Strictly speaking, a top-down design should
start with the definition of a derivational strategy on a higher level of
abstraction, using hyper-rules or even sub-rule-classes (cf doc 67). 
$NL
For the description of a strategy on each of these levels a control-grammar 
approach can be used. In this document, however, I will use control grammars
for meaningful M-rules and for transformation rules.
For the reasons described in (67) it is 
convenient to divide an M-grammar in so called subgrammars. For the same 
reasons we can divide a control-grammar into sub-control-grammars.
We will call a control-grammar which is defined by means of a set of 
sub-control-grammars a _C-grammar_. A sub-control-grammar will be called a 
_SC-grammar_. Below I will give the
definition of a C-grammar of which the parse-trees define derivational
strategies in terms of meaningful rules and transformation rules.
$NL 1
_Definition 1._
$NL
A C-grammar G is defined as a 2-tuple <T,U>, 
where U is a set of SC-grammars and T is a subset of U consisting of start 
SC-grammars of G.
$NL 1
_Definition 2._
$NL
A SC-grammar SG is defined as a 4-tuple <V, B, S, R> where
$NL
V is the set of non-terminals, which can be partioned into the sets V%T%
containing only names of transformation rules and V%R% containing names of 
translation relevant rules.
$NL
B is the set of terminals, which can be partitioned into B%T% and B%N%
$NL
B%T% is the set of terminals, which are names of classes of basic-expressions
$NL
B%N% is a set of terminals, which are names of sub-grammars.
$NL
S is the set of start categories, which are names of transformation rules
or translation relevant rules.
$NL
And finally, P is the set of context free production rules.
$NL 1
Furthermore the following conditions must hold : 
$NL 1
1. _A_ SG1 in U:_A_ b in B%N&SG1&:_E_ SG2 in U: b = _SG2_
$NL 1
This condition says that each terminal belonging to the set B%N% of a SC-grammar
SG1 should be the name of an SC-grammmar belonging to the set of SC-grammar
which define the C-grammar.
$NL 2
2. _A_ r->r%1%,...,r%n%, SG: (r in V%T&SG&) => (n = 1)
$NL 1
Condition 2. requires that each transformation rule is a unary rule.
$NL 2
3. The name of a SC-grammars must be unique troughout the complete C-grammar.
$NL 2
_Example_
$NL
Suppose, an SC-grammar G has been defined as follows:
$UM
V%T% = { T%1% }
V%R% = { R%1% }
B%T% = { B%1% }
B%N% = { SG%1% }
P  = {   R%1% -> SG%1% + T%1%,   T%1% -> T%1% | B%1% }
S  = { R%1% }

$QM
This SC-grammar defines parse-trees (to be called strategy trees ) with the 
following structure:
$NL 1
$UM
$RL 7
                             R%1%

                       SG%1%       T%1%
                                   
                                 T%1%

                                 B%1%                         

$QM
Here R%1% is the name of an M-rule, T%1% is the name of a
transformation rule and B%1% is the name of a class of basic expressions.
The derivational strategy corresponding with the control grammar can be 
interpreted as follows. Start with a basic expression of class B%1%. Next, apply
a number of times the transformation rule T%1%. 
And finally, aplly the M-rule R%1% to the results of application of the
sub-grammar SG%1% and  T%1%. Sub-grammar SG%1% has, of course, also a 
derivation strategy of its own. 
$NL
In other words, a non-terminal in a strategy tree, which is the name of a 
meaningful rule or transformation rule, corresponds with application of one 
rule. A terminal which is the name of a SC-grammar corresponds with 
application of the possible derivational strategies defined by that SC-grammar 
and a terminal with the name of a class of basic expressions requires a basic 
expression which is a member of that class.
$NL
$C1 Definitions
It will be obvious that we can use the interpretation of a strategy 
tree, which was given in natural language in the previous chapter, 
for a new definition of M-PARSER and M-GENERATOR. 
$UM

M-PARSER(t, R, i) =%def%

  { d | _E_ r : R in U&G&  and  r in S&R&  and  d in M-PARSER(t, r, R) } +

  { d | _E_ r%1%,...,r%n%, t%1%,...,t%n%, d%1%,...,d%n% :
        R->r%1%,...,r%n% in P&i&  and  d = (R,i)<d%1%,...,d%n%>  and
        _A_j: 1_<_j_<_n : d%j% in M-PARSER(t%j%, r%j%, i) and
        t in F%R%(t%1%,...,t%n%) } +

  { d | _E_ b: R in B%T&i&  and  b in B  and _t_ = b  and  d = (b,i)  and
             b %=&C& R } +

  { d | _E_ r, t%1% : R in V%T&i&  and  
        R->r in P&i&  and  t%1% in F%R%(t)  and
        d in M-PARSER(t%1%, r, i)  } 

$QM
In this definition M-PARSER has three parameters. Parameter t is the
S-tree to which the rules have to be applied. The third parameter, i, is
the name of the current sub-control grammar and, finally, parameter
R is the terminal or non-terminal symbol expected by the current
sub-control grammar i.
$NL
The symbol R can be the name of an SC-grammar, the name of a class of
basic expressions, the name of a meaningful M-rule or the name of a 
transformation rule. For each of these four alternatives M-PARSER
perfoms a different action. 
$NL
1. If R is the name of a SC-grammar, then
M-parser is called again, for each of the elements in the set of
start-symbols of that SC-grammar. 
$NL
2. If R is the name of a meaningful M-rule, M-PARSER applies the corresponding
M-rule to t, and it calls M-PARSER for the results t%i% of this application.
If the SC-grammar is correct, there is a production rule specifying the 
symbols for each t%i%. 
$NL
3. If R is the name of a class of basic expressions then t should be a
basic expression belonging to this class.
$NL
4. If R is the name of a transformation rule, the transformation rule
is applied to t, and M-PARSER is applied to the result.
$NL 2
So, for M-PARSER we have given a compact and transparent definition using the
SC-grammars to control the application of the M-RULES. The definition
of M-GENERATOR can now easily be given:
$UM

M-GENERATOR(d, R, i) =%def%

  { t | _E_ r : R in U&G&  and  r in S&R&  and  t in M-GENERATOR(d, r, R) } +

  { t | _E_ r%1%,...,r%n%, t%1%,...,t%n%, d%1%,...,d%n% :
          R->r%1%,...,r%n% in P&i&  and  d = (R,i)<d%1%,...,d%n%>  and
          _A_j: 1_<_j_<_n : t%j% in M-GENERATOR(d%j%, r%j%, i)  and
          t in F%R%(t%1%,...,t%n%) } +

  { t | _E_b: R in B%T&i&  and  b in B  and  _t_ = b  and  b %=&C& R  and
            d = (b,i)} +

  { t | _E_ r, t%1% : R in V%T&i&  and  
        R->r in P&i&  and  t in F%R%(t%1%)  and
        t%1% in M-GENERATOR(d, r, i)  } 

$QM
It is obvious that this definiton is completly symmetric with respect to the
M-PARSER definition. However.., there is a snake in the grass.
$NL
In principle, rules of the form R->R are allowed in our SC-grammar. But if
R is a transformation rule (alternative 4.), this definition of 
M-GENERATOR causes infinite recursion !!. This is caused by the fact that the
actual transformation rule is applied after the application of M-GENERATOR.
And because the production rule has the form R->R, the parameters for 
M-GENERATOR have the same value as the current parameters.
$NL
This problem can be solved as follows. Because transformation rules are unary 
rules and because a transformation rule can never be the terminal of an 
SC-grammar there will be for each transformation rule T a derivation 
of the form T &*%=>% A, where A is not a transformation rule and where the
derivation sequence contains only transformation rules. For a given
SC-grammar the set of rules that can be derived from a transformation
rule is fixed. We can therefore define the function DERIVABLEFROM which
gives for each transformation rule the set of derivable rules that are
not transformation rules. Furthermore we define a function
A-TRANSFORMS, which applies for a given category A and transformation rule T
all rules in the derivation sequences for T &*%=>% A, containing only 
transformation rules. Using the functions DERIVABLEFROM and A-TRANSFORMS
the M-PARSER can be defined as follows: 

$UM

M-PARSER(t, R, i) =%def%

  { d | _E_ r : R in U&G&  and  r in S&R&  and  d in M-PARSER(t, r, R) } +

  { d | _E_ r%1%,...,r%n%, t%1%,...,t%n%, d%1%,...,d%n% :
        R->r%1%,...,r%n% in P&i&  and  d = (R,i)<d%1%,...,d%n%>  and
        _A_j: 1_<_j_<_n : d%j% in M-PARSER(t%j%, r%j%, i) and
        t in F%R%(t%1%,...,t%n%) } +

  { d | _E_ b: R in B%T&i&  and  b in B  and _t_ = b  and  d = (b,i)  and
             b %=&C& R } +

  { d | _E_ r, t%1%, d%1%,...,d%n% : 
        R in V%T&i&  and  d = r<d%1%,...,d%n%>  and
        r in DERIVABLEFROM(R,i)  and  not r in V%T&i&  and
        d in M-PARSER(t%1%, r, i)  and  t%1% in A-TRANSFORMS(t, R, r, i) }



A-TRANSFORMS(t%1%, R%1%, R%2%, i) =%def%

  { t | _E_ R in V%T&i& :
        R%1% -> R in P&i&  and  v in F%R%(t%1%)  and
        t in A-TRANSFORMS(v, R, R%2%, i) } +

  { t | R%1% = R%2%  and  t = t%1%}
        
$QM
The definition of M-GENERATOR is the reverse of M-PARSER, in the definition
we use the reverse functions of A-TRANSFORMS, viz. G-TRANSFORMS:
$UM

M-GENERATOR(d, R, i) =%def%

  { t | _E_ r : R in U&G&  and  r in S&R&  and  t in M-GENERATOR(d, r, R) } +

  { t | _E_ r%1%,...,r%n%, t%1%,...,t%n%, d%1%,...,d%n% :
          R->r%1%,...,r%n% in P&i&  and  d = (R,i)<d%1%,...,d%n%>  and
          _A_j: 1_<_j_<_n : t%j% in M-GENERATOR(d%j%, r%j%, i)  and
          t in F%R%(t%1%,...,t%n%) } +

  { t | _E_b: R in B%T&i&  and  b in B  and  _t_ = b  and  b %=&C& R  and
            d = (b,i)} +

  { t | _E_ r, t%1%, d%1%,...,d%n% : 
          R in V%T&i&  and  d = r<d%1%,...,d%n%>  and
          r in DERIVABLEFROM(R,i)  and  not r in V%T&i&  and
          t%1% in M-GENERATOR(d, r, i)  and  t in G-TRANSFORMS(t%1%, R, r, i) }



G-TRANSFORMS(t%1%, R%1%, R%2%, i) =%def%

  { t | _E_ R in V%T&i& :
          R -> R%2% in P&i&  and  v in F%R%(t%1%)  and
          t in G-TRANSFORMS(v, R%1%, R, i) } +

  { t | R%1% = R%2%  and  t = t%1% }
        
$QM
The difference between this definition of M-GENERATOR and the previous one
is the fact that this function applies bottom up the M-rules specified in
the derivation tree. However, if the control grammar specifies that at a
specific place in the derivation tree transformation rules can be applied, 
the function G-TRANSFORMS is called in order to apply these transformation
rules as specified by the control grammar. 
$NL
In the previous version of M-GENERATOR the number of 
recursive applications of M-GENERATOR determined how 
often a certain transformation would have to be applied. 
$NL 1
Notice that in practice the first version of the M-PARSER definition can be 
used, the second version has only been given for reasons of symmetry. 
Furthermore, the M-GENERATOR definition can be sligthly simplified. The 
function DERIVABLEFROM has been used inside M-GENERATOR also for reasons of
symmetry only and it therefore can be omitted.
$QM
$C1 Theoretical considerations
In the preface I have already mentioned that there is a major theoretical
difference 
between CF control grammars and control expressions. This difference can 
almost be eliminated by an extension of the definition of control expressions, 
cq subgrammars as specified in document R101.
$NL
At the moment a subgrammar is defined by means of a control expression; a 
regular expression over the alphabet of ruleindices. If we would add for each 
rule index a specification of the imported subgrammars, it would be possible to
generate a SC-grammar from the subgrammar definition. The rule-import 
specification could have the following layout:
$UM

REGULAR EXPRESSION:
[R%1%].{R%2%}.R%3%

RULE IMPORT SPEC:
R%1% :: * + SG%3%
R%2% :: * + SG%1% + SG%2% | * + SG%3% + SG%2% 
R%3% :: BNOUN + VAR

$QM
This RULE IMPORT SPEC says that the first argument of rule R%1% comes
from the current subgrammar ( specified by the "*" symbol ), whereas the second 
argument must come from subgrammar SG%3%. For rule R%2% there are two
alternatives separated by the "|" symbol and rule R%3% needs two basic 
expressions as input. 
$NL 1
Such a specification has the "merits" of both approaches: the flow of
control is specified by means of the regular expression ,whereas the links
between the subgrammars are specified by means of the rule import specification.
$NL 1
A comparison of the efficiency of the M-PARSER and M-GENERATOR algorithms is
very difficult to make. It seems to me that the efficiency of the algorithms
in the case of the control expression approach depends highly on the complexity 
of the control expressions. As the control expressions get more complex it
will take more time to get to the basic building blocks of the expressions:
the rules. The CF control grammar variant does not have this problem, because 
the flow of control is specified by means of a CF grammar. 
$NL
Humans apparently prefer a specification in terms of regular expressions, 
whereas it seems that a context free grammar specification is more suitable
for computers.
