h46702
s 02420/00001/00000
d D 1.2 92/02/21 15:48:55 rous 2 1
c 
e
s 00001/00000/00000
d D 1.1 92/02/11 11:50:06 rous 1 0
c date and time created 92/02/11 11:50:06 by rous
e
u
U
f e 0
t
T
I 1
D 2
 
E 2
I 2
DUTCH 98

&

\newpage
\begin{verbatim}
%
% TRANSFORMATION RVerbpattern9
< m1: VERBPPROP{VERBPPROPrec1}[ mu1,
                                predrel/VERBP{VERBPrec1}
                                        [ argrel/SENTENCEVAR{SENTENCEVARrec1},
                                          argrel/T1,
                                          head/VERB{VERBrec1}[mu2]
                                        ] 
                              ]
>

< m : VERBPPROP{VERBPPROPrec2}
               [ mu1,
                 predrel/VERBP{VERBPrec1}
                        [ indobjrel/T2,
                          objrel/NP{NPrec1}
                               [ head/PERSPRO{PERSPROrec1}
                                  [head/BPERSPRO(AUX_hetbpersprokey){BPERSPROrec1}]
                               ],
                          complrel/SENTENCEVAR{SENTENCEVARrec1},
                          head/VERB{VERBrec1}[mu2]
                        ]
               ]
>
(*  *)
<
   SUBRULE (*1a *)
      < T1:NPVAR{NPVARrec1} >
      < T2:NPVAR{NPVARrec2} >

      COMP
         <
          C1: synIONP_HETTHATSENT IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : finite
			 } AND
              NPVARrec1.cases = [Nominative]
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synIONP_HETTHATSENT];
              PERSPROrec1 := COPYT_bpersproTOperspro(BPERSPROrec1);
              PERSPROrec1.reduced := false;
             (* persprocases retains its default value *)
              NPVARrec2 := NPVARrec1;
              NPVARrec2.cases := [Dative];
              NPrec1 := AUX_NPonhetBPRSPR;
         >
      DECOMP
         <
          C1: synIONP_HETTHATSENT IN VERBrec1.synvps AND
              synIONP_HETTHATSENT IN VERBPPROPrec2.synvpefs AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : finite
			 } AND
              Dative IN NPVARrec2.cases AND
              NPrec1 = AUX_NPonhetBPRSPR AND
              PERSPROrec1 = COPYT_bpersproTOperspro(BPERSPROrec1)
            (* no check on the attribute reduced, so that both the reduced
               AND the unreduced version are accepted *)
          A1: NPVARrec1 := NPVARrec2;
              NPVARrec1.cases := [Nominative];
              VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >


   SUBRULE (*1b *)
      < T1:CNVAR{CNVARrec1} >
      < T2:CNVAR{CNVARrec2} >

      COMP
         <
          C1: synIONP_HETTHATSENT IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : finite
			 } AND
              CNVARrec1.cases = [Nominative]
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synIONP_HETTHATSENT];
              PERSPROrec1 := COPYT_bpersproTOperspro(BPERSPROrec1);
              PERSPROrec1.reduced := false;
             (* persprocases retains its default value *)
              CNVARrec2 := CNVARrec1;
              CNVARrec2.cases := [Dative];
              NPrec1 := AUX_NPonhetBPRSPR;
         >
      DECOMP
         <
          C1: synIONP_HETTHATSENT IN VERBrec1.synvps AND
              synIONP_HETTHATSENT IN VERBPPROPrec2.synvpefs AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : finite
			 } AND
              Dative IN CNVARrec2.cases AND
              NPrec1 = AUX_NPonhetBPRSPR AND
              PERSPROrec1 = COPYT_bpersproTOperspro(BPERSPROrec1)
            (* no check on the attribute reduced, so that both the reduced
               AND the unreduced version are accepted *)
          A1: CNVARrec1 := CNVARrec2;
              CNVARrec1.cases := [Nominative];
              VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

(*  *)
   SUBRULE (* 2 *)
      < T1:EMPTYVAR{EMPTYVARrec1} >
      < T2:EMPTYVAR{EMPTYVARrec1} >
      COMP
         <
          C1: synEMPTY_HETTHATSENT IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : finite
			 } 
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synEMPTY_HETTHATSENT];
              PERSPROrec1 := COPYT_bpersproTOperspro(BPERSPROrec1);
              PERSPROrec1.reduced := false;
             (* persprocases retains its default value *)
              NPrec1 := AUX_NPonhetBPRSPR;
         >
      DECOMP
         <
          C1: synEMPTY_HETTHATSENT IN VERBrec1.synvps AND
              synEMPTY_HETTHATSENT IN VERBPPROPrec2.synvpefs AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : finite
			 } AND
              NPrec1 = AUX_NPonhetBPRSPR AND
              PERSPROrec1 = COPYT_bpersproTOperspro(BPERSPROrec1)
            (* no check on the attribute reduced, so that both the reduced
               AND the unreduced version are accepted *)
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

(*  *)
   SUBRULE (*3a *)
      < T1:NPVAR{NPVARrec1}>
      < T2:NPVAR{NPVARrec2}>

      COMP
         <
          C1: synIONP_HETOPENOMTESENT IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          infsort     : omteinf
                          PROsubject  : true
			 } AND
              NPVARrec1.cases = [Nominative]
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synIONP_HETOPENOMTESENT];
              PERSPROrec1 := COPYT_bpersproTOperspro(BPERSPROrec1);
              PERSPROrec1.reduced := false;
             (* persprocases retains its default value *)
              NPVARrec2 := NPVARrec1;
              NPVARrec2.cases := [Dative];
              NPrec1 := AUX_NPonhetBPRSPR;
         >
      DECOMP
         <
          C1: synIONP_HETOPENOMTESENT IN VERBrec1.synvps AND
              synIONP_HETOPENOMTESENT IN VERBPPROPrec2.synvpefs AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          infsort     : omteinf
                          PROsubject  : true
			 } AND
              Dative IN NPVARrec2.cases AND
              NPrec1 = AUX_NPonhetBPRSPR AND
              PERSPROrec1 = COPYT_bpersproTOperspro(BPERSPROrec1)
            (* no check on the attribute reduced, so that both the reduced
               AND the unreduced version are accepted *)
          A1: NPVARrec1 := NPVARrec2;
              NPVARrec1.cases := [Nominative];
              VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

(*  *)
   SUBRULE (*3b *)
      < T1:CNVAR{CNVARrec1}>
      < T2:CNVAR{CNVARrec2}>

      COMP
         <
          C1: synIONP_HETOPENOMTESENT IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          infsort     : omteinf
                          PROsubject  : true
			 } AND
              CNVARrec1.cases = [Nominative]
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synIONP_HETOPENOMTESENT];
              PERSPROrec1 := COPYT_bpersproTOperspro(BPERSPROrec1);
              PERSPROrec1.reduced := false;
             (* persprocases retains its default value *)
              CNVARrec2 := CNVARrec1;
              CNVARrec2.cases := [Dative];
              NPrec1 := AUX_NPonhetBPRSPR;
         >
      DECOMP
         <
          C1: synIONP_HETOPENOMTESENT IN VERBrec1.synvps AND
              synIONP_HETOPENOMTESENT IN VERBPPROPrec2.synvpefs AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          infsort     : omteinf
                          PROsubject  : true
			 } AND
              Dative IN CNVARrec2.cases AND
              NPrec1 = AUX_NPonhetBPRSPR AND
              PERSPROrec1 = COPYT_bpersproTOperspro(BPERSPROrec1)
            (* no check on the attribute reduced, so that both the reduced
               AND the unreduced version are accepted *)
          A1: CNVARrec1 := CNVARrec2;
              CNVARrec1.cases := [Nominative];
              VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

(*  *)
   SUBRULE (* 4 *)
      < T1:EMPTYVAR{EMPTYVARrec1} >
      < T2:EMPTYVAR{EMPTYVARrec1} >
      COMP
         <
          C1: synEMPTY_HETOPENOMTESENT IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          infsort     : omteinf
                          PROsubject  : true
			 } 
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synEMPTY_HETOPENOMTESENT];
              PERSPROrec1 := COPYT_bpersproTOperspro(BPERSPROrec1);
              PERSPROrec1.reduced := false;
             (* persprocases retains its default value *)
              NPrec1 := AUX_NPonhetBPRSPR;
         >
      DECOMP
         <
          C1: synEMPTY_HETOPENOMTESENT IN VERBrec1.synvps AND
              synEMPTY_HETOPENOMTESENT IN VERBPPROPrec2.synvpefs AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : finite
                          infsort     : omteinf
			 } AND
              NPrec1 = AUX_NPonhetBPRSPR AND
              PERSPROrec1 = COPYT_bpersproTOperspro(BPERSPROrec1)
            (* no check on the attribute reduced, so that both the reduced
               AND the unreduced version are accepted *)
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

(*  *)
   SUBRULE (*5a *)
      < T1:NPVAR{NPVARrec1}>
      < T2:NPVAR{NPVARrec2}>

      COMP
         <
          C1: synIONP_HETOPENTESENT IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          infsort     : omteinf
                          PROsubject  : true
			 } AND
              NPVARrec1.cases = [Nominative]
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synIONP_HETOPENTESENT];
              PERSPROrec1 := COPYT_bpersproTOperspro(BPERSPROrec1);
              PERSPROrec1.reduced := false;
             (* persprocases retains its default value *)
              NPVARrec2 := NPVARrec1;
              NPVARrec2.cases := [Dative];
              NPrec1 := AUX_NPonhetBPRSPR;
         >
      DECOMP
         <
          C1: synIONP_HETOPENTESENT IN VERBrec1.synvps AND
              synIONP_HETOPENTESENT IN VERBPPROPrec2.synvpefs AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          infsort     : omteinf
                          PROsubject  : true
			 } AND
              Dative IN NPVARrec2.cases AND
              NPrec1 = AUX_NPonhetBPRSPR AND
              PERSPROrec1 = COPYT_bpersproTOperspro(BPERSPROrec1)
            (* no check on the attribute reduced, so that both the reduced
               AND the unreduced version are accepted *)
          A1: NPVARrec1 := NPVARrec2;
              NPVARrec1.cases := [Nominative];
              VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

(*  *)
   SUBRULE (*5b *)
      < T1:CNVAR{CNVARrec1}>
      < T2:CNVAR{CNVARrec2}>

      COMP
         <
          C1: synIONP_HETOPENTESENT IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          infsort     : omteinf
                          PROsubject  : true
			 } AND
              CNVARrec1.cases = [Nominative]
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synIONP_HETOPENTESENT];
              PERSPROrec1 := COPYT_bpersproTOperspro(BPERSPROrec1);
              PERSPROrec1.reduced := false;
             (* persprocases retains its default value *)
              CNVARrec2 := CNVARrec1;
              CNVARrec2.cases := [Dative];
              NPrec1 := AUX_NPonhetBPRSPR;
         >
      DECOMP
         <
          C1: synIONP_HETOPENTESENT IN VERBrec1.synvps AND
              synIONP_HETOPENTESENT IN VERBPPROPrec2.synvpefs AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          infsort     : omteinf
                          PROsubject  : true
			 } AND
              Dative IN CNVARrec2.cases AND
              NPrec1 = AUX_NPonhetBPRSPR AND
              PERSPROrec1 = COPYT_bpersproTOperspro(BPERSPROrec1)
            (* no check on the attribute reduced, so that both the reduced
               AND the unreduced version are accepted *)
          A1: CNVARrec1 := CNVARrec2;
              CNVARrec1.cases := [Nominative];
              VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

(*  *)
   SUBRULE (* 6 *)
      < T1:EMPTYVAR{EMPTYVARrec1} >
      < T2:EMPTYVAR{EMPTYVARrec1} >
      COMP
         <
          C1: synEMPTY_HETOPENTESENT IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : infinite
                          infsort     : omteinf
                          PROsubject  : true
			 } 
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synEMPTY_HETOPENTESENT];
              PERSPROrec1 := COPYT_bpersproTOperspro(BPERSPROrec1);
              PERSPROrec1.reduced := false;
             (* persprocases retains its default value *)
              NPrec1 := AUX_NPonhetBPRSPR;
         >
      DECOMP
         <
          C1: synEMPTY_HETOPENTESENT IN VERBrec1.synvps AND
              synEMPTY_HETOPENTESENT IN VERBPPROPrec2.synvpefs AND
              SENTENCEVARrec1 =
			 {
			  mood        : declarative
			  senttype    : subordinateclause
			  finiteness  : finite
                          infsort     : omteinf
			 } AND
              NPrec1 = AUX_NPonhetBPRSPR AND
              PERSPROrec1 = COPYT_bpersproTOperspro(BPERSPROrec1)
            (* no check on the attribute reduced, so that both the reduced
               AND the unreduced version are accepted *)
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

   SUBRULE (*7a *)
      < T1:NPVAR{NPVARrec1} >
      < T2:NPVAR{NPVARrec2} >

      COMP
         <
          C1: synIONP_HETQSENT IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              SENTENCEVARrec1 =
			 {
			  senttype    : subordinateclause
			  finiteness  : finite
			 } AND
              SENTENCEVARRec1.mood IN [yesnointerrogative, whinterrogative] AND
              NPVARrec1.cases = [Nominative]
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synIONP_HETQSENT];
              PERSPROrec1 := COPYT_bpersproTOperspro(BPERSPROrec1);
              PERSPROrec1.reduced := false;
             (* persprocases retains its default value *)
              NPVARrec2 := NPVARrec1;
              NPVARrec2.cases := [Dative];
              NPrec1 := AUX_NPonhetBPRSPR;
         >
      DECOMP
         <
          C1: synIONP_HETQSENT IN VERBrec1.synvps AND
              synIONP_HETQSENT IN VERBPPROPrec2.synvpefs AND
              SENTENCEVARrec1 =
			 {
			  senttype    : subordinateclause
			  finiteness  : finite
			 } AND
              SENTENCEVARRec1.mood IN [yesnointerrogative, whinterrogative] AND
              Dative IN NPVARrec2.cases AND
              NPrec1 = AUX_NPonhetBPRSPR AND
              PERSPROrec1 = COPYT_bpersproTOperspro(BPERSPROrec1)
            (* no check on the attribute reduced, so that both the reduced
               AND the unreduced version are accepted *)
          A1: NPVARrec1 := NPVARrec2;
              NPVARrec1.cases := [Nominative];
              VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >


   SUBRULE (*7b *)
      < T1:CNVAR{CNVARrec1} >
      < T2:CNVAR{CNVARrec2} >

      COMP
         <
          C1: synIONP_HETQSENT IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              SENTENCEVARrec1 =
			 {
			  senttype    : subordinateclause
			  finiteness  : finite
			 } AND
              SENTENCEVARRec1.mood IN [yesnointerrogative, whinterrogative] AND
              CNVARrec1.cases = [Nominative]
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synIONP_HETQSENT];
              PERSPROrec1 := COPYT_bpersproTOperspro(BPERSPROrec1);
              PERSPROrec1.reduced := false;
             (* persprocases retains its default value *)
              CNVARrec2 := CNVARrec1;
              CNVARrec2.cases := [Dative];
              NPrec1 := AUX_NPonhetBPRSPR;
         >
      DECOMP
         <
          C1: synIONP_HETQSENT IN VERBrec1.synvps AND
              synIONP_HETQSENT IN VERBPPROPrec2.synvpefs AND
              SENTENCEVARrec1 =
			 {
			  senttype    : subordinateclause
			  finiteness  : finite
			 } AND
              SENTENCEVARRec1.mood IN [yesnointerrogative, whinterrogative] AND
              Dative IN CNVARrec2.cases AND
              NPrec1 = AUX_NPonhetBPRSPR AND
              PERSPROrec1 = COPYT_bpersproTOperspro(BPERSPROrec1)
            (* no check on the attribute reduced, so that both the reduced
               AND the unreduced version are accepted *)
          A1: CNVARrec1 := CNVARrec2;
              CNVARrec1.cases := [Nominative];
              VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >


   SUBRULE (*7c *)
      < T1:EMPTYVAR{EMPTYVARrec1} >
      < T2:EMPTYVAR{EMPTYVARrec1} >

      COMP
         <
          C1: synIOEMPTY_HETQSENT IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              SENTENCEVARrec1 =
			 {
			  senttype    : subordinateclause
			  finiteness  : finite
			 } AND
              SENTENCEVARRec1.mood IN [yesnointerrogative, whinterrogative] 
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synIOEMPTY_HETQSENT];
              PERSPROrec1 := COPYT_bpersproTOperspro(BPERSPROrec1);
              PERSPROrec1.reduced := false;
             (* persprocases retains its default value *)
              NPrec1 := AUX_NPonhetBPRSPR;
         >
      DECOMP
         <
          C1: synIOEMPTY_HETQSENT IN VERBrec1.synvps AND
              synIOEMPTY_HETQSENT IN VERBPPROPrec2.synvpefs AND
              SENTENCEVARrec1 =
			 {
			  senttype    : subordinateclause
			  finiteness  : finite
			 } AND
              SENTENCEVARRec1.mood IN [yesnointerrogative, whinterrogative] AND
              NPrec1 = AUX_NPonhetBPRSPR AND
              PERSPROrec1 = COPYT_bpersproTOperspro(BPERSPROrec1)
            (* no check on the attribute reduced, so that both the reduced
               AND the unreduced version are accepted *)
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >


>
&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RVerbpattern9
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] Verbppropformation
\item[* class:] (name of rule, transformation or filter class) TC:
Verbpatternrules
\item[* date of creation:] 9-JAN-1987 14:40:53  
\item[* author:] Jan Odijk
\item[* copied from:] RVerbpattern2
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In analysis both {\em het} and {\em 't} are accepted. In generation only
{\em het} is generated.
\item[\  \ suggested semantics:] dna
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% TRANSFORMATION RVerbpattern10
< m1: VERBPPROP{VERBPPROPrec1}
               [ mu1,
                 predrel/VERBP{VERBPrec1}
                        [ argrel/T1,
                          argrel/NPPROPVAR{NPPROPVARrec1},
                          head/VERB{VERBrec1}[mu2]
                        ] 
               ]
>

< m : VERBPPROP{VERBPPROPrec2}
               [ mu1,
                 predrel/VERBP{VERBPrec1}
                        [ objrel/T1,
                          prepobjrel/VARPREPP{VARPREPPrec1}
                                   [ head/PREP(VERBrec1.prepkey1){PREPrec1},
                                     objrel/NPPROPVAR{NPPROPVARrec1}
                                   ],
                          head/VERB{VERBrec1}[mu2]
                        ] 
               ]
>
(*  *)
<
   SUBRULE (* 1a *)
      < T1:NPVAR{NPVARrec1} >
      < T1:NPVAR{NPVARrec1} >
      COMP
         <
          C1: synDONP_PREPOPENNPPROP IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              NPPROPVARrec1.PROsubject = true
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synDONP_PREPOPENNPPROP];
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
   
         >
      DECOMP
         <
          C1: synDONP_PREPOPENNPPROP IN VERBrec1.synvps AND
              synDONP_PREPOPENNPPROP IN VERBPPROPrec2.synvpefs AND
              PREPrec1.key = VERBrec1.prepkey1 AND
              NPPROPVARrec1.PROsubject = true AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> [] 
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >
(*  *)
   SUBRULE (* 1b *)
      < T1:CNVAR{CNVARrec1} >
      < T1:CNVAR{CNVARrec1} >
      COMP
         <
          C1: synDONP_PREPOPENNPPROP IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              NPPROPVARrec1.PROsubject = true
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synDONP_PREPOPENNPPROP];
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
         >
      DECOMP
         <
          C1: synDONP_PREPOPENNPPROP IN VERBrec1.synvps AND
              synDONP_PREPOPENNPPROP IN VERBPPROPrec2.synvpefs AND
              PREPrec1.key = VERBrec1.prepkey1 AND
              NPPROPVARrec1.PROsubject = true AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> [] 
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

>
&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RVerbpattern10
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] Verbppropformation
\item[* class:] (name of rule, transformation or filter class)TC: 
Verbpatternrules
\item[* date of creation:] 9-JAN-1987 15:17:55  
\item[* author:] Jan Odijk
\item[* copied from:] --
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% TRANSFORMATION RVerbpattern11
< m1: VERBPPROP{VERBPPROPrec1}
               [ mu1,
                 predrel/VERBP{VERBPrec1}
                        [ argrel/T1,
                          argrel/ADJPPROPVAR{ADJPPROPVARrec1},
                          head/VERB{VERBrec1}[mu2]
                        ] 
               ]
>

< m : VERBPPROP{VERBPPROPrec2}
               [ mu1,
                 predrel/VERBP{VERBPrec1}
                        [ indobjrel/T2,
                          prepobjrel/VARPREPP{VARPREPPrec1}
                                   [ head/PREP(VERBrec1.prepkey1){PREPrec1},
                                     objrel/ADJPPROPVAR{ADJPPROPVARrec1}
                                   ],
                          head/VERB{VERBrec1}[mu2]
                        ] 
               ]
>
(*  *)
<
   SUBRULE (* 1a *)
      < T1:NPVAR{NPVARrec1} >
      < T2:NPVAR{NPVARrec3} >
      COMP
         <
          C1: synIONP_PREPCLOSEDADJPPROP IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              ADJPPROPVARrec1.PROsubject = false  AND
              NPVARrec1.cases = [Nominative]
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synIONP_PREPCLOSEDADJPPROP];
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synCLOSEDADJPPROP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              NPVARrec3 := NPVARrec1;
              NPVARrec3.cases := [Dative];
         >
      DECOMP
         <
          C1: synIONP_PREPCLOSEDADJPPROP IN VERBrec1.synvps AND
              synIONP_PREPCLOSEDADJPPROP IN VERBPPROPrec2.synvpefs AND
              PREPrec1.key = VERBrec1.prepkey1 AND
              ADJPPROPVARrec1.PROsubject = false AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synCLOSEDADJPPROP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> [] AND
              Dative IN NPVARrec3.cases
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := [];
              NPVARrec1 := NPVARrec3;
              NPVARrec1.cases := [Nominative];
         >
(* 1 *)
   SUBRULE (* 1b *)
      < T1:CNVAR{CNVARrec1} >
      < T2:CNVAR{CNVARrec3} >
      COMP
         <
          C1: synIONP_PREPCLOSEDADJPPROP IN VERBrec1.synvps AND
              VERBPPROPrec1.synvpefs = [] AND
              ADJPPROPVARrec1.PROsubject = false  AND
              CNVARrec1.cases = [Nominative]
          A1: VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synIONP_PREPCLOSEDADJPPROP];
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synCLOSEDADJPPROP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              CNVARrec3 := CNVARrec1;
              CNVARrec3.cases := [Dative];
         >
      DECOMP
         <
          C1: synIONP_PREPCLOSEDADJPPROP IN VERBrec1.synvps AND
              synIONP_PREPCLOSEDADJPPROP IN VERBPPROPrec2.synvpefs AND
              PREPrec1.key = VERBrec1.prepkey1 AND
              ADJPPROPVARrec1.PROsubject = false AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synCLOSEDADJPPROP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> [] AND
              Dative IN CNVARrec3.cases
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := [];
              CNVARrec1 := CNVARrec3;
              CNVARrec1.cases := [Nominative];
         >
>
&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RVerbpattern11
\item[* relevant examples:] See list
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] Verbppropformation
\item[* class:] (name of rule, transformation or filter class) TC: 
VErbppropformation
\item[* date of creation:] 9-JAN-1987 15:39:23  
\item[* author:] Jan Odijk
\item[* copied from:] RVerbpattern10
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:] dna
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% TRANSFORMATION RVerbpattern12
< m1:VERBPPROP{VERBPPROPrec1}
              [ mu1,
                predrel/VERBP{VERBPrec1}
                       [ argrel/T1,
                         argrel/T2,
                         head/VERB{VERBrec1}[mu2]
                       ] 
              ]
>

< m :VERBPPROP{VERBPPROPrec2}
              [ mu1,
                predrel/VERBP{VERBPrec1}
                       [ objrel/T1,
                         prepobjrel/VARPREPP{VARPREPPrec1}
                                   [ head/PREP(VERBrec1.prepkey1){PREPrec1},
                                     objrel/T2
                                   ],
                         head/VERB{VERBrec1}[mu2]
                       ] 
              ]
>

(*  *)
<
   SUBRULE (* 1a *)
      < 
       T1 : NPVAR{NPVARrec1}
       T2 : NPVAR{NPVARrec2}
      >
      < 
       T1 : NPVAR{NPVARrec1} 
       T2 : NPVAR{NPVARrec2}
      >

      COMP
         <
          C1: (synDONP_PREPNP IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )
          A1: 
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : NPVARrec2.specq
                  mood       : NPVARrec2.mood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synDONP_PREPNP]
         >
      DECOMP
         <
          C1: (synDONP_PREPNP IN VERBrec1.synvps) AND
              (synDONP_PREPNP IN VERBPPROPrec2.synvpefs ) AND
              (PREPrec1.key = VERBrec1.prepkey1) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : NPVARrec2.specq
                  mood       : NPVARrec2.mood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> [] 
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >
(*  *)
   SUBRULE (* 1b *)
      < 
       T1 : CNVAR{CNVARrec1}
       T2 : NPVAR{NPVARrec2}
      >
      < 
       T1 : CNVAR{CNVARrec1} 
       T2 : NPVAR{NPVARrec2}
      >

      COMP
         <
          C1: (synDONP_PREPNP IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )
          A1: 
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : NPVARrec2.specq
                  mood       : NPVARrec2.mood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synDONP_PREPNP]
         >
      DECOMP
         <
          C1: (synDONP_PREPNP IN VERBrec1.synvps) AND
              (synDONP_PREPNP IN VERBPPROPrec2.synvpefs ) AND
              (PREPrec1.key = VERBrec1.prepkey1) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : NPVARrec2.specq
                  mood       : NPVARrec2.mood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> [] 
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >
(*  *)
   SUBRULE (* 1c *)
      < 
       T1 : NPVAR{NPVARrec1}
       T2 : CNVAR{CNVARrec2}
      >
      < 
       T1 : NPVAR{NPVARrec1} 
       T2 : CNVAR{CNVARrec2}
      >

      COMP
         <
          C1: (synDONP_PREPNP IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )
          A1:
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synDONP_PREPNP]
         >
      DECOMP
         <
          C1: (synDONP_PREPNP IN VERBrec1.synvps) AND
              (synDONP_PREPNP IN VERBPPROPrec2.synvpefs ) AND
              (PREPrec1.key = VERBrec1.prepkey1) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> []     
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >
(*  *)
   SUBRULE (* 1d *)
      < 
       T1 : CNVAR{CNVARrec1}
       T2 : CNVAR{CNVARrec2}
      >
      < 
       T1 : CNVAR{CNVARrec1} 
       T2 : CNVAR{CNVARrec2}
      >

      COMP
         <
          C1: (synDONP_PREPNP IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )
          A1: 
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synDONP_PREPNP]
         >
      DECOMP
         <
          C1: (synDONP_PREPNP IN VERBrec1.synvps) AND
              (synDONP_PREPNP IN VERBPPROPrec2.synvpefs ) AND
              (PREPrec1.key = VERBrec1.prepkey1) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> []        
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

   SUBRULE (* 1ce *)
      < 
       T1 : NPVAR{NPVARrec1}
       T2 : EMPTYVAR{EMPTYVARrec1}
      >
      < 
       T1 : NPVAR{NPVARrec1} 
       T2 : EMPTYVAR{EMPTYVARrec1}
      >

      COMP
         <
          C1: (synDONP_PREPEMPTY IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )
          A1:
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synDONP_PREPEMPTY]
         >
      DECOMP
         <
          C1: (synDONP_PREPEMPTY IN VERBrec1.synvps) AND
              (synDONP_PREPEMPTY IN VERBPPROPrec2.synvpefs ) AND
              (PREPrec1.key = VERBrec1.prepkey1) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> []     
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >
(*  *)
   SUBRULE (* 1de *)
      < 
       T1 : CNVAR{CNVARrec1}
       T2 : EMPTYVAR{EMPTYVARrec1}
      >
      < 
       T1 : CNVAR{CNVARrec1} 
       T2 : EMPTYVAR{EMPTYVARrec1}
      >

      COMP
         <
          C1: (synDONP_PREPEMPTY IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )
          A1: 
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synDONP_PREPEMPTY]
         >
      DECOMP
         <
          C1: (synDONP_PREPEMPTY IN VERBrec1.synvps) AND
              (synDONP_PREPEMPTY IN VERBPPROPrec2.synvpefs ) AND
              (PREPrec1.key = VERBrec1.prepkey1) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> []        
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

(*  *)
   SUBRULE (* 1ee *)
      < 
       T1 : EMPTYVAR{EMPTYVARrec1}
       T2 : EMPTYVAR{EMPTYVARrec2}
      >
      < 
       T1 : EMPTYVAR{EMPTYVARrec1} 
       T2 : EMPTYVAR{EMPTYVARrec2}
      >

      COMP
         <
          C1: (synEMPTY_PREPEMPTY IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )
          A1: 
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synEMPTY_PREPEMPTY]
         >
      DECOMP
         <
          C1: (synEMPTY_PREPEMPTY IN VERBrec1.synvps) AND
              (synEMPTY_PREPEMPTY IN VERBPPROPrec2.synvpefs ) AND
              (PREPrec1.key = VERBrec1.prepkey1) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> []        
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

(*  *)
   SUBRULE (* 1ea *)
      < 
       T1 : EMPTYVAR{EMPTYVARrec1}
       T2 : NPVAR{NPVARrec2}
      >
      < 
       T1 : EMPTYVAR{EMPTYVARrec1} 
       T2 : NPVAR{NPVARrec2}
      >

      COMP
         <
          C1: (synEMPTY_PREPNP IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )
          A1: 
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : NPVARrec2.specq
                  mood       : NPVARrec2.mood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synEMPTY_PREPNP]
         >
      DECOMP
         <
          C1: (synEMPTY_PREPNP IN VERBrec1.synvps) AND
              (synEMPTY_PREPNP IN VERBPPROPrec2.synvpefs ) AND
              (PREPrec1.key = VERBrec1.prepkey1) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : NPVARrec2.specq
                  mood       : NPVARrec2.mood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> [] 
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

(*  *)
   SUBRULE (* 1eb *)
      < 
       T1 : EMPTYVAR{EMPTYVARrec1}
       T2 : CNVAR{CNVARrec2}
      >
      < 
       T1 : EMPTYVAR{EMPTYVARrec1} 
       T2 : CNVAR{CNVARrec2}
      >

      COMP
         <
          C1: (synEMPTY_PREPNP IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )
          A1: 
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synEMPTY_PREPNP]
         >
      DECOMP
         <
          C1: (synEMPTY_PREPNP IN VERBrec1.synvps) AND
              (synEMPTY_PREPNP IN VERBPPROPrec2.synvpefs ) AND
              (PREPrec1.key = VERBrec1.prepkey1) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> [] 
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >


SUBRULE (* 1-p *)
      < 
       T1 : T3
       T2 : PROSENTVAR{PROSENTVARrec1}
      >
      < 
       T1 : T3
       T2 : PROSENTVAR{PROSENTVARrec1}
      >

   MATCHCONDITIONS
      <
       T1: T3.CAT IN [NPVAR,CNVAR]
      >


      COMP
         <
          C1: (synDONP_PREPPROSENT IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )           AND
              PROSENTVARrec1.so = false
          A1:
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synDONP_PREPPROSENT]
         >
      DECOMP
         <
          C1: (synDONP_PREPPROSENT IN VERBrec1.synvps) AND
              (synDONP_PREPPROSENT IN VERBPPROPrec2.synvpefs ) AND
              (PROSENTVARrec1.so =false)                       AND
              (PREPrec1.key = VERBrec1.prepkey1) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> []     
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >


(*  *)
   SUBRULE (* 2 *)
      < 
       T1 : T3
       T2 : SENTENCEVAR{SENTENCEVARrec1}
      >
      < 
       T1 : T3
       T2 : SENTENCEVAR{SENTENCEVARrec1}
      >

   MATCHCONDITIONS
      <
       T1: T3.CAT IN [NPVAR,CNVAR]
      >

      COMP
         <
          C1: (synDONP_PREPOPENOMTESENT IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] ) AND
              SENTENCEVARrec1 =
		  {
		  mood       : declarative
		  senttype   : subordinateclause
		  PROsubject : true
		  modus      : infinitive
		  finiteness : infinite
		  infsort    : omteinf
		  VRcompl    : false
		  }

          A1: 
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synDONP_PREPOPENOMTESENT]
         >
      DECOMP
         <
          C1: (synDONP_PREPOPENOMTESENT IN VERBrec1.synvps) AND
              (synDONP_PREPOPENOMTESENT IN VERBPPROPrec2.synvpefs ) AND
              (PREPrec1.key = VERBrec1.prepkey1) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> []        AND
              SENTENCEVARrec1 = 
		  {
		  mood       : declarative
		  senttype   : subordinateclause
		  PROsubject : true
		  modus      : infinitive
		  finiteness : infinite
		  infsort    : omteinf
		  VRcompl    : false
		  }
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

(*  *)
   SUBRULE (* 3 *)
      < 
       T1 : T3
       T2 : SENTENCEVAR{SENTENCEVARrec1}
      >
      < 
       T1 : T3
       T2 : SENTENCEVAR{SENTENCEVARrec1}
      >

   MATCHCONDITIONS
      <
       T1: T3.CAT IN [NPVAR,CNVAR]
      >

      COMP
         <
          C1: (synDONP_PREPOPENTESENT IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] ) AND
              SENTENCEVARrec1 =
		  {
		  mood       : declarative
		  senttype   : subordinateclause
		  PROsubject : true
		  modus      : infinitive
		  finiteness : infinite
		  infsort    : teinf
		  VRcompl    : false
		  }

          A1: 
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synDONP_PREPOPENTESENT]
         >
      DECOMP
         <
          C1: (synDONP_PREPOPENTESENT IN VERBrec1.synvps) AND
              (synDONP_PREPOPENTESENT IN VERBPPROPrec2.synvpefs ) AND
              (PREPrec1.key = VERBrec1.prepkey1) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> []        AND
              SENTENCEVARrec1 = 
		  {
		  mood       : declarative
		  senttype   : subordinateclause
		  PROsubject : true
		  modus      : infinitive
		  finiteness : infinite
		  infsort    : teinf
		  VRcompl    : false
		  }
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

(*  *)
   SUBRULE (* 4 *)
      < 
       T1 : T3
       T2 : SENTENCEVAR{SENTENCEVARrec1}
      >
      < 
       T1 : T3
       T2 : SENTENCEVAR{SENTENCEVARrec1}
      >

   MATCHCONDITIONS
      <
       T1: T3.CAT IN [NPVAR,CNVAR]
      >

      COMP
         <
          C1: (synDONP_PREPTHATSENT IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] ) AND
              SENTENCEVARrec1 =
		  {
		  mood       : declarative
		  senttype   : subordinateclause
		  PROsubject : false
		  modus      : indicative
		  finiteness : finite
		  infsort    : omegainf
		  VRcompl    : false
		  }

          A1: 
              VARPREPPrec1 :=
                 {
                  headkey    : PREPrec1.key
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synDONP_PREPTHATSENT]
         >
      DECOMP
         <
          C1: (synDONP_PREPTHATSENT IN VERBrec1.synvps) AND
              (synDONP_PREPTHATSENT IN VERBPPROPrec2.synvpefs ) AND
              (PREPrec1.key = VERBrec1.prepkey1) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : PREPrec1.key
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> []        AND
              SENTENCEVARrec1 = 
		  {
		  mood       : declarative
		  senttype   : subordinateclause
		  PROsubject : false
		  modus      : indicative
		  finiteness : finite
		  infsort    : omegainf
		  VRcompl    : false
		  }
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >




>
&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RVerbpattern12
\item[* relevant examples:] Hij beschuldigt de man van diefstal
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] Verbppropformation
\item[* class:] (name of rule, transformation or filter class)TC:
Verbpatternrules
\item[* date of creation:] 13-JAN-1987 09:08:27  
\item[* author:] Jan Odijk
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% TRANSFORMATION Rverbpattern13
< m1:VERBPPROP{VERBPPROPrec1}
              [ mu1,
                predrel/VERBP{VERBPrec1}
                       [ argrel/T1,
                         argrel/T2,
                         head/VERB{VERBrec1}[mu2]
                       ] 
              ]
>

< m :VERBPPROP{VERBPPROPrec2}
              [ mu1,
                predrel/VERBP{VERBPrec1}
                       [ objrel/T1,
                         prepobjrel/VARPREPP{VARPREPPrec1}
                                   [ head/PREP(KEY1){PREPrec1},
                                     objrel/T2
                                   ],
                         head/VERB{VERBrec1}[mu2]
                       ] 
              ]
>

<

   SUBRULE (* 1a *)
      < 
       T1 : T3
       T2 : NPVAR{NPVARrec1}
      >
      < 
       T1 : T3
       T2 : NPVAR{NPVARrec1}
      >


   MATCHCONDITIONS
      <
       T1: T3.CAT IN [NPVAR, CNVAR]
      >

      COMP
         <
          C1: (synaanNP_DONP IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )
          A1: KEY1 := KEY_aanioprepkey;
              VARPREPPrec1 :=
                 {
                  headkey    : KEY_aanioprepkey
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : NPVARrec1.specq
                  mood       : NPVARrec1.mood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synAANNP_DONP]
         >
      DECOMP
         <
          C1: (synAANNP_DONP IN VERBrec1.synvps) AND
              (synAANNP_DONP IN VERBPPROPrec2.synvpefs ) AND
              (KEY1 = KEY_aanioprepkey) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : KEY_aanioprepkey
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : NPVARrec1.specq
                  mood       : NPVARrec1.mood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> []        
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

   SUBRULE (* 1b *)
      < 
       T1 : T3
       T2 : CNVAR{CNVARrec1}
      >
      < 
       T1 : T3
       T2 : CNVAR{CNVARrec1}
      >


   MATCHCONDITIONS
      <
       T1: T3.CAT IN [NPVAR, CNVAR]
      >

      COMP
         <
          C1: (synaanNP_DONP IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )
          A1: KEY1 := KEY_aanioprepkey;
              VARPREPPrec1 :=
                 {
                  headkey    : KEY_aanioprepkey
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synAANNP_DONP]
         >
      DECOMP
         <
          C1: (synAANNP_DONP IN VERBrec1.synvps) AND
              (synAANNP_DONP IN VERBPPROPrec2.synvpefs ) AND
              (KEY1 = KEY_aanioprepkey) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : KEY_aanioprepkey
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> []        
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >

   SUBRULE (* 1a *)
      < 
       T1 : T3
       T2 : NPVAR{NPVARrec1}
      >
      < 
       T1 : T3
       T2 : NPVAR{NPVARrec1}
      >


   MATCHCONDITIONS
      <
       T1: T3.CAT IN [NPVAR, CNVAR]
      >

      COMP
         <
          C1: (synvoorNP_DONP IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )
          A1: KEY1 := KEY_voorioprepkey;
              VARPREPPrec1 :=
                 {
                  headkey    : KEY_voorioprepkey
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : NPVARrec1.specq
                  mood       : NPVARrec1.mood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synvoorNP_DONP]
         >
      DECOMP
         <
          C1: (synvoorNP_DONP IN VERBrec1.synvps) AND
              (synvoorNP_DONP IN VERBPPROPrec2.synvpefs ) AND
              (KEY1 = KEY_voorioprepkey) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : KEY_voorioprepkey
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : NPVARrec1.specq
                  mood       : NPVARrec1.mood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> []        
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >


   SUBRULE (* 1b *)
      < 
       T1 : T3
       T2 : CNVAR{CNVARrec1}
      >
      < 
       T1 : T3
       T2 : CNVAR{CNVARrec1}
      >


   MATCHCONDITIONS
      <
       T1: T3.CAT IN [NPVAR, CNVAR]
      >

      COMP
         <
          C1: (synvoorNP_DONP IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] )
          A1: KEY1 := KEY_voorioprepkey;
              VARPREPPrec1 :=
                 {
                  headkey    : KEY_voorioprepkey
                  synppefs   : [synNP]
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  actsubcefs : PREPrec1.subcs
                  specq      : yesspec
                  mood       : declxpmood
                 };
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synvoorNP_DONP]
         >
      DECOMP
         <
          C1: (synvoorNP_DONP IN VERBrec1.synvps) AND
              (synvoorNP_DONP IN VERBPPROPrec2.synvpefs ) AND
              (KEY1 = KEY_voorioprepkey) AND
              VARPREPPrec1 =
                 {
                  req        : [omegapol, pospol, negpol]
                  env        : [omegapol, pospol, negpol]
                  superdeixis: omegadeixis
                  radvkey    : 0
                  stranded   : false
                  headkey    : KEY_voorioprepkey
                  synppefs   NI synNP
                  thetapp    : pp120
                  retro      : PREPrec1.retro
                  aspect     : PREPrec1.aspect
                  deixis     : PREPrec1.deixis
                  class      : PREPrec1.class
                  specq      : yesspec
                  mood       : declxpmood
                 } AND
              VARPREPPrec1.actsubcefs * PREPrec1.subcs <> []        
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := []
         >


>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rverbpattern13
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 10-OCT-1988 12:56:06  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% TRANSFORMATION Rverbpattern15
< m1:VERBPPROP{VERBPPROPrec1}
              [ mu1,
                predrel/VERBP{VERBPrec1}
                       [ argrel/T1,
                         argrel/T2,
                         head/VERB{VERBrec1}[mu2]
                       ] 
              ]
>

< m :VERBPPROP{VERBPPROPrec2}
              [ mu1,
                predrel/VERBP{VERBPrec1}
                       [ 
                         locargrel/T2,
                         complrel/T1,
                         head/VERB{VERBrec1}[mu2]
                       ] 
              ]
>

<
   SUBRULE
      <T1: SENTENCEVAR{SENTENCEVARrec1} 
       T2: T3
      >
      < >

   MATCHCONDITIONS
      <
       T2: (T3.CAT IN [PREPPPROPVAR] WITH (T3.REC.PROsubject = true AND
                                          loc IN T3.REC.actsubcefs))     OR
           (T3.CAT IN [ADVPPROPVAR] WITH (T3.REC.PROsubject = true  AND
                                        locadv IN T3.REC.actsubcefs))     
      >

      COMP
         <
          C1: (synTHATSENT_LOCOPENPREPPPROP IN VERBrec1.synvps) AND
              (VERBPPROPrec1.synvpefs = [] ) AND
              SENTENCEVARrec1 = {
                                 mood        : declarative
                                 senttype    : subordinateclause
                                 finiteness  : finite
                                }
          A1:  
              VERBPPROPrec2 := VERBPPROPrec1;
              VERBPPROPrec2.synvpefs := [synTHATSENT_LOCOPENPREPPPROP];
         >
      DECOMP
         <
          C1: (synTHATSENT_LOCOPENPREPPPROP IN VERBrec1.synvps) AND
              (synTHATSENT_LOCOPENPREPPPROP IN VERBPPROPrec2.synvpefs ) AND
              SENTENCEVARrec1 = {
                                 mood        : declarative
                                 senttype    : subordinateclause
                                 finiteness  : finite
                                }
          A1: VERBPPROPrec1 := VERBPPROPrec2;
              VERBPPROPrec1.synvpefs := [];
         >


>

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rverbpattern15
\item[* relevant examples:]
er staat in de krant dat hij ziek is
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 10-OCT-1988 13:08:38  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


%
%

E 2
E 1
