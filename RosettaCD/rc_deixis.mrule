DUTCH 65
&
\newpage
\begin{verbatim}
%
% RULE Rfinpresentdeixis
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
            I7:mu7=[mu3,
                    I2:rel1/VERB{VERBrec1}[mu4]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
            I7:mu7=[mu3,
                    I3:rel1/VERB{VERBrec2}[mu4]
                   ],
            mu5
           ] 

>

   MATCHCONDITIONS
      <
       m1: CLAUSErec1.deixis = omegadeixis AND
           CLAUSErec1.finiteness = finite
       I2: VERBrec1.tense = omegatense
       m : CLAUSErec2.modus <> imperative AND
           CLAUSErec2.finiteness = finite AND
           CLAUSErec2.deixis = presentdeixis
       I3: VERBrec2.tense = presenttense
       I7: NOT EXIST(mu7,[head/VERB{VERBrec7}
                          [head/SUBVERB{SUBVERBrec7}
                           [head/I71::BVERB{BVERBrec7}] ]
                         ]
                    )
           I71: BVERBrec7.key = KEY_kanirr1BVERBkey  OR
                BVERBrec7.key = KEY_kanirr2BVERBkey  OR
                BVERBrec7.key = KEY_moetirr1BVERBkey OR
                BVERBrec7.key = KEY_moetirr2BVERBkey        

      >


<
   SUBRULE
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <T1: ADVPVAR{ADVPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          ((ADVPVARrec1.deixis = presentdeixis) OR
           (ADVPVARrec1.deixis = omegadeixis) OR
           (ADVPVARrec1.deixis = futuredeixis)
          )
      >

      COMP
         <
          C1: true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;

         >
      DECOMP
         <
          C1:true
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;

         >
   SUBRULE
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
   
MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          ((PREPPVARrec1.deixis = presentdeixis) OR
           (PREPPVARrec1.deixis = omegadeixis) OR
           (PREPPVARrec1.deixis = futuredeixis)
          )
      >

      COMP
         <
          C1: true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
         >
      DECOMP
         <
          C1: true
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <T1: SENTENCE{SENTENCErec1}[mu9]>

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          ((SENTENCErec1.conjdeixis = presentdeixis) OR
          (SENTENCErec1.conjdeixis = omegadeixis) OR
          (SENTENCErec1.conjdeixis = futuredeixis)
         )
      >

      COMP
         <
          C1:true
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
         >
      DECOMP
         <
          C1: true
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rfinpresentdeixis
\item[* relevant examples:] slaapt (o.t.t.)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 21-MAY-1987 16:23:37  
\item[* author:] Lisette Appelo
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 21/01/88\ \ \ \ \ author: Lisette Appelo
\item date: 19/05/89\ \ \ \ \ author: Lisette Appelo
\item date: 09/01/90\ \ \ \ \ author: Lisette Appelo\\
Splitting into two subrules. Necessary to be able to refer to the key of the 
main verb. The abstract irrealis modal verbs should be excluded here.
\end{enumerate}
\item[* task:] The relation between Rs and S is simultanuous: PRESENT.
               This rule is for a finite independent clause.
               The most right verb in the clause gets a present tense.
               The deixis 
value of the reference adverbial is checked for 
               present, future or omega.
               The clause is marked for present deixis.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different categories of the variables for the 
reference adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The superdeixis value also may be presentdeixis in the case 
this sentence is a sentence with {\em graag}\\
19/5/89: Added condition on futuredeixis reference adverbial.\\
\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rfinpastdeixis
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I2:rel1/VERB{VERBrec1}
                        [head/T2]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I3:rel1/VERB{VERBrec2}
                        [head/T2]
                   ],
            mu5
           ] 

>


   MATCHCONDITIONS
      <
       m1:CLAUSErec1.deixis = omegadeixis AND
          CLAUSErec1.finiteness = finite
       I2:VERBrec1.tense = omegatense
       m :CLAUSErec2.modus <> imperative AND
          CLAUSErec2.finiteness = finite AND
          CLAUSErec2.deixis = pastdeixis
       I3:VERBrec2.tense = pasttense

      >


<
   SUBRULE (* 1 *)
      <T2: SUBVERB{SUBVERBrec1}[I1: head/BVERB(KEY1){BVERBrec1}] >
      <T2: SUBVERB{SUBVERBrec1}[I1: head/BVERB(KEY1){BVERBrec1}] >
   
MATCHCONDITIONS
      <
        I1: KEY1 <> KEY_kanirr1BVERBkey AND
            KEY1 <> KEY_kanirr2BVERBkey AND
            KEY1 <> KEY_moetirr1BVERBkey AND
            KEY1 <> KEY_moetirr2BVERBkey        
      >

<
   SUBRULE (* 1a *)
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <T1: ADVPVAR{ADVPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          ((ADVPVARrec1.deixis = pastdeixis) OR
           (ADVPVARrec1.deixis = omegadeixis) OR
           (ADVPVARrec1.deixis = futuredeixis) 
          )
      >

      COMP
         <
          C1:(ADVPVARrec1.deixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 

             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
         >
      DECOMP
         <
          C1:(ADVPVARrec1.deixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := pastdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              CLAUSErec1.deixis:= omegadeixis;

         >
   SUBRULE (* 1 b *)
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <T1: PREPPVAR{PREPPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          ((PREPPVARrec1.deixis = pastdeixis) OR
           (PREPPVARrec1.deixis = omegadeixis) OR
           (PREPPVARrec1.deixis = futuredeixis)
          )
      >

      COMP
         <
          C1:(PREPPVARrec1.deixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 

             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
         >
      DECOMP
         <
          C1:(PREPPVARrec1.deixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := pastdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (* 1c *)
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <T1: SENTENCE{SENTENCErec1}[mu9]>

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          ((SENTENCErec1.conjdeixis = pastdeixis) OR
           (SENTENCErec1.conjdeixis = omegadeixis) OR
           (SENTENCErec1.conjdeixis = futuredeixis)
          )
      >

      COMP
         <
          C1:(SENTENCErec1.conjdeixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 

             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
         >
      DECOMP
         <
          C1:(SENTENCErec1.conjdeixis = futuredeixis ->
               KEY1 = KEY_zullenbverbkey) 
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := pastdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >
>

   SUBRULE (* 2 *)
      <T2: SUBVERB{SUBVERBrec1}
                  [sig1, head/SUBVERB{SUBVERBrec2}
                             [I2: head/BVERB(KEY1){BVERBrec1}]
                  ]
      >
      <T2: SUBVERB{SUBVERBrec1}
                  [sig1, head/SUBVERB{SUBVERBrec2}
                             [I2: head/BVERB(KEY1){BVERBrec1}] 
                  ]
      >

MATCHCONDITIONS
      <
        I2: KEY1 <> KEY_kanirr1BVERBkey AND
            KEY1 <> KEY_kanirr2BVERBkey AND
            KEY1 <> KEY_moetirr1BVERBkey AND
            KEY1 <> KEY_moetirr2BVERBkey        
      >

<
   SUBRULE (* 2a *)
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <T1: ADVPVAR{ADVPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          ((ADVPVARrec1.deixis = pastdeixis) OR
           (ADVPVARrec1.deixis = omegadeixis) OR
           (ADVPVARrec1.deixis = futuredeixis)
          )
      >

      COMP
         <
          C1:(ADVPVARrec1.deixis = futuredeixis ->
               KEY1 = KEY_zullenbverbkey) 

             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
         >
      DECOMP
         <
          C1:(ADVPVARrec1.deixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := pastdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              CLAUSErec1.deixis:= omegadeixis;

         >
   SUBRULE (* 2 b *)
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <T1: PREPPVAR{PREPPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          ((PREPPVARrec1.deixis = pastdeixis) OR
           (PREPPVARrec1.deixis = omegadeixis) OR
           (PREPPVARrec1.deixis = futuredeixis)
          )
      >

      COMP
         <
          C1:(PREPPVARrec1.deixis = futuredeixis ->
               KEY1 = KEY_zullenbverbkey) 

             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
         >
      DECOMP
         <
          C1:(PREPPVARrec1.deixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := pastdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (* 2c *)
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <T1: SENTENCE{SENTENCErec1}[mu9]>

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          ((SENTENCErec1.conjdeixis = pastdeixis) OR
           (SENTENCErec1.conjdeixis = omegadeixis) OR
           (SENTENCErec1.conjdeixis = futuredeixis)
          )
      >

      COMP
         <
          C1:(SENTENCErec1.conjdeixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 

             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
         >
      DECOMP
         <
          C1:(SENTENCErec1.conjdeixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 
              C11: (CLAUSErec2.superdeixis = omegadeixis)
              A11: CLAUSErec1 := CLAUSErec2;

              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := pastdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >
>

>
&
\end{verbatim}

\newpage
\begin{description}
\item[* name:] Rfinpastdeixis
\item[* relevant examples:] sliep (o.v.t.)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 21-MAY-1987 
\item[* author:] Lisette Appelo
\item[* copied from:]Rindeppresentdeixis
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 08/02/88\ \ \ \ \ author: Lisette Appelo
\item date: 05/01/90\ \ \ \ \ author: Lisette Appelo\\
Added condition on futuredeixis adverbial in combination with {\em zullen}
to be able to generate {\em hij zou morgen komen}. Maybe it would be better
to have a special {\em irrealis} rule.
\item date: 08/01/90\ \ \ \ \ author: Lisette Appelo\\
Rule had to be split up into to subrules, one for a verb without particle
and one with particle. This is necessary because the key is referred to.
\item date: 09/01/90\ \ \ \ \ author: Lisette Appelo\\
Added condition modal irrealis keys; they should be treated in 
Rfinirrmodaldeixis.
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is before: PAST.
               This rule is for a finite independent clause.
               The most right verb in the clause gets a past tense.
               The deixis 
value of the reference adverbial is checked for 
               past or omega.
               The clause is marked for past deixis.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different variable categories for the reference 
adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The superdeixis value also may be pastdeixis in the case 
this sentence is a sentence with {\em graag}.\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}

% RULE Rfinpastdeixisspec
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                I1: [mu3,
                    I2: rel1/VERB{VERBrec1}[mu4]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                I1:[mu3,
                    I3:rel1/VERB{VERBrec2}[mu4],
                    I4:auxrel/VERB{VERBrec3}
                          [head/SUBVERB{SUBVERBrec1}
                               [head/T2] 
                          ]
                   ],
            mu5
           ] 

>
   MATCHCONDITIONS
      <
       m1:CLAUSErec1.deixis = omegadeixis AND
          CLAUSErec1.aspect = perfective AND
          CLAUSErec1.retro = false AND
          CLAUSErec1.finiteness = finite
       I2: VERBrec1.tense = omegatense AND
           VERBrec1.subc <> modalverb
       m : CLAUSErec2.modus <> imperative AND
           CLAUSErec2.deixis = pastdeixis AND
           CLAUSErec2.aspect = perfective AND
           CLAUSErec2.retro = false AND
           CLAUSErec2.finiteness = finite
       I1: RIGHTTOLEFT 
       I3: VERBrec2.modus = pastpart 
       I4: VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1) AND
           (VERBrec3 =
                     {
                      number : omeganumber
                      persons : []
                      eORenForm : NoForm
                      modus : omegamodus
                      tense : presenttense
                      status : bareV
                     }
           )
           (* other values: default values *)

      >

<
   SUBRULE (*1: ADVPVAR, hebben*)
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <
       T1: ADVPVAR{ADVPVARrec1}[ ]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          ((ADVPVARrec1.deixis = pastdeixis) OR
           (ADVPVARrec1.deixis = omegadeixis)
          )
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := presenttense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (hebaux IN VERBrec2.perfauxs) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*2: ADVPVAR, zijn*)
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <
       T1: ADVPVAR{ADVPVARrec1}[ ]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          ((ADVPVARrec1.deixis = pastdeixis) OR
           (ADVPVARrec1.deixis = omegadeixis)
          )
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := presenttense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (isaux IN VERBrec2.perfauxs) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*3: PREPPVAR, hebben*)
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <
       T1: PREPPVAR{PREPPVARrec1}[ ]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          ((PREPPVARrec1.deixis = pastdeixis) OR
           (PREPPVARrec1.deixis = omegadeixis)
          )
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := presenttense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (hebaux IN VERBrec2.perfauxs) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*4: PREPPVAR, zijn*)
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <
       T1: PREPPVAR{PREPPVARrec1}[ ]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          ((PREPPVARrec1.deixis = pastdeixis) OR
           (PREPPVARrec1.deixis = omegadeixis)
          )
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := presenttense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (isaux IN VERBrec2.perfauxs) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
         >
   SUBRULE (*5: SENTENCE, hebben*)
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <
       T1: SENTENCE{SENTENCErec1}[mu9]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          ((SENTENCErec1.conjdeixis = pastdeixis) OR
           (SENTENCErec1.conjdeixis = omegadeixis)
          )
      >

      COMP
         <
          C1:(hebaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := presenttense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (hebaux IN VERBrec2.perfauxs) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*6: SENTENCE, zijn*)
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <
       T1: SENTENCE{SENTENCErec1}[mu9]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          ((SENTENCErec1.conjdeixis = pastdeixis) OR
           (SENTENCErec1.conjdeixis = omegadeixis)
          )
      >

      COMP
         <
          C1:(isaux IN VERBrec1.perfauxs)
             C11:(CLAUSErec1.superdeixis = omegadeixis)
             A11:CLAUSErec2 := CLAUSErec1;
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec3.tense := presenttense;
              (* other values retain their default values *)
         >
      DECOMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (isaux IN VERBrec2.perfauxs) 
             C11: (CLAUSErec2.superdeixis = omegadeixis)
             A11: CLAUSErec1 := CLAUSErec2;
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
              CLAUSErec1.deixis := omegadeixis;
         >
>
&
\end{verbatim}

\newpage
\begin{description}
\item[* name:] Rfinpastdeixisspec
\item[* relevant examples:] hij heeft gisteren geslapen (v.t.t.)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 25-MAY-1987 
\item[* author:] Lisette Appelo
\item[* copied from:]Rindeppresentpast
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 08/02/88\ \ \ \ \ author: Lisette Appelo
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is before: PAST.
               This rule is for a finite independent clause. This
               is a special rule for Dutch with respect to the finite version. 
               The most right verb in the clause (input generative rule)
gets modus of a past particle.
The auxiliary verb {\em hebben/zijn
} is introduced with a present tense.
               The deixis 
value of the reference adverbial is checked for 
               past or omega.
               The clause is marked for past deixis.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different variable categories for the reference 
adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial, perfective aspect rule \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language: This rule has the same semantics as 
Rfinpastdeixis.\\

\item in other languages: This rule corresponds to the rule for simple past 
tense in English and preterito in Spanish. \\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The superdeixis value also may be pastdeixis in the case 
this sentence is a sentence with {\em graag}\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE RfinpresentdeixisA
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I2:rel1/VERB{VERBrec1}
                             [I3:rel2/VERB{VERBrec3}[head/T2],
                              mu6
                             ]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I4:rel1/VERB{VERBrec2}
                             [I5:rel2/VERB{VERBrec4}[head/T2],
                              mu6
                             ]
                   ],
            mu5
           ] 

>

   MATCHCONDITIONS
      <
       m1: CLAUSErec1.deixis = omegadeixis AND
           CLAUSErec1.finiteness = finite
       I2: VERbrec1.status IN [VV, AuxV] AND
           VERBrec1.tense = omegatense
       I3: VERBrec3.tense = omegatense AND
           VERBrec3.modus = infinitive
       m : CLAUSErec2.modus <> imperative AND
           CLAUSErec2.finiteness = finite AND
           CLAUSErec2.deixis = presentdeixis
       I4: VERBrec2.tense = presenttense AND
           VERBrec2.status IN [VV, AuxV] 
       I5: VERBrec4.tense = presenttense AND
           VERBrec4.modus = omegamodus
      >

<
   SUBRULE (* 1 *)
      <T2: SUBVERB{SUBVERBrec1}[I1: head/BVERB(KEY1){BVERBrec1}] >
      <T2: SUBVERB{SUBVERBrec1}[I1: head/BVERB(KEY1){BVERBrec1}] >
   
MATCHCONDITIONS
      <
        I1: KEY1 <> KEY_kanirr1BVERBkey AND
            KEY1 <> KEY_kanirr2BVERBkey AND
            KEY1 <> KEY_moetirr1BVERBkey AND
            KEY1 <> KEY_moetirr2BVERBkey        
      >

<
   SUBRULE
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <T1: ADVPVAR{ADVPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          ((ADVPVARrec1.deixis = presentdeixis) OR
           (ADVPVARrec1.deixis = omegadeixis) OR
           (ADVPVARrec1.deixis = futuredeixis)
          )
      >

      COMP
         <
          C1:true
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := presenttense;
              VERbrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1: true
              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERbrec4;
              VERbrec3.tense := omegatense;
              VERbrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;

         >
   SUBRULE
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <T1: PREPPVAR{PREPPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          ((PREPPVARrec1.deixis = presentdeixis) OR
           (PREPPVARrec1.deixis = omegadeixis) OR
           (PREPPVARrec1.deixis = futuredeixis)
          )
      >

      COMP
         <
          C1:true
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := presenttense;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:true
              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERbrec4;
              VERbrec3.tense := omegatense;
              VERbrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;

         >

   SUBRULE
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <T1: SENTENCE{SENTENCErec1}[mu9]>

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          ((SENTENCErec1.conjdeixis = presentdeixis) OR
           (SENTENCErec1.conjdeixis = omegadeixis) OR
           (SENTENCErec1.conjdeixis = futuredeixis)
          )
      >

      COMP
         <
          C1:true
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := presenttense;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:true
              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERbrec4;
              VERbrec3.tense := omegatense;
              VERbrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;

         >
>
   SUBRULE (* 2 *)
      <T2: SUBVERB{SUBVERBrec1}
                  [sig1, head/SUBVERB{SUBVERBrec2}
                             [I2: head/BVERB(KEY1){BVERBrec1}]
                  ]
      >
      <T2: SUBVERB{SUBVERBrec1}
                  [sig1, head/SUBVERB{SUBVERBrec2}
                             [I2: head/BVERB(KEY1){BVERBrec1}] 
                  ]
      >

MATCHCONDITIONS
      <
        I2: KEY1 <> KEY_kanirr1BVERBkey AND
            KEY1 <> KEY_kanirr2BVERBkey AND
            KEY1 <> KEY_moetirr1BVERBkey AND
            KEY1 <> KEY_moetirr2BVERBkey        
      >
<
   SUBRULE
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <T1: ADVPVAR{ADVPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          ((ADVPVARrec1.deixis = presentdeixis) OR
           (ADVPVARrec1.deixis = omegadeixis) OR
           (ADVPVARrec1.deixis = futuredeixis)
          )
      >

      COMP
         <
          C1:true
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := presenttense;
              VERbrec4.modus := omegamodus;

         >
      DECOMP
         <
          C1:true
              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERbrec4;
              VERbrec3.tense := omegatense;
              VERbrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;


         >
   SUBRULE
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <T1: PREPPVAR{PREPPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          ((PREPPVARrec1.deixis = presentdeixis) OR
           (PREPPVARrec1.deixis = omegadeixis) OR
           (PREPPVARrec1.deixis = futuredeixis)
          )
      >

      COMP
         <
          C1:true
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := presenttense;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:true
              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERbrec4;
              VERbrec3.tense := omegatense;
              VERbrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;

         >

   SUBRULE
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <T1: SENTENCE{SENTENCErec1}[mu9]>

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          ((SENTENCErec1.conjdeixis = presentdeixis) OR
           (SENTENCErec1.conjdeixis = omegadeixis) OR
           (SENTENCErec1.conjdeixis = futuredeixis)
          )
      >

      COMP
         <
          C1:true
             C12:(CLAUSErec1.superdeixis = presentdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := presentdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := presenttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := presenttense;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:true
              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := presentdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERbrec4;
              VERbrec3.tense := omegatense;
              VERbrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;

         >
>
>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RfinpresentdeixisA
\item[* relevant examples:] wil graag kunnen zwemmen (o.t.t.)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 27-FEB-1990
\item[* author:] Lisette Appelo
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item 
\end{enumerate}
\item[* task:] The relation between Rs and S is simultanuous: PRESENT.
               This rule is for a finite independent clause.
               The most right cluster verb and its most left head
               in the clause get a present tense.
               The modus of the former is checked for infinitive and set to
               omegamodus.
               The deixis value of the reference adverbial is checked for 
               present, future or omega.
               The clause should have presentdeixis for superdeixis.
               The clause is marked for present deixis.
               The rule is meant for cases with {\em graag}
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different categories of the variables for the 
reference adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: 
\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE RfinpastdeixisA
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I2:rel1/VERB{VERBrec1}
                             [I3:rel2/VERB{VERBrec3}[head/T2],
                              mu6
                             ]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                   [mu3,
                    I4:rel1/VERB{VERBrec2}
                             [I5:rel2/VERB{VERBrec4}[head/T2],
                              mu6
                             ]
                   ],
            mu5
           ] 

>


   MATCHCONDITIONS
      <
       m1:CLAUSErec1.deixis = omegadeixis AND
          CLAUSErec1.finiteness = finite
       I2:VERbrec1.status IN [VV, AuxV] AND
          VERBrec1.tense = omegatense
       I3:VERBrec3.tense = omegatense AND
          VERBrec3.modus = infinitive
       m :CLAUSErec2.modus <> imperative AND
          CLAUSErec2.finiteness = finite AND
          CLAUSErec2.deixis = pastdeixis
       I4:VERBrec2.tense = pasttense AND
          VERBrec2.status IN [VV, AuxV]
       I5:VERBrec4.tense = pasttense AND
          VERBrec4.modus = omegamodus

      >


<
   SUBRULE (* 1 *)
      <T2: SUBVERB{SUBVERBrec1}[I1: head/BVERB(KEY1){BVERBrec1}] >
      <T2: SUBVERB{SUBVERBrec1}[I1: head/BVERB(KEY1){BVERBrec1}] >
   
MATCHCONDITIONS
      <
        I1: KEY1 <> KEY_kanirr1BVERBkey AND
            KEY1 <> KEY_kanirr2BVERBkey AND
            KEY1 <> KEY_moetirr1BVERBkey AND
            KEY1 <> KEY_moetirr2BVERBkey        
      >

<
   SUBRULE (* 1a *)
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <T1: ADVPVAR{ADVPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          ((ADVPVARrec1.deixis = pastdeixis) OR
           (ADVPVARrec1.deixis = omegadeixis) OR
           (ADVPVARrec1.deixis = futuredeixis)
          )
      >

      COMP
         <
          C1:(ADVPVARrec1.deixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(ADVPVARrec1.deixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 
              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := pastdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERbrec4;
              VERbrec3.tense := omegatense;
              VERbrec3.modus := infinitive;
              CLAUSErec1.deixis:= omegadeixis;

         >
   SUBRULE (* 1 b *)
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <T1: PREPPVAR{PREPPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          ((PREPPVARrec1.deixis = pastdeixis) OR
           (PREPPVARrec1.deixis = omegadeixis) OR
           (PREPPVARrec1.deixis = futuredeixis)
          )
      >

      COMP
         <
          C1:(PREPPVARrec1.deixis = futuredeixis  ->
              KEY1 = KEY_zullenbverbkey) 
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;
      >
      DECOMP
         <
          C1:(PREPPVARrec1.deixis = futuredeixis  ->
              KEY1 = KEY_zullenbverbkey) 
              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := pastdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERbrec4;
              VERbrec3.tense := omegatense;
              VERbrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (* 1c *)
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <T1: SENTENCE{SENTENCErec1}[mu9]>

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          ((SENTENCErec1.conjdeixis = pastdeixis) OR
           (SENTENCErec1.conjdeixis = omegadeixis) OR
           (SENTENCErec1.conjdeixis = futuredeixis)
          )
      >

      COMP
         <
          C1:(SENTENCErec1.conjdeixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(SENTENCErec1.conjdeixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 
              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := pastdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERbrec4;
              VERbrec3.tense := omegatense;
              VERbrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;
         >
>

   SUBRULE (* 2 *)
      <T2: SUBVERB{SUBVERBrec1}
                  [sig1, head/SUBVERB{SUBVERBrec2}
                             [I2: head/BVERB(KEY1){BVERBrec1}]
                  ]
      >
      <T2: SUBVERB{SUBVERBrec1}
                  [sig1, head/SUBVERB{SUBVERBrec2}
                             [I2: head/BVERB(KEY1){BVERBrec1}] 
                  ]
      >

MATCHCONDITIONS
      <
        I2: KEY1 <> KEY_kanirr1BVERBkey AND
            KEY1 <> KEY_kanirr2BVERBkey AND
            KEY1 <> KEY_moetirr1BVERBkey AND
            KEY1 <> KEY_moetirr2BVERBkey        
      >

<
   SUBRULE (* 2a *)
      <T1: ADVPVAR{ADVPVARrec1}[ ]>
      <T1: ADVPVAR{ADVPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          ((ADVPVARrec1.deixis = pastdeixis) OR
           (ADVPVARrec1.deixis = omegadeixis) OR
           (ADVPVARrec1.deixis = futuredeixis)
          )
      >

      COMP
         <
          C1:(ADVPVARrec1.deixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey)
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(ADVPVARrec1.deixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey)
              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := pastdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERbrec4;
              VERbrec3.tense := omegatense;
              VERbrec3.modus := infinitive;
              CLAUSErec1.deixis:= omegadeixis;

         >
   SUBRULE (* 2 b *)
      <T1: PREPPVAR{PREPPVARrec1}[ ]>
      <T1: PREPPVAR{PREPPVARrec1}[ ]>

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
           (PREPPVARrec1.retro = false) AND
           ((PREPPVARrec1.deixis = pastdeixis) OR
            (PREPPVARrec1.deixis = omegadeixis) OR
            (PREPPVARrec1.deixis = futuredeixis)
           )
      >

      COMP
         <
          C1:(PREPPVARrec1.deixis = futuredeixis  ->
              KEY1 = KEY_zullenbverbkey) 
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(PREPPVARrec1.deixis = futuredeixis  ->
              KEY1 = KEY_zullenbverbkey) 
              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := pastdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERbrec4;
              VERbrec3.tense := omegatense;
              VERbrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (* 2c *)
      <T1: SENTENCE{SENTENCErec1}[mu9]>
      <T1: SENTENCE{SENTENCErec1}[mu9]>

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          ((SENTENCErec1.conjdeixis = pastdeixis) OR
           (SENTENCErec1.conjdeixis = omegadeixis) OR
           (SENTENCErec1.conjdeixis = futuredeixis) 
          )
      >

      COMP
         <
          C1:(SENTENCErec1.conjdeixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec2 := VERBrec1;
              VERBrec2.tense := pasttense;
              VERBrec4 := VERBrec3;
              VERBrec4.tense := pasttense;
              VERbrec4.modus := omegamodus;
         >
      DECOMP
         <
          C1:(SENTENCErec1.conjdeixis = futuredeixis ->
              KEY1 = KEY_zullenbverbkey) 
              C12: (CLAUSErec2.superdeixis = omegadeixis)
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.superdeixis := pastdeixis
 
          A1: VERBrec1 := VERBrec2;
              VERBrec1.tense := omegatense;
              VERBrec3 := VERbrec4;
              VERbrec3.tense := omegatense;
              VERbrec3.modus := infinitive;
              CLAUSErec1.deixis := omegadeixis;
         >
>

>
&
\end{verbatim}

\newpage
\begin{description}
\item[* name:] Rfinpastdeixis
\item[* relevant examples:] kon graag willen zwemmen (o.v.t.)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 07-MAR-1990 
\item[* author:] Lisette Appelo
\item[* copied from:]Rfinpastdeixis and RfinpresentdeixisA
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author: 
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is before: PAST.
               This rule is for a finite independent clause.
               The most right verb in the clause gets a past tense.
               The deixis 
value of the reference adverbial is checked for 
               past or omega.
               The clause is marked for past deixis.
               The superdeixis of this clause should be pastdeixis.
               This rule is meant for cases with {\em graag}
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different variable categories for the reference 
adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: 

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}

% RULE RfinpastdeixisspecA
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                I1: [mu3,
                     I6:head/VERB{VERBrec5}
                         [I4:auxrel/VERB{VERBrec3}
                                   [head/SUBVERB{SUBVERBrec1}
                                        [head/T2] 
                                   ],
                          I2: rel1/VERB{VERBrec1}
                                  [I3:head/VERB{VERbrec2}[mu4],
                                   mu6
                                  ]
                         ]
                   ],
            mu5
           ] 
>

< m :CLAUSE{CLAUSErec2}
           [mu1,
            tempadvrel/T1,
            mu2,
            predrel/VERBP{VERBPrec1}
                I1:[mu3,
                    I6:head/VERB{VERbrec5}
                        [I5:auxrel/VERB{VERBrec4}
                                  [head/SUBVERB{SUBVERBrec1}
                                       [head/T2] 
                                  ],
                         I2:rel1/VERB{VERBrec1}
                                      [I3:head/VERB{VERBrec2}[mu4],
                                       mu6
                                      ]
                         ]
                   ],
            mu5
           ] 

>
   MATCHCONDITIONS
      <
       m1:CLAUSErec1.deixis = omegadeixis AND
          CLAUSErec1.aspect = perfective AND
          CLAUSErec1.retro = false AND
          CLAUSErec1.finiteness = finite
       I2: VERBrec1.tense = omegatense AND
           VERbrec1.status = VV AND
           VERBrec1.subc <> modalverb 
       I3: VERbrec2.tense = omegatense AND
           VERbrec2.modus = infinitive
       m : CLAUSErec2.modus <> imperative AND
           CLAUSErec2.deixis = pastdeixis AND
           CLAUSErec2.aspect = perfective AND
           CLAUSErec2.retro = false AND
           CLAUSErec2.finiteness = finite
       I1: RIGHTTOLEFT 
       I4: VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1) AND
           (VERBrec3 =
                     {
                      number : omeganumber
                      persons : []
                      eORenForm : NoForm
                      modus : infinitive
                      tense : omegatense
                      status : bareV
                     }
           )
           (* other values: default values *)

       I5: VERBrec4 = COPYT_subverbtoverb(SUBVERBrec1) AND
           (VERBrec4 =
                     {
                      number : omeganumber
                      persons : []
                      eORenForm : NoForm
                      modus : omegamodus
                      tense : presenttense
                      status : bareV
                     }
           )
           (* other values: default values *)
       I6: VERBrec5.status = AuxV
      >

<
   SUBRULE (*1: ADVPVAR, hebben*)
      <T1: ADVPVAR{ADVPVARrec1}[ ]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

      <
       T1: ADVPVAR{ADVPVARrec1}[ ]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          ((ADVPVARrec1.deixis = pastdeixis) OR
           (ADVPVARrec1.deixis = omegadeixis)
          )
      >

      COMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (hebaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec4 := VERbrec3;
              VERBrec4.modus := omegamodus;
              VERbrec4.tense := presenttense;
         >
      DECOMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (hebaux IN VERBrec2.perfauxs) 
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              VERbrec3.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*2: ADVPVAR, zijn*)
      <T1: ADVPVAR{ADVPVARrec1}[ ]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >
      <
       T1: ADVPVAR{ADVPVARrec1}[ ]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(ADVPVARrec1.class = reference) AND
          (ADVPVARrec1.retro = false) AND
          ((ADVPVARrec1.deixis = pastdeixis) OR
           (ADVPVARrec1.deixis = omegadeixis)
          )
      >

      COMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
            (isaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec4 := VERbrec3;
              VERBrec4.modus := omegamodus;
              VERbrec4.tense := presenttense;
         >
      DECOMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (isaux IN VERBrec2.perfauxs) 
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              VERbrec3.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*3: PREPPVAR, hebben*)
      <T1: PREPPVAR{PREPPVARrec1}[ ]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >
      <
       T1: PREPPVAR{PREPPVARrec1}[ ]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          ((PREPPVARrec1.deixis = pastdeixis) OR
           (PREPPVARrec1.deixis = omegadeixis)
          )
      >

      COMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (hebaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec4 := VERbrec3;
              VERBrec4.modus := omegamodus;
              VERbrec4.tense := presenttense;
         >
      DECOMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (hebaux IN VERBrec2.perfauxs) 
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              VERbrec3.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*4: PREPPVAR, zijn*)
      <T1: PREPPVAR{PREPPVARrec1}[ ]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >
      <
       T1: PREPPVAR{PREPPVARrec1}[ ]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(PREPPVARrec1.class = reference) AND
          (PREPPVARrec1.retro = false) AND
          ((PREPPVARrec1.deixis = pastdeixis) OR
           (PREPPVARrec1.deixis = omegadeixis)
          )
      >

      COMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (isaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec4 := VERbrec3;
              VERBrec4.modus := omegamodus;
              VERbrec4.tense := presenttense;
         >
      DECOMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (isaux IN VERBrec2.perfauxs) 
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              VERbrec3.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >
   SUBRULE (*5: SENTENCE, hebben*)
      <T1: SENTENCE{SENTENCErec1}[mu9]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >
      <
       T1: SENTENCE{SENTENCErec1}[mu9]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          ((SENTENCErec1.conjdeixis = pastdeixis) OR
           (SENTENCErec1.conjdeixis = omegadeixis)
          )
      >

      COMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (hebaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec4 := VERbrec3;
              VERBrec4.modus := omegamodus;
              VERbrec4.tense := presenttense;
         >
      DECOMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (hebaux IN VERBrec2.perfauxs) 
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              VERbrec3.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >

   SUBRULE (*6: SENTENCE, zijn*)
      <T1: SENTENCE{SENTENCErec1}[mu9]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >
      <
       T1: SENTENCE{SENTENCErec1}[mu9]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}[ ]
      >

   MATCHCONDITIONS
      <
       T1:(SENTENCErec1.conjclass = reference) AND
          (SENTENCErec1.conjretro = false) AND
          ((SENTENCErec1.conjdeixis = pastdeixis) OR
           (SENTENCErec1.conjdeixis = omegadeixis)
          )
      >

      COMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
            (isaux IN VERBrec1.perfauxs)
             
             C12:(CLAUSErec1.superdeixis = pastdeixis) (* geval graag *)
             A12: CLAUSErec2 := CLAUSErec1;
                  CLAUSErec2.superdeixis := omegadeixis;

          A1: CLAUSErec2.deixis := pastdeixis;
              VERBrec4 := VERbrec3;
              VERBrec4.modus := omegamodus;
              VERbrec4.tense := presenttense;
         >
      DECOMP
         <
          C1:SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
             (isaux IN VERBrec2.perfauxs) 
 
             C12: (CLAUSErec2.superdeixis = omegadeixis)
             A12: CLAUSErec1 := CLAUSErec2;
                  CLAUSErec1.superdeixis := pastdeixis;

          A1: VERBrec3 := VERBrec4;
              VERBrec3.modus := infinitive;
              VERbrec3.tense := omegatense;
              CLAUSErec1.deixis := omegadeixis;
         >
>
&
\end{verbatim}

\newpage
\begin{description}
\item[* name:] RfinpastdeixisspecA
\item[* relevant examples:] hij heeft toevallig proberen te slapen (v.t.t.)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Deixis rules
\item[* date of creation:] 07-MAR-1990 
\item[* author:] Lisette Appelo
\item[* copied from:]Rfinpastdeixisspec
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 08/02/88\ \ \ \ \ author: Lisette Appelo
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] The relation between Rs and S is before: PAST.
               This rule is for a finite independent clause. This
               is a special rule for Dutch with respect to the finite version.
               This is a rule meant for cases like {\em graag, toevallig} 
The auxiliary verb {\em hebben/zijn
} gets a present tense.
In analysis the modus gets infinitive.
               The deixis 
value of the reference adverbial is checked for 
               past or omega.
               The clause is marked for past deixis.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:] The splitting into
subrules corresponds to the different variable categories for the reference 
adverbials. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see task)
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules: finiteness transformations, rules that introduce the 
reference adverbial, perfective aspect rule \\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language: This rule has the same semantics as 
Rfinpastdeixis.\\

\item in other languages: This rule corresponds to the rule for simple past 
tense in English and preterito in Spanish. \\

\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: 
\end{enumerate}
\end{description}

%
%
