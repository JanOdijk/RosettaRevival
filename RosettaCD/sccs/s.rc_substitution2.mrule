h19928
s 03199/00001/00000
d D 1.2 92/02/21 15:44:28 rous 2 1
c 
e
s 00001/00000/00000
d D 1.1 92/02/11 11:48:17 rous 1 0
c date and time created 92/02/11 11:48:17 by rous
e
u
U
f e 0
t
T
I 1
D 2
 
E 2
I 2

DUTCH 93
&
\newpage
\begin{verbatim}
%
% RULE RIdSubstitution1
                                        (* NP in objNP in VP *)
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      objrel/NP{NPrec3}
                            [ detrel/I1::NPVAR{NPVARrec1},
                              head/CN{CNrec1}[mu7]
                            ],
                      mu3
                    ],
             mu4 
           ] 
SUBST:
  m2: T1 
>

< m : I10::CLAUSE{CLAUSErec2}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      objrel/NP{NPrec3}
                            [ I2:detrel/T2,
                              head/CN{CNrec1}[mu7]
                            ],
                      mu3
                    ],
             mu4 
           ] 
>

   MATCHCONDITIONS
      <
       m : QUOTE_substordercondition2(mu3, mu4) 
       I1: NPVARrec1.index = LEVEL
       m2: NOT QUOTE_NegPhrase(T1) AND
           QUOTE_Gsubstordercondition2(mu3,mu4,T1) 
       I2: NOT QUOTE_NegPhrase(T2)
       I10: CLAUSErec2.synvpefs * [vpid10] <> []
      >

   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE (* 1 *) (* Jans *)
      <T1: I3::NP{NPrec1}[head/PROPERNOUN{PROPERNOUNrec1}[mu8]] >
      <T2: I4::NP{NPrec2}[head/PROPERNOUN{PROPERNOUNrec2}[mu8]] >

   MATCHCONDITIONS
      <
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
       I4: [NPrec2.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec2.NPhead <> enNP  OR mass IN NPrec2.actcomas)
      >
      COMP
         <
          C1: NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              NPrec1.cases = [Nominative]   AND
              NPrec1.generic = nogeneric
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   PROPERNOUNrec2 := PROPERNOUNrec1;
                   PROPERNOUNrec2.geni := true;
                   NPrec2.superdeixis := omegadeixis;
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   PROPERNOUNrec2 := PROPERNOUNrec1;
                   PROPERNOUNrec2.geni := true;
                   NPrec2.superdeixis := omegadeixis;
          A1: NPrec2.generic := omegageneric;
              CLAUSErec2 := CLAUSErec1;
         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric 
              C11: CLAUSErec2.deixis = omegadeixis AND
                   NPrec2.superdeixis = omegadeixis
              A11: NPrec1 := NPrec2;
                   NPrec1.cases := [nominative];
                   PROPERNOUNrec1 := PROPERNOUNrec2;
                   PROPERNOUNrec1.geni := false;
                   NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis AND
                   NPrec2.superdeixis = omegadeixis  
              A12: NPrec1 := NPrec2;
                   NPrec1.cases := [nominative];
                   PROPERNOUNrec1 := PROPERNOUNrec2;
                   PROPERNOUNrec1.geni := false;
                   NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: NPVARrec1 := COPYT_nptovar(NPrec2);
              NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid10]
         >

   SUBRULE (* 2 *) (* mijn *)
      <T1: I3::NP{NPrec1}[head/PERSPRO{PERSPROrec1}
                               [head/BPERSPRO{BPERSPROREC1}]
                         ] >
      <T2: POSSADJ{POSSADJrec1}[head/BPERSPRO{BPERSPROREC1}] >

   MATCHCONDITIONS
      <
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
      >

      COMP
         <
          C1: PERSPROrec1 = COPYT_bpersprotoperspro(BPERSPROrec1)  AND
              NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              genitive IN NPVARrec1.cases                          AND
              (
               (BPERSPROrec1.animate = yesanimate    AND
                BPERSPROrec1.person IN [1,2,4,5]     AND
                NPrec1.human = omegahuman
               )                                              OR
               (BPERSPROrec1.animate <> yesanimate   AND
                BPERSPROrec1.person IN [3]           AND
                NPrec1.human = omegahuman
               )
              )                                                    AND
	      NPrec1 = 
		  {
		   req            : [pospol,negpol,omegapol]
		   env            : [pospol,negpol,omegapol]
		   class          : omegaTimeAdvClass
		   deixis         : omegadeixis
		   aspect         : omegaAspect
		   retro          : false
		   definite       : def
		   person         : BPERSPROrec1.person
		   number         : BPERSProrec1.number
		   cases          : [Nominative]
		   genders        : [BPERSPROrec1.gender]
		   sexes          : []
		   actsubcs       : [othernoun]
		   temporal       : false
		   possgeni       : false
                   animate        : BPERSPROrec1.animate
		   actcomas       : [count]
		   thetanp        : omegathetanp
		   nounpatternefs : []
		   posspred       : true
		   possnietnp     : false
		   mood           : declxpmood
		   generic        : nogeneric
		   possRform      : false
		   syntquant      : omegaquant
                   NPhead         : BPERSPROrec1.NPhead
		   specQ          : yesspec
                  }
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: @
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: @
          A1: CLAUSErec2 := CLAUSErec1;
         >
               (* Possadjrec happens to be default *)
      DECOMP
         <
          C1: TRUE
              C11: CLAUSErec2.deixis = omegadeixis
                   C111: BPERSPROrec1.animate = yesanimate AND
                         BPERSPROrec1.person IN [1,2,4,5]
                   A111: NPrec1.human := omegahuman
                   C112: BPERSPROrec1.animate <> yesanimate AND
                         BPERSPROrec1.person IN [3]
                   A112: NPrec1.human := omegahuman
              A11: NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis
                   C121: BPERSPROrec1.animate = yesanimate AND
                         BPERSPROrec1.person IN [1,2,4,5]
                   A121: NPrec1.human := omegahuman
                   C122: BPERSPROrec1.animate <> yesanimate AND
                         BPERSPROrec1.person IN [3]
                   A122: NPrec1.human := omegahuman
              A12: NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: PERSPROrec1 := COPYT_bpersprotoperspro(BPERSPROrec1);
              NPVARrec1 := 
		  {
                   index          : LEVEL
		   req            : [pospol,negpol,omegapol]
		   env            : [pospol,negpol,omegapol]
		   class          : omegaTimeAdvClass
		   deixis         : omegadeixis
		   aspect         : omegaAspect
		   retro          : false
		   definite       : def
		   person         : BPERSPROrec1.person
		   number         : BPERSProrec1.number
		   cases          : [genitive]
		   genders        : [BPERSPROrec1.gender]
		   sexes          : []
		   actsubcs       : [othernoun]
		   temporal       : false
		   possgeni       : false
		   actcomas       : [count]
		   thetanp        : omegathetanp
		   nounpatternefs : []
		   posspred       : true
		   possnietnp     : false
		   mood           : declxpmood
		   generic        : nogeneric
		   possRform      : false
		   syntquant      : omegaquant
		   specQ          : yesspec
                  }                                      ;
	      NPrec1 := 
		  {
		   req            : [pospol,negpol,omegapol]
		   env            : [pospol,negpol,omegapol]
		   class          : omegaTimeAdvClass
		   deixis         : omegadeixis
		   aspect         : omegaAspect
		   retro          : false
		   definite       : def
		   person         : BPERSPROrec1.person
		   number         : BPERSProrec1.number
		   cases          : [Nominative]
		   genders        : [BPERSPROrec1.gender]
		   sexes          : []
		   actsubcs       : [othernoun]
		   temporal       : false
		   possgeni       : false
                   animate        : BPERSPROrec1.animate
		   actcomas       : [count]
		   thetanp        : omegathetanp
		   nounpatternefs : []
		   posspred       : true
		   possnietnp     : false
		   mood           : declxpmood
		   generic        : nogeneric
		   possRform      : false
		   syntquant      : omegaquant
                   NPhead         : BPERSPROrec1.NPhead
		   specQ          : yesspec
                  }                                      ;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid10]
         >

   SUBRULE (* 3 *) (* mijn vaders *)
      <T1: NP{NPrec1}[mu11, 
                      head/CN{CNREC2}[mu5, 
                                      head/NOUN{NOUNREC1}[mu8]]]>
      <T2: NP{NPrec2}[mu11,
                      head/CN{CNREC3}[mu5,
                                      head/NOUN{NOUNREC2}[mu8]]]>

   MATCHCONDITIONS
      <
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
       I4: [NPrec2.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec2.NPhead <> enNP  OR mass IN NPrec2.actcomas)
      >

      COMP
         <
          C1: NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              NPrec1.cases = [Nominative]   AND
              NPrec1.generic = nogeneric AND
              CNREC2.possgeni = true
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   NPrec2.superdeixis := omegadeixis
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   NPrec2.superdeixis := omegadeixis  
          A1: NPrec2.generic := omegageneric;
              NPrec2.cases := [genitive];
              CNrec3 := CNrec2;
              CNrec3.cases := [genitive];
              NOUNrec2 := NOUNrec1;
              NOUNrec2.geni := true;
              CLAUSErec2 := CLAUSErec1;         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric           AND
              CNrec3.possgeni = true                  AND
              NOUNrec2.geni = true                    AND
              NPrec2.cases= [genitive]
              C11: CLAUSErec2.deixis = omegadeixis AND
                   NPrec2.superdeixis = omegadeixis
              A11: NPrec1 := NPrec2;
                   NPrec1.cases := [nominative];
                   NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis AND
                   NPrec2.superdeixis = omegadeixis  
              A12: NPrec1 := NPrec2;
                   NPrec1.cases := [nominative];
                   NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: NOUNrec1 := NOUNrec2;
              NOUNrec1.geni := false;
              CNrec2 := CNrec3;
              CNrec2.cases := [nominative];
              NPVARrec1 := COPYT_nptovar(NPrec2);
              NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid10]
         >

   SUBRULE (* 4 *) (* wiens *)
      <T1: I3::NP{NPrec1}[head/WHPRO{WHPROrec1}
                               [head/BWHPRO{BWHPROREC1}]
                         ] >
      <T2: POSSADJ{POSSADJrec1}[head/BWHPRO{BWHPROREC1}] >

   MATCHCONDITIONS
      <
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
      >

      COMP
         <
          C1: WHPROrec1 = COPYT_bwhprotowhpro(BWHPROrec1)          AND
              NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              genitive IN NPVARrec1.cases                          AND
              NPVARrec1.generic = nogeneric                        AND
              NPVARrec1.index = LEVEL                              AND
              NPrec1.generic = nogeneric                           AND
              NPrec1.definite = NPrec3.definite                    AND
              NPrec1.mood = NPrec3.mood                            AND
              NPrec1.animate = WHPROrec1.animate                   AND
              NPrec1.possRform = WHPROrec1.possRform               AND
              NPrec1.sexes = WHPROrec1.sexes                       AND
              NPrec1.number = WHPROrec1.number                     AND
              NPrec1.specq = yesspec                               AND
              NPrec1.syntquant = omegaquant                        AND
              NPrec1.posspred = TRUE                               AND
              NPrec1.human = yeshuman
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: @                   
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: @
          A1: POSSADJrec1.geni := false;
              POSSADJrec1.mood := wh;
              CLAUSErec2 := CLAUSErec1;
         >

      DECOMP
         <
          C1: POSSADJrec1.geni = false                  AND
              POSSADJrec1.mood = wh
              C11: CLAUSErec2.deixis = omegadeixis
              A11: NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis
              A12: NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: WHPROrec1 := COPYT_bwhprotowhpro(BWHPROrec1);
              NPrec1.generic := nogeneric;
              NPrec1.definite := NPrec3.definite;
              NPrec1.mood := NPrec3.mood;
              NPrec1.animate := WHPROrec1.animate;
              NPrec1.possRform := WHPROrec1.possRform;
              NPrec1.sexes := WHPROrec1.sexes;
              NPrec1.number := WHPROrec1.number;
              NPrec1.specq := yesspec;
              NPrec1.syntquant := omegaquant;
              NPrec1.posspred := TRUE;
              NPrec1.human := yeshuman;              
              NPVARrec1 := COPYT_nptovar(NPrec1);
              NPVARrec1.cases := [genitive];
              NPVARrec1.index := LEVEL;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid10]
         >
>
&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RIdSubstitution1
\item[* relevant examples:] x1 breekt x2 hart, Jan breekt haar/Maries/zijn 
moeders hart
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] CLAUSEtoSENTENCE
\item[* class:] (name of rule, transformation or filter class) RC:Substitution
\item[* date of creation:] 19-JAN-1989 10:33:40  
\item[* author:] Andr\'{e} Schenk
\item[* copied from:]--
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] It substitutes POSSADJs for variables under NP under VP, in 
particular, for variables bearing relation objrel.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
The function assigncase must assign a set of cases !!
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\
The substitution order condition must be added. This is not simple !!
Also to be added: polarity requirements, superdeixis
\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE RIdSubstitution3               (* NP in objNP in PREPP in VP *)
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      I8:rel1/PREPP{PREPPrec1}
                         [ head/PREP{PREPrec1},
                           objrel/NP{NPrec3}
                              [ detrel/I1::NPVAR{NPVARrec1},
                                head/CN{CNrec1}[mu7]
                              ]
                         ],
                      mu3
                    ],
             mu4 
           ] 
SUBST:
  m2: T3
>

< m : I10::CLAUSE{CLAUSErec2}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      I8:rel1/PREPP{PREPPrec1}
                         [ head/PREP{PREPrec1},
                           objrel/NP{NPrec3}
                              [ I2:detrel/T4,
                                head/CN{CNrec1}[mu7]
                              ]
                         ],
                      mu3
                    ],
             mu4 
           ] 
>

   MATCHCONDITIONS
      <
       m : QUOTE_substordercondition2(mu3, mu4) 
       m2: NOT QUOTE_NegPhrase(T3) AND
           QUOTE_Gsubstordercondition2(mu3,mu4,T3) 
       I1: NPVARrec1.index = LEVEL
       I8: rel1 IN [locargrel, dirargrel]
       I2: NOT QUOTE_NegPhrase(T4)
       I10: CLAUSErec2.synvpefs * [vpid11] <> []
      >

   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE (* 1 *) (* Jans *)
      <T3: I3::NP{NPrec1}[head/PROPERNOUN{PROPERNOUNrec1}[mu8]] >
      <T4: I4::NP{NPrec2}[head/PROPERNOUN{PROPERNOUNrec2}[mu8]] >

   MATCHCONDITIONS
      <
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
       I4: [NPrec2.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec2.NPhead <> enNP  OR mass IN NPrec2.actcomas)
      >
      COMP
         <
          C1: NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              NPrec1.cases = [Nominative]   AND
              NPrec1.generic = nogeneric
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   PROPERNOUNrec2 := PROPERNOUNrec1;
                   PROPERNOUNrec2.geni := true;
                   NPrec2.superdeixis := omegadeixis;
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   PROPERNOUNrec2 := PROPERNOUNrec1;
                   PROPERNOUNrec2.geni := true;
                   NPrec2.superdeixis := omegadeixis;
          A1: NPrec2.generic := omegageneric;
              CLAUSErec2 := CLAUSErec1;
         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric 
              C11: CLAUSErec2.deixis = omegadeixis AND
                   NPrec2.superdeixis = omegadeixis
              A11: NPrec1 := NPrec2;
                   NPrec1.cases := [nominative];
                   PROPERNOUNrec1 := PROPERNOUNrec2;
                   PROPERNOUNrec1.geni := false;
                   NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis AND
                   NPrec2.superdeixis = omegadeixis  
              A12: NPrec1 := NPrec2;
                   NPrec1.cases := [nominative];
                   PROPERNOUNrec1 := PROPERNOUNrec2;
                   PROPERNOUNrec1.geni := false;
                   NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: NPVARrec1 := COPYT_nptovar(NPrec2);
              NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid11];

         >

   SUBRULE (* 2 *) (* mijn *)
      <T3: I3::NP{NPrec1}[head/PERSPRO{PERSPROrec1}
                               [head/BPERSPRO{BPERSPROREC1}]
                         ] >
      <T4: POSSADJ{POSSADJrec1}[head/BPERSPRO{BPERSPROREC1}] >

   MATCHCONDITIONS
      <
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
      >
      COMP
         <
          C1: PERSPROrec1 = COPYT_bpersprotoperspro(BPERSPROrec1)  AND
              NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              genitive IN NPVARrec1.cases                          AND
              (
               (BPERSPROrec1.animate = yesanimate    AND
                BPERSPROrec1.person IN [1,2,4,5]     AND
                NPrec1.human = omegahuman
               )                                              OR
               (BPERSPROrec1.animate <> yesanimate   AND
                BPERSPROrec1.person IN [3]           AND
                NPrec1.human = omegahuman
               )
              )                                                    AND
	      NPrec1 = 
		  {
		   req            : [pospol,negpol,omegapol]
		   env            : [pospol,negpol,omegapol]
		   class          : omegaTimeAdvClass
		   deixis         : omegadeixis
		   aspect         : omegaAspect
		   retro          : false
		   definite       : def
		   person         : BPERSPROrec1.person
		   number         : BPERSProrec1.number
		   cases          : [Nominative]
		   genders        : [BPERSPROrec1.gender]
		   sexes          : []
		   actsubcs       : [othernoun]
		   temporal       : false
		   possgeni       : false
                   animate        : BPERSPROrec1.animate
		   actcomas       : [count]
		   thetanp        : omegathetanp
		   nounpatternefs : []
		   posspred       : true
		   possnietnp     : false
		   mood           : declxpmood
		   generic        : nogeneric
		   possRform      : false
		   syntquant      : omegaquant
                   NPhead         : BPERSPROrec1.NPhead
		   specQ          : yesspec
                  }
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: @
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: @
          A1: CLAUSErec2 := CLAUSErec1;
         >
               (* Possadjrec happens to be default *)
      DECOMP
         <
          C1: TRUE
              C11: CLAUSErec2.deixis = omegadeixis
                   C111: BPERSPROrec1.animate = yesanimate AND
                         BPERSPROrec1.person IN [1,2,4,5]
                   A111: NPrec1.human := omegahuman
                   C112: BPERSPROrec1.animate <> yesanimate AND
                         BPERSPROrec1.person IN [3]
                   A112: NPrec1.human := omegahuman
              A11: NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis
                   C121: BPERSPROrec1.animate = yesanimate AND
                         BPERSPROrec1.person IN [1,2,4,5]
                   A121: NPrec1.human := omegahuman
                   C122: BPERSPROrec1.animate <> yesanimate AND
                         BPERSPROrec1.person IN [3]
                   A122: NPrec1.human := omegahuman
              A12: NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: PERSPROrec1 := COPYT_bpersprotoperspro(BPERSPROrec1);
              NPVARrec1 := 
		  {
                   index          : LEVEL
		   req            : [pospol,negpol,omegapol]
		   env            : [pospol,negpol,omegapol]
		   class          : omegaTimeAdvClass
		   deixis         : omegadeixis
		   aspect         : omegaAspect
		   retro          : false
		   definite       : def
		   person         : BPERSPROrec1.person
		   number         : BPERSProrec1.number
		   cases          : [genitive]
		   genders        : [BPERSPROrec1.gender]
		   sexes          : []
		   actsubcs       : [othernoun]
		   temporal       : false
		   possgeni       : false
		   actcomas       : [count]
		   thetanp        : omegathetanp
		   nounpatternefs : []
		   posspred       : true
		   possnietnp     : false
		   mood           : declxpmood
		   generic        : nogeneric
		   possRform      : false
		   syntquant      : omegaquant
		   specQ          : yesspec
                  }                                      ;
	      NPrec1 := 
		  {
		   req            : [pospol,negpol,omegapol]
		   env            : [pospol,negpol,omegapol]
		   class          : omegaTimeAdvClass
		   deixis         : omegadeixis
		   aspect         : omegaAspect
		   retro          : false
		   definite       : def
		   person         : BPERSPROrec1.person
		   number         : BPERSProrec1.number
		   cases          : [Nominative]
		   genders        : [BPERSPROrec1.gender]
		   sexes          : []
		   actsubcs       : [othernoun]
		   temporal       : false
		   possgeni       : false
                   animate        : BPERSPROrec1.animate
		   actcomas       : [count]
		   thetanp        : omegathetanp
		   nounpatternefs : []
		   posspred       : true
		   possnietnp     : false
		   mood           : declxpmood
		   generic        : nogeneric
		   possRform      : false
		   syntquant      : omegaquant
                   NPhead         : BPERSPROrec1.NPhead
		   specQ          : yesspec
                  }                                      ;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid11];
         >

   SUBRULE (* 3 *) (* mijn vaders *)
      <T3: NP{NPrec1}[mu11, 
                      head/CN{CNREC2}[mu12, 
                                      head/NOUN{NOUNREC1}[mu8]]]>
      <T4: NP{NPrec2}[mu11,
                      head/CN{CNREC3}[mu12,
                                      head/NOUN{NOUNREC2}[mu8]]]>

   MATCHCONDITIONS
      <
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
       I4: [NPrec2.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec2.NPhead <> enNP  OR mass IN NPrec2.actcomas)
      >

      COMP
         <
          C1: NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              NPrec1.cases = [Nominative]   AND
              NPrec1.generic = nogeneric AND
              CNREC2.possgeni = true
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   NPrec2.superdeixis := omegadeixis
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   NPrec2.superdeixis := omegadeixis  
          A1: NPrec2.generic := omegageneric;
              NPrec2.cases := [genitive];
              CNrec3 := CNrec2;
              CNrec3.cases := [genitive];
              NOUNrec2 := NOUNrec1;
              NOUNrec2.geni := true;
              CLAUSErec2 := CLAUSErec1;
         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric           AND
              CNrec3.possgeni = true                  AND
              NOUNrec2.geni = true                    AND
              NPrec2.cases= [genitive]
              C11: CLAUSErec2.deixis = omegadeixis AND
                   NPrec2.superdeixis = omegadeixis
              A11: NPrec1 := NPrec2;
                   NPrec1.cases := [nominative];
                   NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis AND
                   NPrec2.superdeixis = omegadeixis  
              A12: NPrec1 := NPrec2;
                   NPrec1.cases := [nominative];
                   NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: NOUNrec1 := NOUNrec2;
              NOUNrec1.geni := false;
              CNrec2 := CNrec3;
              CNrec2.cases := [nominative];
              NPVARrec1 := COPYT_nptovar(NPrec2);
              NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid11];

         >

   SUBRULE (* 4 *) (* wiens *)
      <T3: I3::NP{NPrec1}[head/WHPRO{WHPROrec1}
                               [head/BWHPRO{BWHPROREC1}]
                         ] >
      <T4: POSSADJ{POSSADJrec1}[head/BWHPRO{BWHPROREC1}] >

   MATCHCONDITIONS
      <
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
      >

      COMP
         <
          C1: WHPROrec1 = COPYT_bwhprotowhpro(BWHPROrec1)          AND
              NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              genitive IN NPVARrec1.cases                          AND
              NPVARrec1.generic = nogeneric                        AND
              NPVARrec1.index = LEVEL                              AND
              NPrec1.generic = nogeneric                           AND
              NPrec1.definite = NPrec3.definite                    AND
              NPrec1.mood = NPrec3.mood                            AND
              NPrec1.animate = WHPROrec1.animate                   AND
              NPrec1.possRform = WHPROrec1.possRform               AND
              NPrec1.sexes = WHPROrec1.sexes                       AND
              NPrec1.number = WHPROrec1.number                     AND
              NPrec1.specq = yesspec                               AND
              NPrec1.syntquant = omegaquant                        AND
              NPrec1.posspred = TRUE                               AND
              NPrec1.human = yeshuman
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: @                   
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: @
          A1: POSSADJrec1.geni := false;
              POSSADJrec1.mood := wh;
              CLAUSErec2 := CLAUSErec1;
         >

      DECOMP
         <
          C1: POSSADJrec1.geni = false                  AND
              POSSADJrec1.mood = wh
              C11: CLAUSErec2.deixis = omegadeixis
              A11: NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis
              A12: NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: WHPROrec1 := COPYT_bwhprotowhpro(BWHPROrec1);
              NPrec1.generic := nogeneric;
              NPrec1.definite := NPrec3.definite;
              NPrec1.mood := NPrec3.mood;
              NPrec1.animate := WHPROrec1.animate;
              NPrec1.possRform := WHPROrec1.possRform;
              NPrec1.sexes := WHPROrec1.sexes;
              NPrec1.number := WHPROrec1.number;
              NPrec1.specq := yesspec;
              NPrec1.syntquant := omegaquant;
              NPrec1.posspred := TRUE;
              NPrec1.human := yeshuman;              
              NPVARrec1 := COPYT_nptovar(NPrec1);
              NPVARrec1.cases := [genitive];
              NPVARrec1.index := LEVEL;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid11];

         >

>

&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RIdSubstitution3
\item[* relevant examples:] x1 ramt x2 door x3s strot, Jan ramt het stuk door 
zijn/Maries/zijn vaders strot
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] CLAUSEtoSENTENCE
\item[* class:] (name of rule, transformation or filter class) RC:Substitution
\item[* date of creation:]  26-JAN-1989 16:26:18 
\item[* author:] Andr\'{e} Schenk
\item[* copied from:] RIdSubstitution1
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] It substitutes POSSADJs for variables under NP under VP, in 
particular, for variables bearing relation objrel.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
The function assigncase must assign a set of cases !!
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\
The substitution order condition must be added. This is not simple !!
Also to be added: polarity requirements, superdeixis
\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% RULE RIdSubstitution4               (* NP in shiftNP in PREPP in S *)
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             shiftrel/PREPP{PREPPrec1}
                     [ head/PREP{PREPrec1},
                       objrel/NP{NPrec3}
                             [ detrel/I1::NPVAR{NPVARrec1},
                               head/CN{CNrec1}[mu7]
                             ]
                     ],
             mu2,
             predrel/VERBP{VERBPrec1}[mu3],
             mu4 
           ] 
SUBST:
  m2: T3
>

< m : I10::CLAUSE{CLAUSErec2}
           [ mu1,
             shiftrel/PREPP{PREPPrec1}
                     [ head/PREP{PREPrec1},
                       objrel/NP{NPrec3}
                             [ I8:detrel/T4,
                               head/CN{CNrec1}[mu7]
                             ]
                     ],
             mu2,
             predrel/VERBP{VERBPrec1}[mu3],
             mu4 
           ] 
>

   MATCHCONDITIONS
      <
       m : QUOTE_substordercondition(mu2, mu3, mu4) 
       m2: NOT QUOTE_NegPhrase(T3) AND
           QUOTE_Gsubstordercondition(mu2, mu3, mu4,T3) 
       I1: NPVARrec1.index = LEVEL
       I8: NOT QUOTE_NegPhrase(T4)
       I10: CLAUSErec2.synvpefs * [vpid11] <> []
      >

   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE (* 1 *) (* Jans *)
      <T3: I3::NP{NPrec1}[head/PROPERNOUN{PROPERNOUNrec1}[mu8]] >
      <T4: I4::NP{NPrec2}[head/PROPERNOUN{PROPERNOUNrec2}[mu8]] >

   MATCHCONDITIONS
      <
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
       I4: [NPrec2.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec2.NPhead <> enNP  OR mass IN NPrec2.actcomas)
      >
      COMP
         <
          C1: NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              NPrec1.cases = [Nominative]   AND
              NPrec1.generic = nogeneric
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   PROPERNOUNrec2 := PROPERNOUNrec1;
                   PROPERNOUNrec2.geni := true;
                   NPrec2.superdeixis := omegadeixis;
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   PROPERNOUNrec2 := PROPERNOUNrec1;
                   PROPERNOUNrec2.geni := true;
                   NPrec2.superdeixis := omegadeixis;
          A1: NPrec2.generic := omegageneric;
              CLAUSErec2 := CLAUSErec1;
         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric 
              C11: CLAUSErec2.deixis = omegadeixis AND
                   NPrec2.superdeixis = omegadeixis
              A11: NPrec1 := NPrec2;
                   NPrec1.cases := [nominative];
                   PROPERNOUNrec1 := PROPERNOUNrec2;
                   PROPERNOUNrec1.geni := false;
                   NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis AND
                   NPrec2.superdeixis = omegadeixis  
              A12: NPrec1 := NPrec2;
                   NPrec1.cases := [nominative];
                   PROPERNOUNrec1 := PROPERNOUNrec2;
                   PROPERNOUNrec1.geni := false;
                   NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: NPVARrec1 := COPYT_nptovar(NPrec2);
              NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid11];

         >

   SUBRULE (* 2 *) (* mijn *)
      <T3: I3::NP{NPrec1}[head/PERSPRO{PERSPROrec1}
                               [head/BPERSPRO{BPERSPROREC1}]
                         ] >
      <T4: POSSADJ{POSSADJrec1}[head/BPERSPRO{BPERSPROREC1}] >

   MATCHCONDITIONS
      <
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
      >
      COMP
         <
          C1: PERSPROrec1 = COPYT_bpersprotoperspro(BPERSPROrec1)  AND
              NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              genitive IN NPVARrec1.cases                          AND
              (
               (BPERSPROrec1.animate = yesanimate    AND
                BPERSPROrec1.person IN [1,2,4,5]     AND
                NPrec1.human = omegahuman
               )                                              OR
               (BPERSPROrec1.animate <> yesanimate   AND
                BPERSPROrec1.person IN [3]           AND
                NPrec1.human = omegahuman
               )
              )                                                    AND
	      NPrec1 = 
		  {
		   req            : [pospol,negpol,omegapol]
		   env            : [pospol,negpol,omegapol]
		   class          : omegaTimeAdvClass
		   deixis         : omegadeixis
		   aspect         : omegaAspect
		   retro          : false
		   definite       : def
		   person         : BPERSPROrec1.person
		   number         : BPERSProrec1.number
		   cases          : [Nominative]
		   genders        : [BPERSPROrec1.gender]
		   sexes          : []
		   actsubcs       : [othernoun]
		   temporal       : false
		   possgeni       : false
                   animate        : BPERSPROrec1.animate
		   actcomas       : [count]
		   thetanp        : omegathetanp
		   nounpatternefs : []
		   posspred       : true
		   possnietnp     : false
		   mood           : declxpmood
		   generic        : nogeneric
		   possRform      : false
		   syntquant      : omegaquant
                   NPhead         : BPERSPROrec1.NPhead
		   specQ          : yesspec
                  }
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: @
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: @
          A1: CLAUSErec2 := CLAUSErec1;
         >
               (* Possadjrec happens to be default *)
      DECOMP
         <
          C1: TRUE
              C11: CLAUSErec2.deixis = omegadeixis
                   C111: BPERSPROrec1.animate = yesanimate AND
                         BPERSPROrec1.person IN [1,2,4,5]
                   A111: NPrec1.human := omegahuman
                   C112: BPERSPROrec1.animate <> yesanimate AND
                         BPERSPROrec1.person IN [3]
                   A112: NPrec1.human := omegahuman
              A11: NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis
                   C121: BPERSPROrec1.animate = yesanimate AND
                         BPERSPROrec1.person IN [1,2,4,5]
                   A121: NPrec1.human := omegahuman
                   C122: BPERSPROrec1.animate <> yesanimate AND
                         BPERSPROrec1.person IN [3]
                   A122: NPrec1.human := omegahuman
              A12: NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: PERSPROrec1 := COPYT_bpersprotoperspro(BPERSPROrec1);
              NPVARrec1 := 
		  {
                   index          : LEVEL
		   req            : [pospol,negpol,omegapol]
		   env            : [pospol,negpol,omegapol]
		   class          : omegaTimeAdvClass
		   deixis         : omegadeixis
		   aspect         : omegaAspect
		   retro          : false
		   definite       : def
		   person         : BPERSPROrec1.person
		   number         : BPERSProrec1.number
		   cases          : [genitive]
		   genders        : [BPERSPROrec1.gender]
		   sexes          : []
		   actsubcs       : [othernoun]
		   temporal       : false
		   possgeni       : false
		   actcomas       : [count]
		   thetanp        : omegathetanp
		   nounpatternefs : []
		   posspred       : true
		   possnietnp     : false
		   mood           : declxpmood
		   generic        : nogeneric
		   possRform      : false
		   syntquant      : omegaquant
		   specQ          : yesspec
                  }                                      ;
	      NPrec1 := 
		  {
		   req            : [pospol,negpol,omegapol]
		   env            : [pospol,negpol,omegapol]
		   class          : omegaTimeAdvClass
		   deixis         : omegadeixis
		   aspect         : omegaAspect
		   retro          : false
		   definite       : def
		   person         : BPERSPROrec1.person
		   number         : BPERSProrec1.number
		   cases          : [Nominative]
		   genders        : [BPERSPROrec1.gender]
		   sexes          : []
		   actsubcs       : [othernoun]
		   temporal       : false
		   possgeni       : false
                   animate        : BPERSPROrec1.animate
		   actcomas       : [count]
		   thetanp        : omegathetanp
		   nounpatternefs : []
		   posspred       : true
		   possnietnp     : false
		   mood           : declxpmood
		   generic        : nogeneric
		   possRform      : false
		   syntquant      : omegaquant
                   NPhead         : BPERSPROrec1.NPhead
		   specQ          : yesspec
                  }                                      ;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid11];
         >

   SUBRULE (* 3 *) (* mijn vaders *)
      <T3: NP{NPrec1}[mu11, 
                      head/CN{CNREC2}[mu12, 
                                      head/NOUN{NOUNREC1}[mu8]]]>
      <T4: NP{NPrec2}[mu11,
                      head/CN{CNREC3}[mu12,
                                      head/NOUN{NOUNREC2}[mu8]]]>

   MATCHCONDITIONS
      <
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
       I4: [NPrec2.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec2.NPhead <> enNP  OR mass IN NPrec2.actcomas)
      >

      COMP
         <
          C1: NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              NPrec1.cases = [Nominative]   AND
              NPrec1.generic = nogeneric AND
              CNREC2.possgeni = true
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   NPrec2.superdeixis := omegadeixis
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   NPrec2.superdeixis := omegadeixis  
          A1: NPrec2.generic := omegageneric;
              NPrec2.cases := [genitive];
              CNrec3 := CNrec2;
              CNrec3.cases := [genitive];
              NOUNrec2 := NOUNrec1;
              NOUNrec2.geni := true;
              CLAUSErec2 := CLAUSErec1;
         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric           AND
              CNrec3.possgeni = true                  AND
              NOUNrec2.geni = true                    AND
              NPrec2.cases= [genitive]
              C11: CLAUSErec2.deixis = omegadeixis AND
                   NPrec2.superdeixis = omegadeixis
              A11: NPrec1 := NPrec2;
                   NPrec1.cases := [nominative];
                   NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis AND
                   NPrec2.superdeixis = omegadeixis  
              A12: NPrec1 := NPrec2;
                   NPrec1.cases := [nominative];
                   NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: NOUNrec1 := NOUNrec2;
              NOUNrec1.geni := false;
              CNrec2 := CNrec3;
              CNrec2.cases := [nominative];
              NPVARrec1 := COPYT_nptovar(NPrec2);
              NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid11];

         >

   SUBRULE (* 4 *) (* wiens *)
      <T3: I3::NP{NPrec1}[head/WHPRO{WHPROrec1}
                               [head/BWHPRO{BWHPROREC1}]
                         ] >
      <T4: POSSADJ{POSSADJrec1}[head/BWHPRO{BWHPROREC1}] >

   MATCHCONDITIONS
      <
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
      >

      COMP
         <
          C1: WHPROrec1 = COPYT_bwhprotowhpro(BWHPROrec1)          AND
              NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              genitive IN NPVARrec1.cases                          AND
              NPVARrec1.generic = nogeneric                        AND
              NPVARrec1.index = LEVEL                              AND
              NPrec1.generic = nogeneric                           AND
              NPrec1.definite = NPrec3.definite                    AND
              NPrec1.mood = NPrec3.mood                            AND
              NPrec1.animate = WHPROrec1.animate                   AND
              NPrec1.possRform = WHPROrec1.possRform               AND
              NPrec1.sexes = WHPROrec1.sexes                       AND
              NPrec1.number = WHPROrec1.number                     AND
              NPrec1.specq = yesspec                               AND
              NPrec1.syntquant = omegaquant                        AND
              NPrec1.posspred = TRUE                               AND
              NPrec1.human = yeshuman
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: @                   
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: @
          A1: POSSADJrec1.geni := false;
              POSSADJrec1.mood := wh;
              CLAUSErec2 := CLAUSErec1;
         >

      DECOMP
         <
          C1: POSSADJrec1.geni = false                  AND
              POSSADJrec1.mood = wh
              C11: CLAUSErec2.deixis = omegadeixis
              A11: NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis
              A12: NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: WHPROrec1 := COPYT_bwhprotowhpro(BWHPROrec1);
              NPrec1.generic := nogeneric;
              NPrec1.definite := NPrec3.definite;
              NPrec1.mood := NPrec3.mood;
              NPrec1.animate := WHPROrec1.animate;
              NPrec1.possRform := WHPROrec1.possRform;
              NPrec1.sexes := WHPROrec1.sexes;
              NPrec1.number := WHPROrec1.number;
              NPrec1.specq := yesspec;
              NPrec1.syntquant := omegaquant;
              NPrec1.posspred := TRUE;
              NPrec1.human := yeshuman;              
              NPVARrec1 := COPYT_nptovar(NPrec1);
              NPVARrec1.cases := [genitive];
              NPVARrec1.index := LEVEL;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid11];

         >

>

&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RIdSubstitution4
\item[* relevant examples:] door x1's strot ramt Jan het stuk
zijn/Maries/zijn vaders strot
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] CLAUSEtoSENTENCE
\item[* class:] (name of rule, transformation or filter class) RC:Substitution
\item[* date of creation:]  18-SEP-1989 16:00:04 
\item[* author:] Andr\'{e} Schenk
\item[* copied from:] RIdSubstitution3
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] It substitutes POSSADJs for variables under NP under VP, in 
particular, for variables bearing relation objrel.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
The function assigncase must assign a set of cases !!
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\
The substitution order condition must be added. This is not simple !!
Also to be added: polarity requirements, superdeixis
\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% RULE RIdSubstitution5               (* objNP PREPP modifying NOUN
                                         in objNP in PREPP in VP *)
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      I8:rel1/PREPP{PREPPrec1}
                         [ mu5,
                           objrel/NP{NPrec3}
                              [ head/CN{CNrec1}
                                    [ mu6,
                                      postmodrel/PREPP{PREPPrec2}
                                        [ mu7,
                                          objrel/I1::NPVAR{NPVARrec1},
                                          mu8
                                        ],
                                      mu12
                                    ]
                              ],
                           mu9
                         ],
                      mu3
                    ],
             mu4 
           ] 
SUBST:
  m2: T3=I3::NP{NPrec1}[mu10]
>

< m :CLAUSE{CLAUSErec2}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      I8:rel1/PREPP{PREPPrec1}
                         [ mu5,
                           objrel/NP{NPrec3}
                              [ head/CN{CNrec1}
                                    [ mu6,
                                      postmodrel/PREPP{PREPPrec2}
                                        [ mu7,
                                          objrel/NP{NPrec2}[mu11],
                                          mu8
                                        ],
                                      mu12
                                    ]
                              ],
                           mu9
                         ],
                      mu3
                    ],
             mu4 
           ] 
>

   MATCHCONDITIONS
      <
       m : ALL
           QUOTE_substordercondition(mu3, mu4, mu8) AND
           QUOTE_substordercondition2(mu9, mu12)
       m2: ALL
           NOT QUOTE_NegPhrase(T3) AND
           QUOTE_Gsubstordercondition2(mu3,mu4,T3) AND
           QUOTE_Gsubstordercondition(mu8,mu9,mu12,T3) 
       I1: NPVARrec1.index = LEVEL
       I8: rel1 IN [locargrel]
       I10: CLAUSErec2.synvpefs * [vpid13] <> []
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
       I4: [NPrec2.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec2.NPhead <> enNP  OR mass IN NPrec2.actcomas)
       >

   PARAMETERS
      <
       LEVEL
      >

     COMP
         <
          C1: NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              NPrec1.cases = [Nominative]   AND
              NPrec1.generic = nogeneric
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: QUOTE_assigncase(NPrec1,mu10,NPrec2,mu11,NPVARrec1.cases);
                   NPrec2.cases := NPVARrec1.cases;
                   NPrec2.superdeixis := omegadeixis;
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: QUOTE_assigncase(NPrec1,mu10,NPrec2,mu11,NPVARrec1.cases);
                   NPrec2.cases := NPVARrec1.cases;
                   NPrec2.superdeixis := omegadeixis;
          A1: NPrec2.generic := omegageneric;
              CLAUSErec2 := CLAUSErec1;
         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric 
              C11: CLAUSErec2.deixis = omegadeixis AND
                   NPrec2.superdeixis = omegadeixis
              A11: QUOTE_assigncase(NPrec2,mu11,NPrec1,mu10,[Nominative]);
                   NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis AND
                   NPrec2.superdeixis = omegadeixis  
              A12: QUOTE_assigncase(NPrec2,mu11,NPrec1,mu10,[Nominative]);
                   NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: NPVARrec1 := COPYT_nptovar(NPrec2);
              NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid13];

         >


&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RIdSubstitution5
\item[* relevant examples:] x1 verblijft in afwachting van x2, x1 verblijft in 
afwachting van uw antwoord
zijn/Maries/zijn vaders strot
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] CLAUSEtoSENTENCE
\item[* class:] (name of rule, transformation or filter class) RC:Substitution
\item[* date of creation:]  20-SEP-1989 10:25:17 
\item[* author:] Andr\'{e} Schenk
\item[* copied from:] RIdSubstitution1
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Substitutes in in afwachting van x1 verblijven wij
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
The function assigncase must assign a set of cases !!
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\
The substitution order condition must be added. This is not simple !!
Also to be added: polarity requirements, superdeixis
\item modifications:\\

\end{enumerate}
\end{description}




\newpage
\begin{verbatim}
% RULE RIdSubstitution6               (* shiftrel/objNP PREPP modifying NOUN
                                         in objNP in PREPP in S *)
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             I8:rel1/PREPP{PREPPrec1}
                    [ mu5,
                      objrel/NP{NPrec3}
                            [ head/CN{CNrec1}
                                  [ mu6,
                                    postmodrel/PREPP{PREPPrec2}
                                      [ mu7,
                                        objrel/I1::NPVAR{NPVARrec1},
                                        mu8
                                      ],
                                    mu12
                                  ]
                            ],
                       mu9
                    ],
             mu3,
             predrel/VERBP{VERBPrec1}
                    [ mu2
                    ],
             mu4 
           ] 
SUBST:
  m2: T3=I3::NP{NPrec1}[mu10]
>

< m :CLAUSE{CLAUSErec2}
           [ mu1,
             I8:rel1/PREPP{PREPPrec1}
                  [ mu5,
                    objrel/NP{NPrec3}
                         [ head/CN{CNrec1}
                              [ mu6,
                                postmodrel/PREPP{PREPPrec2}
                                     [ mu7,
                                       objrel/NP{NPrec2}[mu11],
                                       mu8
                                     ],
                                 mu12
                               ]
                          ],
                    mu9
                  ],
             mu3,
             predrel/VERBP{VERBPrec1}
                    [ mu2
                    ],
             mu4 
           ] 
>

   MATCHCONDITIONS
      <
       m : ALL
           QUOTE_substordercondition(mu2, mu4, mu8) AND
           QUOTE_substordercondition(mu3, mu9, mu12)
       m2: ALL
           NOT QUOTE_NegPhrase(T3) AND
           QUOTE_Gsubstordercondition(mu2, mu3, mu4, T3) AND
           QUOTE_Gsubstordercondition(mu8, mu9, mu12, T3) 
       I1: NPVARrec1.index = LEVEL
       I8: rel1 IN [shiftrel]
       I10: CLAUSErec2.synvpefs * [vpid13] <> []
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
       I4: [NPrec2.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec2.NPhead <> enNP  OR mass IN NPrec2.actcomas)
       >

   PARAMETERS
      <
       LEVEL
      >

     COMP
         <
          C1: NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              NPrec1.cases = [Nominative]   AND
              NPrec1.generic = nogeneric
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: QUOTE_assigncase(NPrec1,mu10,NPrec2,mu11,NPVARrec1.cases);
                   NPrec2.cases := NPVARrec1.cases;
                   NPrec2.superdeixis := omegadeixis;
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: QUOTE_assigncase(NPrec1,mu10,NPrec2,mu11,NPVARrec1.cases);
                   NPrec2.cases := NPVARrec1.cases;
                   NPrec2.superdeixis := omegadeixis;
          A1: NPrec2.generic := omegageneric;
              CLAUSErec2 := CLAUSErec1;
         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric 
              C11: CLAUSErec2.deixis = omegadeixis AND
                   NPrec2.superdeixis = omegadeixis
              A11: QUOTE_assigncase(NPrec2,mu11,NPrec1,mu10,[Nominative]);
                   NPrec1.superdeixis := CLAUSErec2.superdeixis;
              C12: CLAUSErec2.deixis <> omegadeixis AND
                   NPrec2.superdeixis = omegadeixis  
              A12: QUOTE_assigncase(NPrec2,mu11,NPrec1,mu10,[Nominative]);
                   NPrec1.superdeixis := CLAUSErec2.deixis;
          A1: NPVARrec1 := COPYT_nptovar(NPrec2);
              NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := [vpid13];

         >


&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] RIdSubstitution6
\item[* relevant examples:] in afwachting van x2 x1 verblijft , in afwachting
van uw antwoord x1 verblijft 
zijn/Maries/zijn vaders strot
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] CLAUSEtoSENTENCE
\item[* class:] (name of rule, transformation or filter class) RC:Substitution
\item[* date of creation:]  25-SEP-1989 11:25:17 
\item[* author:] Andr\'{e} Schenk
\item[* copied from:] RIdSubstitution5
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Substitutes in in afwachting van x1 verblijven wij
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] none
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
The function assigncase must assign a set of cases !!
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\
The substitution order condition must be added. This is not simple !!
Also to be added: polarity requirements, superdeixis
\item modifications:\\

\end{enumerate}
\end{description}



\newpage
\begin{verbatim}
% RULE Rsubstitution7
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             I3:rel1/I2::ADVPVAR{ADVPVARrec1},
             mu2,
             predrel/VERBP{VERBPrec1}[mu3],
             mu4 
           ] 
  SUBST:
  m2:T3=ADVP{ADVPrec1}[head/ADV{ADVrec1}
                        [head/SUBADV{SUBADVrec1}
                             [head/I1::RADV{RADVrec1} ]  
                        ]
                   ]
>

< m :CLAUSE{CLAUSErec1}
           [ mu1,
             I5:rel1/T4=RADVP{RADVPrec1}[head/I1::RADV{RADVrec1}],
             mu2,
             predrel/VERBP{VERBPrec1}[mu3],
             mu4 
           ] 

>


   MATCHCONDITIONS
      <
       I1: RADVrec1.key <> KEY_erRADVkey   AND
           RADVrec1.key <> KEY_daarRADVkey AND
           RADVrec1.key <> KEY_hierRADVkey
       I2: ADVPVARrec1.index = LEVEL
       I3: rel1 IN [locadvrel, shiftrel] 
       I5: rel1 IN [locadvrel, shiftrel] AND
           NOT QUOTE_NegPhrase(T4)
       m : QUOTE_substordercondition(mu2,mu3,mu4) 
       m2: NOT QUOTE_NegPhrase(T3) AND 
           QUOTE_Gsubstordercondition(mu2,mu3,mu4,T3)
      >

   PARAMETERS
      <
       LEVEL
      >


      COMP
         <
          C1: SUBADVrec1 = AUX_SUBADVreconR EXCEPT FOR [mood, possnietnp] AND
              ADVrec1    = AUX_ADVreconR    EXCEPT FOR [mood, possnietnp] AND
              ADVPrec1   = AUX_ADVPreconR  EXCEPT FOR [superdeixis,mood, 
                                           possnietnp] AND
              QUOTE_deixismax(CLAUSErec1.deixis, 
                 CLAUSErec1.superdeixis, ADVPrec1.superdeixis) AND
              SUBADVrec1.mood = RADVrec1.mood AND
              ADVrec1.mood    = RADVrec1.mood AND
              ADVPrec1.mood = RADVrec1.mood AND
              ADVPVARrec1 = COPYT_advpTOvar(ADVPrec1)
              C11: RADVrec1.key = KEY_ergensRADVkey AND
                   SUBADVrec1.possnietnp = true AND
                   ADVrec1.possnietnp = true AND
                   ADVPrec1.possnietnp = true
              A11: @
              C12: RADVrec1.key <> KEY_ergensRADVkey AND
                   SUBADVrec1.possnietnp = false AND
                   ADVrec1.possnietnp = false AND
                   ADVPrec1.possnietnp = false
              A12: @
          A1: RADVPrec1 :=
		 {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : RADVrec1.mood
		  kindefs : [Lk]
		  radvkey : RADVrec1.key
		 }
         >
      DECOMP
         <
          C1: RADVPrec1 =	
                 {
		  req     : [pospol,negpol,omegapol]
		  env     : [pospol,negpol,omegapol]
		  mood    : RADVrec1.mood
		  kindefs NI Lk
		  radvkey : RADVrec1.key
		 }
              C11: RADVrec1.key = KEY_ergensRADVkey 
              A11: SUBADVrec1  := AUX_SUBADVreconR;
                   ADVrec1     := AUX_ADVreconR;
                   ADVPrec1    := AUX_ADVPreconR;
                   SUBADVrec1.possnietnp := true;
                   ADVrec1.possnietnp := true;
                   ADVPrec1.possnietnp := true;
              C12: RADVrec1.key = KEY_ergensRADVkey 
              A12: SUBADVrec1  := AUX_SUBADVreconR;
                   ADVrec1     := AUX_ADVreconR;
                   ADVPrec1    := AUX_ADVPreconR;
                   SUBADVrec1.possnietnp := true;
                   ADVrec1.possnietnp := false;
                   ADVPrec1.possnietnp := false;
          A1: SUBADVrec1.mood := RADVrec1.mood;
              ADVrec1.mood    := RADVrec1.mood;
              ADVPrec1.mood   := RADVrec1.mood;

              QUOTE_assdeixismax(CLAUSErec1.deixis, 
                 CLAUSErec1.superdeixis, ADVPrec1.superdeixis);
              ADVPVARrec1 := COPYT_advpTOvar(ADVPrec1);
              ADVPVARrec1.index := LEVEL; 
         >

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rsubstitution7
\item[* relevant examples:]
Hij werkt ergens; Hij werkt overal; Waar werkt hij? 
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] ClausetoSentence
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 27-APR-1988 09:44:01  
\item[* author:] Jan Odijk
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% RULE Rsubstitution16         (* NP in VARPREPP in S (shiftrel) *)
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             shiftrel/VARPREPP{VARPREPPrec1}
                     [ mu3,
                       rel2/I1::NPVAR{NPVARrec1},
                       mu4
                     ],
             mu6 
           ] 
SUBST:
  m2: T3=I3::NP{NPrec1}[I9:mu7]
>

< m :CLAUSE{CLAUSErec1}
           [ mu1,
             shiftrel/PREPP{PREPPrec1}
                     [ mu3,
                       I2:rel2/T4=I4::NP{NPrec2}[I10:mu8],
                       mu4
                     ],
             mu6 
           ] 
>

   MATCHCONDITIONS
      <
       m : QUOTE_substordercondition1(mu6)
       I9: NOT EXIST(mu7, [head/BIGPRO{}[mu10]])
       I10:NOT EXIST(mu8, [head/BIGPRO{}[mu10]])
       I1: NPVARrec1.index = LEVEL 
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP, enNP] = []
       I4: [NPrec2.NPhead] * [zichzelfNP, elkaarNP, enNP] = []
       m2: NOT QUOTE_NegPhrase(T3) AND
           QUOTE_Gsubstordercondition1(mu6,T3)
       I2: NOT QUOTE_NegPhrase(T4)
      >

   PARAMETERS
      <
       LEVEL
      >


      COMP
         <
          C1: 
              NPrec1.cases = [Nominative]   AND
              NPrec1.generic = nogeneric    AND
              QUOTE_deixismax(CLAUSErec1.deixis, 
                     CLAUSErec1.superdeixis, NPrec1.superdeixis)
              C11: NPVARrec1 = COPYT_nptovar(NPrec1) 
                            EXCEPT FOR [cases, mood] AND
                   NPVARrec1.mood = topicxpmood AND
                   NPrec1.mood = declxpmood     AND
                   VARPREPPrec1.mood = topicxpmood
              A11: QUOTE_assigncase(NPrec1,mu7,NPrec2,mu8,NPVARrec1.cases); 
                   PREPPrec1 := VARPREPPrec1;
                   PREPPrec1.mood := declxpmood
              C12: NPVARrec1 = COPYT_nptovar(NPrec1) 
                            EXCEPT FOR [cases] AND
                   NPrec1.mood = wh
              A12: QUOTE_assigncase(NPrec1,mu7,NPrec2,mu8,NPVARrec1.cases); 
                   PREPPrec1 := VARPREPPrec1;
          A1: NPrec2.generic := omegageneric;
              NPrec2.superdeixis := omegadeixis  ;
         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric AND
              NPrec2.superdeixis = omegadeixis
              C11: NPrec2.mood = declxpmood AND
                   PREPPrec1.mood = declxpmood
              A11: QUOTE_assigncase(NPrec2,mu8,NPrec1,mu7,[Nominative]); 
                   NPVARrec1 := COPYT_nptovar(NPrec2);
                   NPVARrec1.mood := topicxpmood;
                   VARPREPPrec1 := PREPPrec1;
                   VARPREPPrec1.mood := topicxpmood;
              C12: NPrec2.mood = wh
              A12: QUOTE_assigncase(NPrec2,mu8,NPrec1,mu7,[Nominative]); 
                   NPVARrec1 := COPYT_nptovar(NPrec2);
                   VARPREPPrec1 := PREPPrec1;
          A1: NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
              QUOTE_assdeixismax(CLAUSErec1.deixis, 
                     CLAUSErec1.superdeixis, NPrec1.superdeixis);
         >


&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rsubstitution16
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 25-JUL-1988 11:42:22  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rsubstitution17 (* hij keek x naar + het -> hij keek het+R naar 
                          x keek hij naar + wat -> wat+R keek hij naar
                       *)
< m1:CLAUSE{CLAUSErec1}
          [ mu1, 
            I1:rel1/RADVP{RADVPrec1}[head/I2::NPVAR{NPVARrec1}], 
            mu2, 
            predrel/VERBP{VERBPrec1}[mu3],
            mu4
          ] 

SUBST:  
m2:T3=NP{NPrec1}[mu5]
>

< m :CLAUSE{CLAUSErec1}
          [ mu1, 
            I1:rel1/RADVP{RADVPrec2}[I3:head/T4=NP{NPrec2}[mu6]], 
            mu2, 
            predrel/VERBP{VERBPrec1}[mu3],
            mu4
          ] 
  
>

   MATCHCONDITIONS
      <
       m : QUOTE_substordercondition(mu2, mu3, mu4)
       I1: rel1 IN [shiftrel, erposrel]
       I2: NPVARrec1.index = LEVEL
       m2: NOT QUOTE_NegPhrase(T3) AND
           QUOTE_Gsubstordercondition(mu2, mu3, mu4,T3)
       I3: NOT QUOTE_NegPhrase(T4)
      >
   PARAMETERS
      <
       LEVEL
      >

COMP
         <
          C1: 
              Nominative IN NPrec1.cases AND
              NPrec1.generic = nogeneric AND
              NPrec1.possRform = true    AND
              QUOTE_deixismax(CLAUSErec1.deixis, 
                  CLAUSErec1.superdeixis, NPrec1.superdeixis)
              C11: rel1 = shiftrel AND
                   NPVARrec1 = COPYT_nptovar(NPrec1) 
                         EXCEPT FOR [cases, mood] AND
                   NPVARrec1.mood = topicxpmood AND
                   NPrec1.mood = declxpmood AND
                   RADVPrec1.mood = topicxpmood
              A11: QUOTE_assigncase(NPrec1,mu5,NPrec2,mu6,NPVARrec1.cases);
                   RADVPrec2 := RADVPrec1;
                   RADVPrec2.mood :=  declxpmood
              C12: rel1 <> shiftrel AND
                   NPVARrec1 = COPYT_nptovar(NPrec1) 
                         EXCEPT FOR [cases] AND
                   NPrec1.mood = declxpmood AND
                   RADVPrec1.mood = declxpmood
              A12: QUOTE_assigncase(NPrec1,mu5,NPrec2,mu6,NPVARrec1.cases); 
                   RADVPrec2 := RADVPrec1;
              C13: NPVARrec1 = COPYT_nptovar(NPrec1) 
                         EXCEPT FOR [cases] AND
                   NPrec1.mood = wh
              A13: QUOTE_assigncase(NPrec1,mu5,NPrec2,mu6,NPVARrec1.cases); 
                   RADVPrec2 := RADVPrec1;
          A1: NPrec2.generic := omegageneric;
              NPrec2.superdeixis := omegadeixis;  
         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric AND
              NPrec2.possRform = true       AND
              NPrec2.superdeixis = omegadeixis
              C11: rel1 = shiftrel AND
                   NPrec2.mood = declxpmood AND
                   RADVPrec2.mood = declxpmood
              A11: QUOTE_assigncase(NPrec2,mu6,NPrec1,mu5,[Nominative]); 
                   NPVARrec1 := COPYT_nptovar(NPrec2);
                   NPVARrec1.mood := topicxpmood;
                   RADVPrec1 := RADVPrec2;
                   RADVPrec1.mood := topicxpmood;
              C12: rel1 <> shiftrel AND
                   NPrec2.mood = declxpmood AND
                   RADVPrec2.mood = declxpmood
              A12: QUOTE_assigncase(NPrec2,mu6,NPrec1,mu5,[Nominative]); 
                   NPVARrec1 := COPYT_nptovar(NPrec2);
                   RADVPrec1 := RADVPrec2;
              C13: NPrec2.mood = wh
              A13: QUOTE_assigncase(NPrec2,mu6,NPrec1,mu5,[Nominative]); 
                   NPVARrec1 := COPYT_nptovar(NPrec2);
                   RADVPrec1 := RADVPrec2;
          A1: QUOTE_assdeixismax(CLAUSErec1.deixis, 
                           CLAUSErec1.superdeixis, NPrec1.superdeixis);
              NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
         >

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rsubstitution17
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 8-SEP-1988 09:47:08  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE rsubstitution18 (* hij zwemt [ x vr] + het -> hij zwemt [ het+R vr]
                          [ x naar] kijkt hij + wat -> [ wat+R naar ] kijkt hij
                       *)
< m1:CLAUSE{CLAUSErec1}
          [ mu1, 
            I1:rel1/VARPREPP{VARPREPPrec1}
                     [ mu7, 
                       errel/RADVP{RADVPrec1}[ head/I2::NPVAR{NPVARrec1}],
                       mu8
                     ], 
            mu2, 
            predrel/VERBP{VERBPrec1}[mu3],
            mu4
          ] 

SUBST:  
m2:T3=NP{NPrec1}[mu5]
>

< m :CLAUSE{CLAUSErec1}
          [ mu1, 
            I1:rel1/PREPP{PREPPrec1}
                     [ mu7, 
                       errel/RADVP{RADVPrec2}[ I3:head/T4=NP{NPrec2}[mu6]],
                       mu8
                     ], 
            mu2, 
            predrel/VERBP{VERBPrec1}[mu3],
            mu4
          ] 
  
>

   MATCHCONDITIONS
      <
       m : QUOTE_substordercondition(mu2, mu3, mu4)
       I1: rel1 IN [shiftrel, locadvrel, tempadvrel]
       I2: NPVARrec1.index = LEVEL
       m2: NOT QUOTE_NegPhrase(T3) AND
           QUOTE_Gsubstordercondition(mu2, mu3, mu4,T3)
       I3: NOT QUOTE_NegPhrase(T4)
      >

   PARAMETERS
      <
       LEVEL
      >

COMP
         <
          C1: NPrec1.cases = [Rcase]   AND
              NPrec1.generic = nogeneric AND
              NPrec1.possRform = true AND
              QUOTE_deixismax(CLAUSErec1.deixis, 
                  CLAUSErec1.superdeixis, NPrec1.superdeixis)
              C11: rel1 = shiftrel AND
                   NPVARrec1 = COPYT_nptovar(NPrec1) 
                         EXCEPT FOR [cases, mood] AND
                   NPVARrec1.mood = topicxpmood AND
                   NPrec1.mood = declxpmood AND
                   RADVPrec1.mood = topicxpmood AND
                   VARPREPPrec1.mood = topicxpmood
              A11: QUOTE_assigncase(NPrec1,mu5,NPrec2,mu6,NPVARrec1.cases); 
                   RADVPrec2 := RADVPrec1;
                   RADVPrec2.mood := declxpmood;
                   PREPPrec1 := VARPREPPrec1;
                   PREPPrec1.mood := declxpmood;      
              C12: rel1 <> shiftrel AND
                   NPVARrec1 = COPYT_nptovar(NPrec1) 
                         EXCEPT FOR [cases] AND
                   NPrec1.mood = declxpmood AND
                   RADVPrec1.mood = declxpmood 
              A12: QUOTE_assigncase(NPrec1,mu5,NPrec2,mu6,NPVARrec1.cases); 
                   RADVPrec2 := RADVPrec1;
                   PREPPrec1 := VARPREPPrec1;
              C13: NPVARrec1 = COPYT_nptovar(NPrec1) 
                         EXCEPT FOR [cases] AND
                   NPrec1.mood = wh
              A13: QUOTE_assigncase(NPrec1,mu5,NPrec2,mu6,NPVARrec1.cases); 
                   RADVPrec2 := RADVPrec1;
                   PREPPrec1 := VARPREPPrec1;
          A1: NPrec2.generic := omegageneric;
              NPrec2.superdeixis := omegadeixis;  

         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric AND
              NPrec2.possRform = true AND
              Rcase IN NPrec2.cases   
              C11: rel1 = shiftrel AND
                   NPrec2.mood = declxpmood AND
                   RADVPrec2.mood = declxpmood AND
                   PREPPrec1.mood = declxpmood
              A11: QUOTE_assigncase(NPrec2,mu6,NPrec1,mu5,[Nominative]); 
                   NPVARrec1 := COPYT_nptovar(NPrec2);
                   NPVARrec1.mood := topicxpmood;
                   RADVPrec1 := RADVPrec2;
                   RADVPrec1.mood := topicxpmood;
                   VARPREPPrec1 := PREPPrec1;
                   VARPREPPrec1.mood := topicxpmood;
              C12: rel1 <> shiftrel AND
                   NPrec2.mood = declxpmood AND
                   RADVPrec2.mood = declxpmood
              A12: QUOTE_assigncase(NPrec2,mu6,NPrec1,mu5,[Nominative]); 
                   NPVARrec1 := COPYT_nptovar(NPrec2);
                   RADVPrec1 := RADVPrec2;
                   VARPREPPrec1 := PREPPrec1;
              C13: NPrec2.mood = wh
              A13: QUOTE_assigncase(NPrec2,mu6,NPrec1,mu5,[Nominative]); 
                   NPVARrec1 := COPYT_nptovar(NPrec2);
                   RADVPrec1 := RADVPrec2;
                   VARPREPPrec1 := PREPPrec1;
          A1: QUOTE_assdeixismax(CLAUSErec1.deixis, 
                           CLAUSErec1.superdeixis, NPrec1.superdeixis);
              NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
         >


&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] rsubstitution18
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 8-SEP-1988 09:55:49  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rsubstennp1
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             I1:rel1/I2::NPVAR{NPVARrec1},
             mu2,
             predrel/VERBP{VERBPrec1}[mu3],
             mu4 
           ] 

SUBST:
  m2:T3=NP{NPrec1}
        [ detrel/T1,
          head/CN{CNrec1}[head/EN(KEY_countenkey){ENrec1} ] ,
          I5:mu5
        ]
>

< m :CLAUSE{CLAUSErec1}
           [ mu1,
             I1:rel1/NP{NPrec2}
		  [ detrel/T1,
		    I5:mu5
		  ],
             mu2,
             predrel/VERBP{VERBPrec1}[mu3],
             mu4 
           ] 

>

   MATCHCONDITIONS
      <
       m : QUOTE_Substordercondition(mu2, mu3, mu4) 
       m2: QUOTE_Gsubstordercondition(mu2, mu3, mu4,T3)
       I1: rel1 IN [shiftrel, subjrel, preadvrel, postsubjrel]
       I2: NPVARrec1.index = LEVEL
       I5: NOT EXIST(mu5, [head/..])
      >

   PARAMETERS
      <
       LEVEL
      >

COMP
         <
          C1: NPrec1.cases = [Nominative]   AND
              NPrec1.generic = nogeneric AND
              NPrec1.NPhead = enNP AND
              NPVARrec1.NPhead = enokNP  AND
              CNrec1 = AUX_CNoncountEN EXCEPT FOR [numbers] AND
              NPrec1.number IN CNrec1.numbers AND
              QUOTE_deixismax(CLAUSErec1.deixis, 
                  CLAUSErec1.superdeixis, NPrec1.superdeixis)
              C11: rel1 = shiftrel AND
                   NPVARrec1 = COPYT_nptovar(NPrec1) 
                         EXCEPT FOR [cases, NPhead, mood] AND
                   NPVARrec1.mood = topicxpmood AND
                   NPrec1.mood = declxpmood
              A11: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
              C12: rel1 <> shiftrel AND
                   NPVARrec1 = COPYT_nptovar(NPrec1) 
                         EXCEPT FOR [cases, NPhead] AND
                   NPrec1.mood = declxpmood
              A12: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
              C13: NPVARrec1 = COPYT_nptovar(NPrec1) 
                         EXCEPT FOR [cases, NPhead] AND
                   NPrec1.mood = wh
              A13: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
          A1: NPrec2.generic := omegageneric;
              NPrec2.superdeixis := omegadeixis;  

         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric AND
              NPrec2.NPhead = enNP
              C11: rel1 = shiftrel AND
                   NPrec2.mood = declxpmood
              A11: NPrec1 := NPrec2;
                   NPrec1.cases := [Nominative]; 
                   NPVARrec1 := COPYT_nptovar(NPrec2);
                   NPVARrec1.mood := topicxpmood;
              C12: rel1 <> shiftrel AND
                   NPrec2.mood = declxpmood
              A12: NPrec1 := NPrec2;
                   NPrec1.cases := [Nominative]; 
                   NPVARrec1 := COPYT_nptovar(NPrec2);
              C13: NPrec2.mood = wh
              A13: NPrec1 := NPrec2;
                   NPrec1.cases := [Nominative]; 
                   NPVARrec1 := COPYT_nptovar(NPrec2);
          A1: QUOTE_assdeixismax(CLAUSErec1.deixis, 
                           CLAUSErec1.superdeixis, NPrec1.superdeixis);
              NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
              NPVARrec1.NPhead := enokNP;
              CNrec1 := AUX_CNoncountEN;
              CNrec1.numbers := [NPrec2.number];
         >




&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rsubstennp1
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 18-OCT-1988 13:43:30  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE RsubstenNP2
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      I1:rel1/I2::NPVAR{NPVARrec1},
                      mu3
                    ],         
             mu4 
           ] 

SUBST:
  m2:T3=NP{NPrec1}
        [ detrel/T1,
          head/CN{CNrec1}[head/EN(KEY_countenkey){ENrec1} ] ,
          I5:mu5
        ]
>

< m :CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                   [ mu2,
                     I1:rel1/NP{NPrec2}
			    [ detrel/T1,
			      I5:mu5
			    ],
                     mu3
                   ],
             mu4 
           ] 

>

   MATCHCONDITIONS
      <
       m2: QUOTE_Gsubstordercondition2(mu3, mu4,T3) 
       m : QUOTE_Substordercondition2(mu3, mu4) 
       I1: rel1 IN [objrel]
       I2: NPVARrec1.index = LEVEL
       I5: NOT EXIST(mu5, [head/..])
      >

   PARAMETERS
      <
       LEVEL
      >

COMP
         <
          C1: NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases, NPhead] AND
              NPrec1.cases = [Nominative]   AND
              NPrec1.generic = nogeneric AND
              NPrec1.NPhead = enNP AND
              NPVARrec1.NPhead = enokNP  AND
              CNrec1 = AUX_CNoncountEN EXCEPT FOR [numbers] AND
              NPrec1.number IN CNrec1.numbers 
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   NPrec2.superdeixis := omegadeixis
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: NPrec2 := NPrec1;
                   NPrec2.cases := NPVARrec1.cases;
                   NPrec2.superdeixis := omegadeixis  
          A1: NPrec2.generic := omegageneric
         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric AND
              NPrec2.NPhead = enNP
              C11: CLAUSErec1.deixis = omegadeixis AND
                   NPrec2.superdeixis = omegadeixis
              A11: NPrec1 := NPrec2;
                   NPrec1.cases := [Nominative]; 
                   NPrec1.superdeixis := CLAUSErec1.superdeixis;
              C12: CLAUSErec1.deixis <> omegadeixis AND
                   NPrec2.superdeixis = omegadeixis  
              A12: NPrec1 := NPrec2;
                   NPrec1.cases := [Nominative]; 
                   NPrec1.superdeixis := CLAUSErec1.deixis;
          A1: NPVARrec1 := COPYT_nptovar(NPrec2);
              NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.NPhead := enokNP;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
              CNrec1 := AUX_CNoncountEN;
              CNrec1.numbers := [NPrec2.number];
         >





&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RsubstenNP2
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 18-OCT-1988 13:57:31  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rbigprosubst
< m1:CLAUSE{CLAUSErec1}[ mu1, 
                         subjrel/NPVAR{NPVARrec1},
                         mu2, 
                         predrel/VERBP{VERBPrec1}[mu3 ],
                         mu4
                       ] 
SUBST:
 m2: T3=NP{NPrec1}[head/BIGPRO{BIGPROrec1}[mu10]]
>

< m :CLAUSE{CLAUSErec1}[ mu1, 
                         subjrel/NP{NPrec2}[head/BIGPRO{BIGPROrec1}[mu10]],
                         mu2, 
                         predrel/VERBP{VERBPrec1}[mu3 ],
                         mu4
                       ] 

>

   MATCHCONDITIONS
      <
       m2: QUOTE_Gsubstordercondition(mu2,mu3,mu4,T3)
       m : QUOTE_substordercondition(mu2,mu3,mu4)
       I1: NPVARrec1.index = LEVEL
      >

   PARAMETERS
      <
       LEVEL
      >

      COMP
         <
          C1: NPVARrec1 = COPYT_nptovar(NPrec1) AND
              NPVARrec1.superdeixis = omegadeixis AND   
              NPrec1.generic = nogeneric AND
              NPrec1.cases = [Nominative] AND
              CLAUSErec1.PROsubject = true  AND
              QUOTE_deixismax(CLAUSErec1.deixis, 
                      CLAUSErec1.superdeixis, NPrec1.superdeixis)
          A1: NPrec2 := NPrec1;
              NPrec2.generic := omegageneric;
              NPrec2.superdeixis := omegadeixis;
         >
      DECOMP
         <
          C1: NPrec2.generic = omegageneric AND
              Nominative IN NPrec2.cases    AND
              CLAUSErec1.PROsubject = true  AND
              NPrec2.superdeixis = omegadeixis
          A1: NPrec1 := NPrec2;
              NPrec1.generic := nogeneric;
              NPrec1.cases := [Nominative];
              QUOTE_assdeixismax(CLAUSErec1.deixis, 
                      CLAUSErec1.superdeixis, NPrec1.superdeixis);
              NPVARrec1 := COPYT_nptovar(NPrec2);
              NPVARrec1.generic := nogeneric;
              NPVARrec1.index := LEVEL;
         >


&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rbigprosubst
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 27-OCT-1988 21:03:55  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rsadjsubstitution1
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      predrel/ADJP{ADJPrec1}
                          [mu7, 
                           I2:rel1/I1::NPVAR{NPVARrec1},
                           mu8
                          ],
                      mu3
                    ],
             mu4 
           ] 
SUBST:
  m2: T3=I3::NP{NPrec1}[I9:mu5]
>

< m :CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      predrel/ADJP{ADJPrec1}
                          [mu7, 
                           I5:rel1/T4=I4::NP{NPrec2}[I10:mu6],
                           mu8
                          ],
                      mu3
                    ],
             mu4 
           ] 
>

   MATCHCONDITIONS
      <
       m : QUOTE_substordercondition(mu8, mu3, mu4) 
       m2: NOT EXIST(mu5,[head/BIGPRO{}[mu10]]) AND
           NOT QUOTE_NegPhrase(T3) AND
           QUOTE_Gsubstordercondition(mu8,mu3,mu4,T3) 
       I9 :NOT EXIST(mu5, [head/BIGPRO{}[mu10]])
       I10:NOT EXIST(mu6, [head/BIGPRO{}[mu10]])
       I1: NPVARrec1.index = LEVEL
       I2: rel1 IN [ objrel, indobjrel, dirargrel, predrel, argrel] 
       I5: rel1 IN [ objrel, indobjrel, dirargrel, predrel, argrel] AND
           NOT QUOTE_NegPhrase(T4)
       I3: [NPrec1.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec1.NPhead <> enNP  OR mass IN NPrec1.actcomas)
       I4: [NPrec2.NPhead] * [zichzelfNP, elkaarNP] = [] AND
           (NPrec2.NPhead <> enNP  OR mass IN NPrec2.actcomas)
      >

   PARAMETERS
      <
       LEVEL
      >


      COMP
         <
          C1: synzijn IN CLAUSErec1.synvpefs AND
              NPVARrec1 = COPYT_nptovar(NPrec1) EXCEPT FOR [cases] AND
              NPrec1.cases = [Nominative]   AND
              NPrec1.generic = nogeneric
              C11: CLAUSErec1.deixis = omegadeixis              AND
                   NPrec1.superdeixis = CLAUSErec1.superdeixis
              A11: QUOTE_assigncase(NPrec1,mu5,NPrec2,mu6,NPVARrec1.cases); 
                   NPrec2.superdeixis := omegadeixis
              C12: CLAUSErec1.deixis <> omegadeixis             AND
                   NPrec1.superdeixis = CLAUSErec1.deixis
              A12: QUOTE_assigncase(NPrec1,mu5,NPrec2,mu6,NPVARrec1.cases); 
                   NPrec2.superdeixis := omegadeixis  
          A1: NPrec2.generic := omegageneric
         >
      DECOMP
         <
          C1: synzijn IN CLAUSErec1.synvpefs AND
              NPrec2.generic = omegageneric 
              C11: CLAUSErec1.deixis = omegadeixis AND
                   NPrec2.superdeixis = omegadeixis
              A11: QUOTE_assigncase(NPrec2,mu6,NPrec1,mu5,[Nominative]); 
                   NPrec1.superdeixis := CLAUSErec1.superdeixis;
              C12: CLAUSErec1.deixis <> omegadeixis AND
                   NPrec2.superdeixis = omegadeixis  
              A12: QUOTE_assigncase(NPrec2,mu6,NPrec1,mu5,[Nominative]); 
                   NPrec1.superdeixis := CLAUSErec1.deixis;
          A1: NPVARrec1 := COPYT_nptovar(NPrec2);
              NPVARrec1.cases := NPrec2.cases;
              NPVARrec1.index := LEVEL;
              NPrec1.generic := nogeneric;
              NPVARrec1.generic := nogeneric;
         >

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rsadjsubstitution1
\item[* relevant examples:]
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 6-FEB-1989 13:46:21  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% RULE Rsoprosentsubst
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      complrel/I3::PROSENTVAR{PROSENTVARrec1},
                      mu3
                    ],
             mu4 
           ] 
SUBST:
  m2: T3=PROSENT{PROSENTrec1}
>

< m :CLAUSE{CLAUSErec2}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      objrel/PROSENT{PROSENTrec1},
                      mu3
                    ],
             mu4 
           ] 
>

   MATCHCONDITIONS
      <
       m2: QUOTE_Gsubstordercondition2(mu3,mu4,T3)  
       m : QUOTE_substordercondition2(mu3,mu4)
       I3: PROSENTVARrec1.index = LEVEL
      >

   PARAMETERS
      <
       LEVEL
      >


      COMP
         <
          C1: PROSENTVARrec1.so =  PROSENTrec1.so AND
              PROSENTrec1.so = true               AND
              CLAUSErec1.synvpefs * AUX_soprosentvps <> []
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.synvpefs := CLAUSErec1.synvpefs * AUX_soprosentvps;
         >
      DECOMP
         <
          C1: CLAUSErec2.synvpefs * AUX_soprosentvps <> [] AND
              PROSENTrec1.so = true
          A1: PROSENTVARrec1.so := PROSENTrec1.so;  
              PROSENTVARrec1.index := LEVEL;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * AUX_soprosentvps;
         >



&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rsoprosentsubst
\item[* relevant examples:]
hij denkt x1 +van wel-> hij denkt van wel
hij denkt x1 + van niet -> hij denkt van niet
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 8-JUN-1990 13:06:25  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rprepprosentsubst
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      prepobjrel/VARPREPP{VARPREPPrec1}
                           [mu5, objrel/I3::PROSENTVAR{PROSENTVARrec1}, mu6],
                      mu3
                    ],
             mu4 
           ] 
SUBST:
  m2: T3=PROSENT(KEY_hetPROSENTkey){PROSENTrec1}
>

< m :CLAUSE{CLAUSErec2}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ mu2,
                      prepobjrel/PREPP{PREPPrec1}
                        [mu5, 
                         objrel/NP{NPrec1}
                          [head/PERSPRO{PERSPROrec1}
                            [head/BPERSPRO(KEY_hetBPERSPROkey){BPERSPROrec1}] 
                          ],
                         mu6
                        ],
                      mu3
                    ],
             mu4 
           ] 
>

   MATCHCONDITIONS
      <
       m2: QUOTE_Gsubstordercondition2(mu3,mu4,T3)  
       m : QUOTE_substordercondition2(mu3,mu4)
       I3: PROSENTVARrec1.index = LEVEL
      >

   PARAMETERS
      <
       LEVEL
      >


      COMP
         <
          C1: PROSENTVARrec1.so =  PROSENTrec1.so AND
              CLAUSErec1.synvpefs * AUX_prepprosentvps <> []
          A1: PERSPROrec1 := AUX_PERSPROrecONhet;
              NPrec1      := AUX_NPonHETBPRSPR;
              NPrec1.cases := [Accusative];
              PERSPROrec1.persprocases := [Accusative]; 
              CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.synvpefs := CLAUSErec1.synvpefs * AUX_prepprosentvps;
         >
      DECOMP
         <
          C1: PERSPROrec1 = AUX_PERSPROrecONhet 
                              EXCEPT FOR [reduced, persprocases] AND
              NPrec1      = AUX_NPonHETBPRSPR EXCEPT FOR [cases] AND
              Accusative IN NPrec1.cases AND
              Accusative IN PERSPROrec1.persprocases AND
              CLAUSErec2.synvpefs * AUX_prepprosentvps <> []
          A1: PROSENTVARrec1.so := PROSENTrec1.so;  
              PROSENTVARrec1.index := LEVEL;
              CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.synvpefs := CLAUSErec2.synvpefs * AUX_prepprosentvps;
         >



&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rprepprosentsubst
\item[* relevant examples:]
hij dwingt hem tot x1 + PROSENT -> hij dwingt hem tot het
\item[* language:] (Dutch, English, Spanish) 
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 8-JUN-1990 13:10:45  
\item[* author:] 
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:]
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


%%
E 2
E 1
