
From:	LANDSBERGEN     1-JUL-1985 08:54  
To:	STOOTS

$FL 12
$PL 274,16
$LD 5
$OP SH=S,HY=1,la=E,ph=r,pn=c,AN=C
$NP 
$UC _
$SC &%
$AC @
$XC ~`

   

            Project ROSETTA : Machine Translation


            Topic     :  Rosetta2

    ---------------------------------------------------------







         Title        :  THE TRANSFER COMPONENTS FOR DUTCH IN ROSETTA2

         Author       :  Jan Landsbergen








         Doc.Nr       :  0028

         Date         :  85/06/28

         Status       :  concept

         Supersedes   :  

         Distribution :  project

         Clearance    :  Philips

         Keywords     :  semantic component, A-TRANSFER, G-TRANSFER
$fn 7

   ---------------------------------------------------------
    
    Philips Research Laboratories

    Nederlandse Philips Bedrijven B.V.
$ph Rosetta    Doc.nr: 0028            date:85/06/28
$Np 1
$LD 4
$c1 Introduction

$ According to the definition of M-grammars in R0011 the semantic component
specifies the intermediate language IL and the relation between the set of
syntactic derivation trees as defined by the syntactic component and the 
logical derivation trees of IL. This relation is defined by means
of functions A-TRANSFER and 
G-TRANSFER.$

$ According to R0011 IL is defined by specifying:$
$ (i) a set of 
basic meanings, i.e. their names (keys). This set, the IL dictionary,
 is not specified in
this document. To this finite dictionary the (countable infinite) set of
logical variables, corresponding to the syntactic variables, should be added.
Furthermore the set of integers (in ciphers) should be added. Obviously these
sets cannot be enumerated explicitly in a dictionary: their transfer is defined
"dynamically". The same holds for unknown words (a robustness measure).$
$ (ii) a set of meaning rules, i.e. their names. This has to be modified a
little. Just like M-rules the IL rules may have parameters. From a formal point
of view they
are not necessary, but in many cases they are convenient to have.
I will enumerate the IL rules and their parameters in section 2.$

$ The relation between syntactic and logical derivation trees
is defined in two ways, for analysis by the functions A-TR%B% (for
basic expressions) and A-TR%R% (for rules), for
generation by the functions G-TR%B% and G-TR%R%. 
The definition of A-TR%B% and G-TR%B% is given by means of lexicons
 (for variables, integers and unknown words
by means of procedures), not to be specified in this document. G-TR%R%
and A-TR%R% will be defined in sections 3 and 4 respectively.$ 
$ In the current Dutch grammar the functions G-TR%R% and A-TR%R%
are not entirely each other's reverse, mainly because of the way
time (tempus) is treated. There are no primitive semantic notions that
underly both the Dutch and the English tempus system and that are used in
the interlingua. Instead, both the Dutch and the English tempuses are used
as primitive notions 
in the interlingua. E.g. for the Dutch tempus "ott" there is a corresponding
term (a parameter value), "Lott", in IL, 
for the English simple present there is a separate term
in IL, LSimPres. In Dutch analysis the parameter "ott" is translated into
"Lott", unambiguously. In Dutch generation Lott is translated back into
ott again. In Dutch generative transfer we also find the translation of
LSimPres (the English simple present), which is never the result of
Dutch analytic transfer.In English generation Lott is translated ambiguously,
into the simple present tense, but also in the future present tense and into
the progressive versions of these tenses. This is an ad hoc solution for
a difficult problem. Its main weakness is that the semantic ambiguity 
of tempuses like the "ott" do not arise during analysis, but during generation.$
$ Another example of asymmetry in the transfer components is
the translation of infinitive times: they 
may be translated into finite times, but not vice versa.$
$c1 The IL rules and their parameters

$ In this section the IL rules, the number of their arguments 
 and the values of their parameters are 
enumerated. The parameters always have the names p[1], p[2] and p[3].$
$ No information will be given about the semantics of the rules. In
this respect this document is a bad example: in the future a (formal or
intuitive) description of the meaning of the rules should be supplied.
Other information to be added in the future is about the semantic types:
to each rule a condition on the types of its arguments may be added.$   

Lstartcl0            1 argument
                     p[1]: Lpresenttense, Lpasttense, Lomegatense
                     p[2]: Lhoofdzin, Lopencomplzin, Lgeslcomplzin, 
                           Lbijvbijzin, Ldatdeelzin, Lofdeelzin, Lwhdeelzin
                     p[3]: Limpenk, Limpmv, Lyesno, Lwhinterr, Ldeclarative
Lstartcl1            2 arguments      
                     p[1]: Lpresenttense, Lpasttense, Lomegatense
                     p[2]: Lhoofdzin, Lopencomplzin, Lgeslcomplzin, 
                           Lbijvbijzin, Ldatdeelzin, Lofdeelzin, Lwhdeelzin
                     p[3]: Limpenk, Limpmv, Lyesno, Lwhinterr, Ldeclarative
Lstartcl2            3 arguments
                     p[1]: Lpresenttense, Lpasttense, Lomegatense
                     p[2]: Lhoofdzin, Lopencomplzin, Lgeslcomplzin, 
                           Lbijvbijzin, Ldatdeelzin, Lofdeelzin, Lwhdeelzin
                     p[3]: Limpenk, Limpmv, Lyesno, Lwhinterr, Ldeclarative
Lstartcl3            4 arguments
                     p[1]: Lpresenttense, Lpasttense, Lomegatense
                     p[2]: Lhoofdzin, Lopencomplzin, Lgeslcomplzin, 
                           Lbijvbijzin, Ldatdeelzin, Lofdeelzin, Lwhdeelzin
                     p[3]: Limpenk, Limpmv, Lyesno, Lwhinterr, Ldeclarative
Lemptysubst          2 arguments
Lvp0                 1 argument
Lvpent               1 argument
Lvpentextrapos       1 argument
Lvpenter             1 argument 
Lvpentent            1 argument
Lvpentcompl          1 argument
Lvpentpred           1 argument
Lvpententent         1 argument
Lvpententcompl1      1 argument 
Lvpententcompl2      1 argument
Lvpententpred        1 argument
Lvoiceact            1 argument
Lvoicepass           1 argument
Lvoiceerpass         1 argument
Largsubstent         2 arguments
Largsubstpred        2 arguments
Largsubstsubsent     2 arguments
Largsubstopencl      2 arguments
Ltijdnonimp1         2 arguments
                        p[1]: Loinft,Lvinft, Loinftt, Lvinftt
                              Lott, Lovt, Lottt, Lovtt, Lvtt, Lvvt, Lvttt,
                              Lvvtt, Lvoltdwcltijd, Ltegdwcltijd, LSimPres,
                              LPresProg, LPastPerf, LPastPerfProg, 
                              LFutPresPerf, LFutPresPerfProg, LFutPastPerf, 
                              LFutPastPerfProg, LSimIng, LSimPP
                        p[2]: Lpresenttense, Lpasttense, Lomegatense
Ltijdimp                1 argument
Ltijdnonimp2            1 argument
                        p[1]: Ltegdwcltijd,Lvoltdwcltijd,LSimIng,LSimPP
Lorderhz                1 argument
Lorderbz                1 argument
Ladvsubsttest           2 arguments
Lclsubstadv             2 arguments
Lclsubstadvsent         2 arguments
Lclneg                  2 arguments
Lclpos                  1 argument
Lgeenshift              1 argument
Lwelshift1              1 argument
Lwelshift2              1 argument        
Linv                    1 argument
Lfinalcl                1 argument
Lendsent                1 argument
Lendrelcl               1 argument 
Lendsubsent             1 argument
Lendopencompl           1 argument
Lendadvsent             1 argument
Lutt1                   2 arguments
Lutt2                   1 argument
Lppstart                3 arguments
Lppsubstent             2 arguments
Lppemptysubst           2 arguments
Ladjpstart              2 arguments
                        p[1]: Lstellendpar, Levenpar, Lvergrpar, Lovertrpar,
                              Lverklpar, Londertrpar
                        p[2]: Lnegpartrue, Lnegparfalse  
Ladjpsubstadv           2 arguments      
Ladjpneg                2 arguments
Ladjpcomp               2 arguments
Ladjppp                 2 arguments
Ladjpemptysubst         2 arguments 
Ladvpstart              2 arguments
Ladvpsubstadv           2 arguments
Ladvpneg                2 arguments
Ladvpemptysubst         2 arguments
Lnpnoun                 1 argument
                        p[1]: Ldefall, Ldefone, Lindefone, Lindefsome, 
                              Lcountsing       
                        p[2]: truepar, falsepar
                        p[3]: Lpresenttense, Lpasttense, Lomegatense
Lnpfardemadj            1 argument   
Lnpneardemadj           1 argument
Lnpwatvwhadj            1 argument
Lnpwelkwhadj            1 argument
Lnphoeveelwhadj         1 argument
Lnpqadj                 2 arguments
Lnpperspro              1 argument
Lnpwhpro                1 argument
Lnpindefpro             1 argument
Lnpdempro               1 argument
Lnppropernoun           1 argument
                        p[1]: Lpresenttense, Lpasttense, Lomegatense
Lnppossadj              2 arguments       
Lnprelcl                2 arguments
Lnpadjp                 2 arguments           
Lnppp                   2 arguments
                        p[1]: Ltruepar, Lfalsepar
Lnpnump                 2 arguments        
Lnpcoord                3 arguments
Lnumpstart              2 arguments
Lnumpunit               2 arguments
Lnumpqadj               2 arguments
LBUG1                   1 argument
LBUG2                   2 arguments
Llocalnoun              1 argument       
                        p[1]: Ltruepar, Lfalsepar 
                        p[2]: meervoudpar, enkelvoudpar
Llocalverb              1 argument
                        p[1]: LVoltDwpar, LTegDwpar, LVerlTijdpar, 
                              LTegenwTijdpar, LInfinitiefpar 
Llocalqadj              1 argument      
Llocalperspro           1 argument
  
$c1 G-TRANSFER
$c2 Auxiliary functions
$ First a few auxiliary functions are defined, for the translation of 
parameters.$

$ The function GTRP defines the translation of parameters for the trivial
cases where there is a one-to-one correspondence between the IL-parameters
and the Dutch parameters. $

function GTRP(p):    (p is an IL parameter value,
                      the result is a Dutch parameter value)

p =   Lpresenttense    --> presenttense,
      Lpasttense       --> pasttense,
      Lomegatense      --> omegatense,
      Lhoofdzin        --> hoofdzin,
      Lopencomplzin    --> opencomplzin,
      Lgeslcomplzin    --> geslcomplzin,
      Lbijvbijzin      --> bijvbijzin,
      Ldatdeelzin      --> datdeelzin,
      Lofdeelzin       --> ofdeelzin,
      Lwhdeelzin       --> whdeelzin,
      Limpenk          --> impenk,
      Limpmv           --> impmv,
      Lyesno           --> yesno,
      Lwhinterr        --> whinterr,
      Ldeclarative     --> declarative,
      Lott             --> ott,
      Lovt             --> ovt,
      Loinft           --> oinft,
      Lottt            --> ottt,
      Lovtt            --> ovtt,
      Loinftt          --> oinftt,
      Lvtt             --> vtt,
      Lvvt             --> vvt,
      Lvinft           --> vinft,
      Lvttt            --> vttt,
      Lvvtt            --> vvtt,
      Lvinftt          --> vinftt,
      Lvoltdwcltijd    --> voltdwcltijd,
      Ltegdwcltijd     --> tegdwcltijd,
      LSimPres         --> ott,
      LPresProg        --> ott,
      LPastPerf        --> vvt,
      LPastPerfProg    --> vvt,
      LFutPresPerf     --> vttt,
      LFutPresPerfProg --> vttt,
      LFutPastPerf     --> vvtt,
      LFutPastPerfProg --> vvtt,
      LSimIng          --> tegdwcltijd,
      LSimPP           --> voltdwcltijd,
      Lomegacltijd     --> omegacltijd,
      Lstellendpar     --> stellendpar,
      Levenpar         --> evenpar,
      Lvergrpar        --> vergrpar,
      Lovertrpar       --> overtrpar,
      Lverklpar        --> verklpar,
      Londertrpar      --> ondertrpar,
      Ldefall          --> defall,
      Ldefone          --> defone,
      Lindefone        --> indefone,
      Lindefsome       --> indefsome,
      Lcountsing       --> countsing,
      Lnegpartrue      --> true,
      Lnegparfalse     --> false,
      Ltrue            --> true,
      Lfalse           --> false,
      Lprepobjtrue     --> true,
      Lprepobjfalse    --> false,
      Lenkelvoudpar    --> enkelvoudpar,
      Lmeervoudpar     --> meervoudpar,
      LVoltDwpar       --> VoltDwpar,
      LTegDwpar        --> TegDwpar,
      LVerlTijdpar     --> VerlTijdpar,
      LTegenwTijdpar   --> TegenwTijdpar,
      LInfinitiefpar   --> Infinitiefpar,


$ The function DERTIME is used for the translation of a non-finite tense
used in anterelclauses into
a finite tense, with the help of the parameter supertense.$

$RL 10 
function DERTIME(p,q)      (p and q IL parameter values,
                            q: a value of the interlingual parameter
                               for supertense,
                            p: a value of the interlingual parameter 
                               for cltijdpar (only the non-finite tempus), 
                            result: a value of the Dutch parameter cltijdpar)
begin
      if q in [Ltegdwcltijd,LSimIng,LProgIng,LSimIngPP]
      then
      begin if p=Lpasttense
            then temp:= ovt
            else temp:= ott
      end
      else
      begin if p=Lpasttense
            then temp:= vvt
            else temp:= vtt
      end;
      DERTIME:=temp;
end;{DERTIME}
 
$ The function INFFINTIME has a similar purpose as DERTIME, but for
infinitive tenses in complement sentences.$

$RL 10 
function INFFINTIME(p1,p2):        (p1, p2 are IL parameter values,
                                    p1 is the interlingual cltijdpar, only
                                    for infinitive times,
                                    p2 is the interlingual supertense,
                                    the result is a Dutch cltijdpar value)
begin
 
      if p1 in [Lvinft,LPerfInf,LPerfProgInf]
      then begin
           if p2 = Lpasttense
           then vvt
           else vtt
           end
      else
      if p1 = Loinftt
      then begin
           if p2 = Lpasttense
           then ovtt
           else ottt
           end
      else
      if p1 = Lvinftt
      then begin
           if p2 = Lpasttense
           then vvtt
           else vttt
           end
      else
           if p2 = Lpasttense
           then ovt
           else ott ;
 
      INFFINTIME:=temp;
end;{INFFINTIME}

$c2 Generative transfer of rules

$ Here the function G-TR%R% is specified, i.e. the translation of IL rules and 
parameter values into Dutch M-rules and parameter values. 
$ The IL 
parameters are always called p[1], p[2] or p[3].
In most cases there is a straightforward
correspondence between the parameters of Dutch or English and the
parameters of the IL rules.  For the 
trivial cases the translation of the parameters
is specified by the function GTRP. $
$ Often an IL rule is translated into more than one M-rule. In that case
it may be useful to express by means of bonuses what translations are
preferred (from a "local" point of view). 
This bonus information is not specified here, but it is present
in the implemented system.$

      Lstartcl0  -->
         (with parameters p[1], p[2], p[3])       
           if p[3]=Limper
           then          RSTARTCL0,
                            supertensepar := GTRP(p[1]),
                            clsoortpar    := GTRP(p[2]),
                            moodpar       := impenk,
                       + RSTARTCL0,
                            supertensepar := GTRP(p[1]),
                            clsoortpar    := GTRP(p[2]),
                            moodpar       := impmv,
           else          RSTARTCL0,
                            supertensepar := GTRP(p[1]),
                            clsoortpar    := GTRP(p[2]),
                            moodpar       := GTRP(p[3]),
      Lstartcl1  -->
         (with parameters p[1], p[2], p[3])       
           if p[3]=Limper
           then          RSTARTCL1,
                            supertensepar := GTRP(p[1]),
                            clsoortpar    := GTRP(p[2]),
                            moodpar       := impenk,
                       + RSTARTCL1,
                            supertensepar := GTRP(p[1]),
                            clsoortpar    := GTRP(p[2]),
                            moodpar       := impmv,
           else          RSTARTCL1,
                            supertensepar := GTRP(p[1]),
                            clsoortpar    := GTRP(p[2]),
                            moodpar       := GTRP(p[3]),
      Lstartcl2         
         (with parameters p[1], p[2], p[3])       
           if p[3]=Limper
           then          RSTARTCL2,
                            supertensepar := GTRP(p[1]),
                            clsoortpar    := GTRP(p[2]),
                            moodpar       := impenk,
                       + RSTARTCL2,
                            supertensepar := GTRP(p[1]),
                            clsoortpar    := GTRP(p[2]),
                            moodpar       := impmv,
           else          RSTARTCL2,
                            supertensepar := GTRP(p[1]),
                            clsoortpar    := GTRP(p[2]),
                            moodpar       := GTRP(p[3]),
       Lstartcl3         
         (with parameters p[1], p[2], p[3])       
           if p[3]=Limper
           then          RSTARTCL3,
                            supertensepar := GTRP(p[1]),
                            clsoortpar    := GTRP(p[2]),
                            moodpar       := impenk,
                       + RSTARTCL3,
                            supertensepar := GTRP(p[1]),
                            clsoortpar    := GTRP(p[2]),
                            moodpar       := impmv,
           else          RSTARTCL3,
                            supertensepar := GTRP(p[1]),
                            clsoortpar    := GTRP(p[2]),
                            moodpar       := GTRP(p[3]),

      Lemptysubst     --> REMPTYSUBST1,

      Lvp0            --> RVP0,

      Lvpent          --> RVP1 with vppar:= vp1a,

      Lvpentextrapos  --> RVP1 with vppar:= vp1b,

      Lvpenter        --> RVP1 with vppar:= vp1c,

      Lvpentent        --> RVP2 with vppar:= vp2a,
                         + RVP2 with vppar:= vp2f,
                         + RVP3

      Lvpentcompl      --> RVP2 with vppar:= vp2c,
                         + RVP2 with vppar:= vp2d, 

      Lvpentpred       --> RVP2 with vppar:= vp2e,

      Lvpententent     --> RVP4 with vppar:= vp3a,
                         + RVP5,

      Lvpententcompl1  --> RVP4 with vppar:= vp3c,
 
      Lvpententcompl2  --> RVP4 with vppar:= vp3d,

      Lvpententpred    --> RVP6,

      Lvoiceact        --> RVOICE1 with voicepar:= active,
                         + RVOICE2 with voicepar:= active,

      Lvoicepass       --> RVOICE1 with voicepar:= passive,
                         + RVOICE2 with voicepar:= passive,

      Lvoiceerpass     --> RVOICE3,

      Largsubstent     --> RARGSUBST1 + RARGSUBST2 + RARGSUBST3

      Largsubstpred    --> RARGSUBST4,

      Largsubstsubsent --> RARGSUBST5 + RARGSUBST6 + RARGSUBST7 + RARGSUBST11

      Largsubstopencl -->  RARGSUBST8 + RARGSUBST9 + RARGSUBST10 + RARGSUBST13

      Ltijdnonimp1      -->
          (with parameters p[1] and p[2])
          case p[1] of
            Loinft,
            Lvinft,
            Loinftt,
            Lvinftt     --> RTIJD1,
                             with   cltijdpar := GTRP(p[1]),
                                 supertensepar:= GTRP(p[2]),
                          + RTIJD1,
                             with   cltijdpar := INFFINTIME(p[1],p[2]),
                                 supertensepar:= GTRP(p[2]),
                                                 
            Lott,
            Lovt,
            Lottt,
            Lovtt,
            Lvtt,
            Lvvt,
            Lvttt,
            Lvvtt,
            Lvoltdwcltijd,
            Ltegdwcltijd,
            LSimPres,
            LPresProg,
            LPastPerf,
            LPastPerfProg,
            LFutPresPerf,
            LFutPresPerfProg,
            LFutPastPerf,
            LFutPastPerfProg,
            LSimIng,
            LSimPP      --> RTIJD1,
                             with   cltijdpar := GTRP(p[1]),
                                 supertensepar:= GTRP(p[2]),
            LSimPast    --> RTIJD1,
                             with   cltijdpar := ovt,
                                 supertensepar:= GTRP(p[2]),
                          + RTIJD1,
                             with   cltijdpar := vtt,
                                 supertensepar:= GTRP(p[2]),
            LPastProg   --> RTIJD1,
                             with   cltijdpar := ovt,
                                 supertensepar:= GTRP(p[2]),
                          + RTIJD1,
                             with   cltijdpar := vtt,
                                 supertensepar:= GTRP(p[2]),
            LFutPres   -->  RTIJD1,
                             with   cltijdpar := ott,
                                 supertensepar:= GTRP(p[2]),
                          + RTIJD1,
                             with   cltijdpar := ottt,
                                 supertensepar:= GTRP(p[2]),
            LFutPresProg--> RTIJD1,
                             with   cltijdpar := ott,
                                 supertensepar:= GTRP(p[2]),
                          + RTIJD1,
                             with   cltijdpar := ottt,
                                 supertensepar:= GTRP(p[2]),
            LFutPast    --> RTIJD1,
                             with   cltijdpar := ovt,
                                 supertensepar:= GTRP(p[2]),
                          + RTIJD1,
                             with   cltijdpar := ovtt,
                                 supertensepar:= GTRP(p[2]),
            LFutPastProg--> RTIJD1,
                             with   cltijdpar := ovt,
                                 supertensepar:= GTRP(p[2]),
                          + RTIJD1,
                             with   cltijdpar := ovtt,
                                 supertensepar:= GTRP(p[2]),
            LPresPerf   --> RTIJD1,
                             with   cltijdpar := vtt,
                                 supertensepar:= GTRP(p[2]),
                          + RTIJD1,
                             with   cltijdpar := ovt,
                                 supertensepar:= GTRP(p[2]),
            LPresPerfProg--> RTIJD1,
                             with   cltijdpar := vtt,
                                 supertensepar:= GTRP(p[2]),
                          +  RTIJD1,
                             with   cltijdpar := ovt,
                                 supertensepar:= GTRP(p[2]),
            LSimInf     --> RTIJD1,
                             with   cltijdpar := oinft,
                                 supertensepar:= GTRP(p[2]),
                          + RTIJD1,
                             with   cltijdpar := oinftt,
                                 supertensepar:= GTRP(p[2]),
                          + RTIJD1,
                             with   cltijdpar := INFFINTIME(p[1], p[2]),
                                 supertensepar:= GTRP(p[2]),
            LProgInf     --> RTIJD1,
                             with   cltijdpar := oinft,
                                 supertensepar:= GTRP(p[2]),
                           + RTIJD1,
                             with   cltijdpar := oinftt,
                                 supertensepar:= GTRP(p[2]),
                           + RTIJD1,
                             with   cltijdpar := INFFINTIME(p[1], p[2]),
                                 supertensepar:= GTRP(p[2]),
            LPerfInf     --> RTIJD1,
                             with   cltijdpar := vinft,
                                 supertensepar:= GTRP(p[2]),
                           + RTIJD1,
                             with   cltijdpar := vinftt,
                                 supertensepar:= GTRP(p[2]),
                           + RTIJD1,
                             with   cltijdpar := INFFINTIME(p[1], p[2]),
                                 supertensepar:= GTRP(p[2]),
            LPerfProgInf --> RTIJD1,
                             with   cltijdpar := vinft,
                                 supertensepar:= GTRP(p[2]),
                           + RTIJD1,
                             with   cltijdpar := vinftt,
                                 supertensepar:= GTRP(p[2]),
                           + RTIJD1,
                             with   cltijdpar := INFFINTIME(p[1], p[2]),
                                 supertensepar:= GTRP(p[2]),

      Ltijdimp        -->    RTIJD2,

      Ltijdnonimp2     -->
         (p[1], p[2])       
            if p[1] in [Ltegdwcltijd,Lvoltdwcltijd,LSimIng,LSimPP]
            then             RTIJD3,
                             with   cltijdpar := GTRP(p[1]),
                                 supertensepar:= GTRP(p[2]),
                           + RTIJD1,
                             with   cltijdpar := DERTIME(p[2], p[1]),
                                 supertensepar:= GTRP(p[2]),
            else             RTIJD1,
                             with   cltijdpar := DERTIME(p[2], p[1]),
                                 supertensepar:= GTRP(p[2]),

      Lorderhz        --> RORDER1 + RORDER2,
      Lorderbz        --> RORDER3 + RORDER4,
      Ladvsubsttest   --> RADVSUBSTTEST1,
      Lclsubstadv     --> RADVSUBST1,
      Lclsubstadvsent --> RADVSUBST2,
      Lclneg          --> RNEG1 + RNEG2,
      Lclpos          --> RPOS,
      Lgeenshift      --> RSHIFT1,
      Lwelshift1      --> RSHIFT2,
      Lwelshift2      --> RSHIFT3 + RSHIFT4,
      Linv            --> RINV1 + RINV2 + RINV3,
      Lfinalcl        --> RFINALCL1,
      Lendsent        --> RENDCL1,
      Lendrelcl       --> RENDCL2 + RENDCL6,
      Lendsubsent     --> RENDCL3 + RENDCL5,
      Lendopencompl   --> RENDCL4,
      Lendadvsent     --> RENDCL7,
      Lutt1           --> RUTT1,
      Lutt2           --> RUTT2,
      Lppstart        --> RPP1 + RPP2,
      Lppsubstent     --> RPP3,
      Lppemptysubst   --> RPP4,
      Ladjpstart      --> RADJP1,
         (p[1], p[2])       
                            with comppar := GTRP(p[1]),
                                 negpar  := GTRP(p[2]),
      Ladjpsubstadv   --> RADJP2,
      Ladjpneg        --> RADJP3,
      Ladjpcomp       --> RADJP4,
      Ladjppp         --> RADJP5,
      Ladjpemptysubst --> RADJP6,
      Ladvpstart      --> RADVP1,
      Ladvpsubstadv   --> RADVP2,
      Ladvpneg        --> RADVP3,
      Ladvpemptysubst --> RADVP4,
      Lnpnoun         --> RNP1,
        (p[1], p[2], p[3])       
                              with P     := GTRP(p[1]),
                                   VERKL := GTRP(p[2]),
                                   ST    := GTRP(p[3]),
      Lnpfardemadj     --> RNP2,
                             with DEM := far,
      Lnpneardemadj    --> RNP2,
                             with DEM := near,
      Lnpwatvwhadj     --> RNP3,
                             with WHA := watvoor,
      Lnpwelkwhadj     --> RNP3,
                             with WHA := welk,
      Lnphoeveelwhadj  --> RNP3,
                             with WHA := hoeveel,
      Lnpqadj         --> RNP4,
      Lnpperspro      --> RNP5,
      Lnpwhpro        --> RNP6,
      Lnpindefpro     --> RNP7,
      Lnpdempro       --> RNP8,
      Lnppropernoun   --> RNP9,
          (p[1])             with stpar := GTRP(p[1]),
      Lnppossadj      --> RNP10,
      Lnprelcl        --> RNP11, RNP12,
      Lnpadjp         --> RNP13, RNP14,
      Lnppp           --> RNP15,
          (p[1])             with prepobjpar := GTRP(p[1]),
      Lnpnump         --> RNP16,
      Lnpcoord        --> RNP17,
      Lnumpstart      --> RNUMP1,
      Lnumpunit       --> RNUMP2,
      Lnumpqadj       --> RNUMP3,
      LBUG1           --> RBUG1,
      LBUG2           --> RBUG2,
      Llocalnoun      --> RLOCALNOUN,
         (p[1], p[2])      with VERKL    := GTRP(p[1]),
                                getalpar := GTRP(p[2]),
      Llocalverb      --> RLOCALVERB,
         (p[1])            with verbformpar := GTRP(p[1]),
      Llocalqadj      --> RLOCALQADJ,
      Llocaladj       --> RLOCALADJ,
      Llocalperspro   --> RLOCALPERSPRO
$c1 A-TRANSFER
$c2 Auxiliary functions
$ First we define the auxiliary function ATRP, which specifies a translation
into IL for most of the parameter values. $

function ATRP (p):  ( Dutch parameter value --> IL parameter value )

           supertensepar: 
                      p =      presenttense     --> Lpresenttense;
                               pasttense        --> Lpasttense;
                               omegatense       --> Lomegatense;
           clsoortpar   : 
                               hoofdzin         --> Lhoofdzin;
                               opencomplzin     --> Lopencomplzin;
                               geslcomplzin     --> Lgeslcomplzin;
                               bijvbijzin       --> Lbijvbijzin;
                               datdeelzin       --> Ldatdeelzin;
                               ofdeelzin        --> Lofdeelzin;
                               whdeelzin        --> Lwhdeelzin;
                          
           moodpar      :
                               impenk           --> Limpenk;
                               impmv            --> Limpmv;
                               yesno            --> Lyesno;
                               whinterr         --> Lwhinterr;
                               declarative      --> Ldeclarative;
                           end;
           vppar        :  (* not translated by means of ATRP *)
           voicepar     :  (* not translated by means of ATRP *)
           cltijdpar    : 
                               ott              --> Lott;
                               ovt              --> Lovt;
                               oinft            --> Loinft;
                               ottt             --> Lottt;
                               ovtt             --> Lovtt;
                               oinftt           --> Loinftt;
                               vtt              --> Lvtt;
                               vvt              --> Lvvt;
                               vinft            --> Lvinft;
                               vttt             --> Lvttt;
                               vvtt             --> Lvvtt;
                               vinftt           --> Lvinftt;
                               voltdwcltijd     --> Lvoltdwcltijd;
                               tegdwcltijd      --> Ltegdwcltijd;
                               omegacltijd      --> Lomegacltijd;
           comparpar    : 
                               stellendpar      --> Lstellendpar;
                               evenpar          --> Levenpar;
                               vergrpar         --> Lvergrpar;
                               overtrpar        --> Lovertrpar;
                               verklpar         --> Lverklpar;
                               ondertrpar       --> Londertrpar;
           Ppar         : 
                               defall           --> Ldefall;
                               defone           --> Ldefone;
                               indefone         --> Lindefone;
                               indefsome        --> Lindefsome;
                               countsing        --> Lcountsing;
           negparpar    : 
                               true             --> Lnegpartrue;
                               false            --> Lnegparfalse;
           VERKLpar    : 
                               true             --> Ltrue;
                               false            --> Lfalse;
           DEMpar       :  (* not translated by means of ATRP *) 
           WHApar       :  (* not translated by means of ATRP *)
           prepobjpar   : 
                               true             --> Lprepobjtrue;
                               false            --> Lprepobjfalse;
           getalparpar  : 
                               enkelvoudpar     --> Lenkelvoudpar;
                               meervoudpar      --> Lmeervoudpar;
           verbformpar  : 
                               VoltDwpar        --> LVoltDwpar;
                               TegDwpar         --> LTegDwpar;
                               VerlTijdpar      --> LVerlTijdpar;
                               TegenwTijdpar    --> LTegenwTijdpar;
                               Infinitiefpar    --> LInfinitiefpar;
$c2 Analytic transfer of rules
     RSTARTCL0          -->  Lstartcl0    
     (* IL rule has the same number of parameters *)
         p[1] (supertensepar)  -->  ATRP(p[1]),
         p[2] (clsoortpar)     -->  ATRP(p[2]),
         p[3] (moodpar)        -->  ATRP(p[3]),
     RSTARTCL1          -->  Lstartcl1,
     (* IL rule has the same number of parameters *)
         p[1] (supertensepar)  -->  ATRP(p[1]),
         p[2] (clsoortpar)     -->  ATRP(p[2]),
         p[3] (moodpar)        -->  ATRP(p[3]),
     RSTARTCL2          -->  Lstartcl2,
     (* IL rule has the same number of parameters *)
         p[1] (supertensepar)  -->  ATRP(p[1]),
         p[2] (clsoortpar)     -->  ATRP(p[2]),
         p[3] (moodpar)        -->  ATRP(p[3]),
     RSTARTCL3          -->  Lstartcl3,
     (* IL rule has the same number of parameters *)
         p[1] (supertensepar)  -->  ATRP(p[1]),
         p[2] (clsoortpar)     -->  ATRP(p[2]),
         p[3] (moodpar)        -->  ATRP(p[3]),
     REMPTYSUBST1       -->  Lemptysubst,
     RVP0               -->  Lvp0,
     RVP1               
     (* the Dutch rule with a parameter is translated into an IL rule 
        without parameter; the transfer depends on the parameter value *)
         p[1] (vppar) = vp1a   -->  Lvpent,
                        vp1b   -->  Lvpentextrapos,
                        vp1c   -->  Lvpenter,
     RVP2               
     (* the Dutch rule with parameter is translated into an IL rule without
        parameter; the transfer depends on the parameter value *)
         p[1] (vppar) = vp2a   -->  Lvpentent,
                        vp2c   -->  Lvpentcompl,
                        vp2d   -->  Lvpentcompl,
                        vp2e   -->  Lvpentpred,
                        vp2f   -->  Lvpentent,
     RVP3               -->  Lvpentent,
     RVP4               
     (* the Dutch rule with parameter is translated into an IL rule without
        parameter; the transfer depends on the parameter value *)
         p[1] (vppar) = vp3a   -->  Lvpententent,
                        vp3c   -->  Lvpententcompl1,
                        vp3d   -->  Lvpententcompl2,
     RVP5               -->  Lvpententent,
     RVP6               -->  Lvpententpred,
     RVOICE1            -->  Lvoiceact,
     RVOICE2            -->  Lvoicepass,
     RVOICE3            -->  Lvoiceerpass,
     RARGSUBST1         -->  Largsubstent,
     RARGSUBST2         -->  Largsubstent,
     RARGSUBST3         -->  Largsubstent,
     RARGSUBST4         -->  Largsubstpred,
     RARGSUBST5         -->  Largsubstsubsent,
     RARGSUBST6         -->  Largsubstsubsent,
     RARGSUBST7         -->  Largsubstsubsent,
     RARGSUBST8         -->  Largsubstopencl,
     RARGSUBST9         -->  Largsubstopencl,
     RARGSUBST10        -->  Largsubstopencl,
     RARGSUBST11        -->  Largsubstsubsent,
     RARGSUBST12        -->  Largsubstmodal1,
     RARGSUBST13        -->  Largsubstopencl,
     RTIJD1             -->  Ltijdnonimp1,
     (* IL rule has the same number of parameters *)
          p[1] (cltijdpar)     --> ATRP(p[1]),
          p[2] (supertensepar) --> ATRP(p[2]),
     RTIJD2             -->  Ltijdimp,
     RTIJD3             -->  Ltijdnonimp2,
     (* IL rule has the same number of parameters *)
          p[1] (cltijdpar)     --> ATRP(p[1]),
          p[2] (supertensepar) --> ATRP(p[2]),
     RORDER1            -->  Lorderhz,
     RORDER2            -->  Lorderhz,
     RORDER3            -->  Lorderbz,
     RORDER4            -->  Lorderbz,
     RADVSUBSTTEST1     -->  Ladvsubsttest,
     RADVSUBST1         -->  Lclsubstadv,
     RADVSUBST2         -->  Lclsubstadvsent,
     RNEG1              -->  Lclneg,
     RPOS               -->  Lclpos,
     RSHIFT1            -->  Lgeenshift,
     RSHIFT2            -->  Lwelshift1,
     RSHIFT3            -->  Lwelshift2,
     RSHIFT4            -->  Lwelshift2,
     RINV1              -->  Linv,
     RINV2              -->  Linv,
     RINV3              -->  Linv,
     RFINALCL1          -->  Lfinalcl,
     RENDCL1            -->  Lendsent,
     RENDCL2            -->  Lendrelcl,
     RENDCL3            -->  Lendsubsent,
     RENDCL4            -->  Lendopencompl,
     RENDCL5            -->  Lendsubsent,
     RENDCL6            -->  Lendrelcl,
     RENDCL7            -->  Lendadvsent,
     RUTT1              -->  Lutt1,
     RUTT2              -->  Lutt2,
     RPP1               -->  Lppstart,
     RPP2               -->  Lppstart,
     RPP3               -->  Lppsubstent,
     RPP4               -->  Lppemptysubst,
     RADJP1             -->  Ladjpstart,
     (* IL rule has the same number of parameters *)
          p[1] (comppar) -->    ATRP(p[1]),
          p[2] (negpar)  -->    ATRP(p[2]),
     RADJP2             -->  Ladjpsubstadv,
     RADJP3             -->  Ladjpneg,
     RADJP4             -->  Ladjpcomp,
     RADJP5             -->  Ladjppp,
     RADJP6             -->  Ladjpemptysubst,
     RADVP1             -->  Ladvpstart,
     RADVP2             -->  Ladvpsubstadv,
     RADVP3             -->  Ladvpneg,
     RADVP4             -->  Ladvpemptysubst,
     RNP1               -->  Lnpnoun,
     (* IL rule has the same number of parameters *)
           p[1] (P)      -->  ATRP(p[1]),
           p[2] (VERKL)  -->  ATRP(p[2]),
           p[3] (ST)     -->  ATRP(p[3]),
     RNP2              
     (* the Dutch rule with parameter is translated into an IL rule without
        parameter; the transfer depends on the parameter value *)
           p[1] (DEM) = far  -->  Lnpfardemadj,
                        near -->  Lnpneardemadj,
     RNP3               
     (* the Dutch rule with parameter is translated into an IL rule without
        parameter; the transfer depends on the parameter value *)
         p[1] (WHA) = watvoor -->  Lnpwatvwhadj,
                      welk    -->  Lnpwelkwhadj,
                      hoeveel -->  Lnphoeveelwhadj,
     RNP4               -->  Lnpqadj,
     RNP5               -->  Lnpperspro,
     RNP6               -->  Lnpwhpro,
     RNP7               -->  Lnpindefpro,
     RNP8               -->  Lnpdempro,
     RNP9               -->  Lnppropernoun,
     (* IL rule has the same number of parameters *)
         p[1] (stpar) --> ATRP(p[1]),
     RNP10              -->  Lnppossadj,
     RNP11              -->  Lnprelcl,
     RNP12              -->  Lnprelcl,
     RNP14              -->  Lnpadjp,
     RNP15              -->  Lnppp,
     (* IL rule has the same number of parameters *)
         p[1] (prepobjpar) --> ATRP(p[1]),
     RNP16              -->  Lnpnump,
     RNP17              -->  Lnpcoord,
     RNUMP1             -->  Lnumpstart,
     RNUMP2             -->  Lnumpunit,
     RNUMP3             -->  Lnumpqadj,
     RBUG1              -->  LBUG1,
     RBUG2              -->  LBUG2,
     RLOCALNOUN         -->  Llocalnoun,
     (* IL rule has the same number of parameters *)
         p[1] (VERKL)    --> ATRP(p[1]),
         p[2] (getalpar) --> ATRP(p[2]),
     RLOCALVERB         -->  Llocalverb,
     (* IL rule has the same number of parameters *)
         p[1] (verbformpar) --> ATRP(p[1]),
     RLOCALQADJ         -->  Llocalqadj,
     RLOCALADJ          -->  Llocaladj,
     RLOCALPERSPRO      -->  Llocalperspro.

