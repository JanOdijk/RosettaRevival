DUTCH 76
&
\newpage
\begin{verbatim}
%
% RULE Rretroimperfective
< m1: CLAUSE{CLAUSErec1}
            [I1: mu1,
             predrel/VERBP{VERBPrec1}
                    [mu2,
                     rel1/VERB{VERBrec1}[mu3] 
                    ],
             mu4
            ] 
>

< m : CLAUSE{CLAUSErec2}
            [I1: mu1,
             predrel/VERBP{VERBPrec1}
                    [mu2,
                     rel1/VERB{VERBrec2}[mu3]
                    ],
             mu4
            ] 

>
   MATCHCONDITIONS
      <
       I1: EXIST (mu1, [tempadvrel/..])
      >

<
   SUBRULE

      < mu1: [mu5, I2: tempadvrel/ADVPVAR{ADVPVARrec1}[ ], mu6] >
      < mu1: [mu5, I2: tempadvrel/ADVPVAR{ADVPVARrec1}[ ], mu6] >

   MATCHCONDITIONS
      <
       I2: (ADVPVARrec1.retro = true)

      >

      COMP
         <
          C1: ((CLAUSErec1.aspect = imperfective) AND
               (CLAUSErec1.retro = false)
              )
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.retro := true;
              VERBrec2 := VERBrec1;
         >
      DECOMP
         <
          C1: ((CLAUSErec2.retro = true) AND
               (CLAUSErec2.aspect = imperfective)
              ) 
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.retro := false;
              VERBrec1 := VERBrec2;
         >

   SUBRULE
      < mu1: [mu5, I2: tempadvrel/PREPPVAR{PREPPVARrec1}[ ], mu6] >
      < mu1: [mu5, I2: tempadvrel/PREPPVAR{PREPPVARrec1}[ ], mu6] >

   MATCHCONDITIONS
      <
       I2: (PREPPVARrec1.retro = true)

      >

      COMP
         <
          C1: ((CLAUSErec1.aspect = imperfective) AND
               (CLAUSErec1.retro = false)
              )
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.retro := true;
              VERBrec2 := VERBrec1;
         >
      DECOMP
         <
          C1: ((CLAUSErec2.retro = true) AND
               (CLAUSErec2.aspect = imperfective)
              ) 
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.retro := false;
              VERBrec1 := VERBrec2;
         >

   SUBRULE
      < mu1: [mu5, I2: tempadvrel/SENTENCE{SENTENCErec1}[mu9],mu6] >
      < mu1: [mu5, I2: tempadvrel/SENTENCE{SENTENCErec1}[mu9],mu6] >

   MATCHCONDITIONS
      <
       I2: (SENTENCErec1.conjretro = true)

      >

      COMP
         <
          C1: ((CLAUSErec1.aspect = imperfective) AND
               (CLAUSErec1.retro = false)
              )
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.retro := true;
              VERBrec2 := VERBrec1;
         >
      DECOMP
         <
          C1: ((CLAUSErec2.retro = true) AND
               (CLAUSErec2.aspect = imperfective) 
              ) 
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.retro := false;
              VERBrec1 := VERBrec2;
         >
>
&
\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rretroimperfective
\item[* relevant examples:]  CL(..... al een poosje slapen)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Retrospectivity rules
\item[* date of creation:] 10-JUN-1987 
\item[* author:] Lisette appelo
\item[* copied from:] Rretroperfective
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 02/02/88\ \ \ \ \ author: Lisette Appelo
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Between the reference interval Re and the reference Rs holds a
relation "until".\\
This rule is meant for a clause that is marked for imperfective aspect and that
contains a reference adverbial variable
that has for its attribute retro the value true.\\
The resulting clause is
marked for retrospectivity.
\item[\ \ strategy:] deviation from accepted proposal of doc. 53. The reference 
time adverbial variables are no longer introduced by the retrospectivity rules 
but in a separate rule class following the retrospectivity rule class.
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:] T1 stands for a reference time adverbial 
variable of category ADVP, PREPP or SENTENCE.
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of
 parameters) 
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see also task)\\
This rule has the same semantics as Rretroperfective of Dutch
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\ 

\item rules:\\ Imperfective aspect rule and rule introducing a variable for a 
retrospective time adverbial.

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\
This rule has the same semantics as Rretroperfective

\item in other languages:\\
This rule corresponds to the Rretro rules in other grammars
\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: CONJSENT has been substituted by SENTENCE. Therefore, the 
generalisation over the time attribute {\em retro} is not possible anymore. the 
rule had to be split up in 3 subrules.\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% RULE Rretroperfective
< m1: CLAUSE{CLAUSErec1}
            [I1: mu1,
             predrel/VERBP{VERBPrec1}
                    [mu2,
                     I2: rel1/VERB{VERBrec1}[mu3] 
                    ],
             mu4
            ] 
>

< m : CLAUSE{CLAUSErec2}
            [I1: mu1,
             predrel/VERBP{VERBPrec1}
                    [mu2,
                     I3: rel1/VERB{VERBrec2}[mu3],
                     auxrel/VERB{VERBrec3}
                           [head/SUBVERB{SUBVERBrec1}
                               [head/T2]
                           ]
                    ],
              mu4
            ] 

>
   MATCHCONDITIONS
      <
       I1: EXIST (mu1, [tempadvrel/..])
       I2: rel1 <> auxrel OR
           (rel1 = auxrel AND [VERBrec1.subc] * [hebbenaux, zijnaux] = [])
       I3: rel1 <> auxrel OR
           (rel1 = auxrel AND [VERBrec2.subc] * [hebbenaux, zijnaux] = [])
      >

<
  SUBRULE (*ADVPVAR, hebben *)

      <mu1: [mu5, I2:tempadvrel/ADVPVAR{ADVPVARrec1}[ ], mu6]>
      <mu1: [mu5, I2:tempadvrel/ADVPVAR{ADVPVARrec1}[ ], mu6]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}>
 
   MATCHCONDITIONS
      <
       I2: (ADVPVARrec1.retro = true) AND
           (ADVPVARrec1.aspect = imperfective OR
            ADVPVARrec1.aspect = omegaaspect)

      >

     COMP
         <
          C1: ((CLAUSErec1.aspect = perfective) AND
               (CLAUSErec1.retro = false) AND
               ( hebaux IN VERBrec1.perfauxs)
              )                                AND
              VERBrec1.modus = omegamodus
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.retro := true;
              VERBrec2 := VERBrec1;
              VERBrec2.modus := pastpart;
              SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
               (* other attributes retain their default values *)
         >
      DECOMP
         <
          C1: ((CLAUSErec2.retro = true) AND
               (CLAUSErec2.aspect = perfective) AND
               (hebaux IN VERBrec2.perfauxs) AND
               (VERBrec2.modus = pastpart) AND
               (VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1)) AND
               (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) AND
               SUBVERBrec1.lastaffix = noaffix                 AND
               (VERBrec3 =
                { 
                  number       : omeganumber   
                  persons      : []   
                  eORenForm    : NoForm   
                  modus        : omegamodus
                  tense        : omegatense  
                  status       : bareV
                }
                )
                (* the default values for these attributes *)
              ) 
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.retro := false;
              VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

  SUBRULE (*PREPPVAR, hebben *)

      <mu1: [mu5, I2: tempadvrel/PREPPVAR{PREPPVARrec1}[ ], mu6]>
      <mu1: [mu5, I2: tempadvrel/PREPPVAR{PREPPVARrec1}[ ], mu6]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}>
 
   MATCHCONDITIONS
      <
       I2:(PREPPVARrec1.retro = true) AND
          (PREPPVARrec1.aspect = imperfective OR
            PREPPVARrec1.aspect = omegaaspect)

      >

     COMP
         <
          C1: ((CLAUSErec1.aspect = perfective) AND
               (CLAUSErec1.retro = false) AND
               ( hebaux IN VERBrec1.perfauxs) AND
               (VERBrec1.modus = omegamodus)
              )
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.retro := true;
               VERBrec2 := VERBrec1;
               VERBrec2.modus := pastpart;
               SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
               VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
               (* other attributes retain their default values *)
         >
      DECOMP
         <
          C1: ((CLAUSErec2.retro = true) AND
               (CLAUSErec2.aspect = perfective) AND
                (hebaux IN VERBrec2.perfauxs) AND
                (VERBrec2.modus = pastpart) AND
                (VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1)) AND
                (SUBVERBrec1.lastaffix = noaffix) AND
                (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) AND
                (VERBrec3 =
                { 
                  number       : omeganumber   
                  persons      : []   
                  eORenForm    : NoForm   
                  modus        : omegamodus
                  tense        : omegatense  
                  status       : bareV
                }
                )
                (* the default values for these attributes *)
              ) 
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.retro := false;
              VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

  SUBRULE (*SENTENCE, hebben *)

      <mu1: [mu5, I2: tempadvrel/SENTENCE{SENTENCErec1}[mu9],mu6]>
      <mu1: [mu5, I2: tempadvrel/SENTENCE{SENTENCErec1}[mu9],mu6]
       T2: BVERB(AUX_hebbenbverbkey){BVERBrec1}>
 
   MATCHCONDITIONS
      <
       I2:(SENTENCErec1.conjretro = true) AND
          (SENTENCErec1.conjaspect = imperfective OR
           SENTENCErec1.conjaspect = omegaaspect)

      >

     COMP
         <
          C1: ((CLAUSErec1.aspect = perfective) AND
               (CLAUSErec1.retro = false) AND
               ( hebaux IN VERBrec1.perfauxs) AND
               ( VERBrec1.modus = omegamodus)
              )
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.retro := true;
               VERBrec2 := VERBrec1;
               VERBrec2.modus := pastpart;
               SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
               VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
               (* other attributes retain their default values *)
         >
      DECOMP
         <
          C1: ((CLAUSErec2.retro = true) AND
               (CLAUSErec2.aspect = perfective) AND
               (hebaux IN VERBrec2.perfauxs) AND
               (VERBrec2.modus = pastpart) AND
                (VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1)) AND
                (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) AND
                (SUBVERBrec1.lastaffix = noaffix) AND
                (VERBrec3 =
                { 
                  number       : omeganumber   
                  persons      : []   
                  eORenForm    : NoForm   
                  modus        : omegamodus
                  tense        : omegatense  
                  status       : bareV
                }
                )
                (* the default values for these attributes *)
              ) 
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.retro := false;
              VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >
  SUBRULE (*ADVPVAR, zijn *)

      <mu1: [mu5, I2:tempadvrel/ADVPVAR{ADVPVARrec1}[ ], mu6]>
      <mu1: [mu5, I2:tempadvrel/ADVPVAR{ADVPVARrec1}[ ], mu6]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}>
 
   MATCHCONDITIONS
      <
       I2: (ADVPVARrec1.retro = true) AND
           (ADVPVARrec1.aspect = imperfective OR
            ADVPVARrec1.aspect = omegaaspect)
      >
 
     COMP
         <
          C1: ((CLAUSErec1.aspect = perfective) AND
               (CLAUSErec1.retro = false) AND
               ( isaux IN VERBrec1.perfauxs) AND
               ( VERBrec1.modus = omegamodus)
              )
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.retro := true;
               VERBrec2 := VERBrec1;
               VERBrec2.modus := pastpart;
               SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
               VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
               (* other attributes retain their default values *)
         >
      DECOMP
         <
          C1: ((CLAUSErec2.retro = true) AND
               (CLAUSErec2.aspect = perfective) AND
               (isaux IN VERBrec2.perfauxs) AND
               (VERBrec2.modus = pastpart) AND
                (VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1)) AND
                (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) AND
                (SUBVERBrec1.lastaffix = noaffix) AND
                (VERBrec3 =
                { 
                  number       : omeganumber   
                  persons      : []   
                  eORenForm    : NoForm   
                  modus        : omegamodus
                  tense        : omegatense  
                  status       : bareV
                }
                )
                (* the default values for these attributes *)
              ) 
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.retro := false;
              VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

  SUBRULE (*PREPPVAR, zijn *)

      <mu1: [mu5, I2: tempadvrel/PREPPVAR{PREPPVARrec1}[ ], mu6]>
      <mu1: [mu5, I2: tempadvrel/PREPPVAR{PREPPVARrec1}[ ], mu6]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}>
 
   MATCHCONDITIONS
      <
       I2:(PREPPVARrec1.retro = true) AND
          (PREPPVARrec1.aspect = imperfective OR
           PREPPVARrec1.aspect = omegaaspect)
      >

     COMP
         <
          C1: ((CLAUSErec1.aspect = perfective) AND
               (CLAUSErec1.retro = false) AND
               ( isaux IN VERBrec1.perfauxs) AND
               (VERBrec1.modus = omegamodus)
              )
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.retro := true;
               VERBrec2 := VERBrec1;
               VERBrec2.modus := pastpart;
               SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
               VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
               (* other attributes retain their default values *)
         >
      DECOMP
         <
          C1: ((CLAUSErec2.retro = true) AND
               (CLAUSErec2.aspect = perfective) AND
               (isaux IN VERBrec2.perfauxs) AND
               (VERBrec2.modus = pastpart) AND
                (VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1)) AND
                (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) AND
                (SUBVERBrec1.lastaffix = noaffix) AND
                (VERBrec3 =
                { 
                  number       : omeganumber   
                  persons      : []   
                  eORenForm    : NoForm   
                  modus        : omegamodus
                  tense        : omegatense  
                  status       : bareV
                }
                )
                (* the default values for these attributes *)
              ) 
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.retro := false;
              VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

  SUBRULE (*SENTENCE, zijn *)

      <mu1: [mu5, I2: tempadvrel/SENTENCE{SENTENCErec1}[mu9],mu6]>
      <mu1: [mu5, I2: tempadvrel/SENTENCE{SENTENCErec1}[mu9],mu6]
       T2: BVERB(AUX_zijnbverbkey){BVERBrec1}>
 
   MATCHCONDITIONS
      <
       I2:(SENTENCErec1.conjretro = true) AND
          (SENTENCErec1.conjaspect = imperfective OR
           SENTENCErec1.conjaspect = omegaaspect)
      >
 
     COMP
         <
          C1: ((CLAUSErec1.aspect = perfective) AND
               (CLAUSErec1.retro = false) AND
               ( isaux IN VERBrec1.perfauxs) AND
               (VERBrec1.modus = omegamodus)
              )
          A1: CLAUSErec2 := CLAUSErec1;
              CLAUSErec2.retro := true;
               VERBrec2 := VERBrec1;
               VERBrec2.modus := pastpart;
               SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
               VERBrec3 := COPYT_subverbtoverb(SUBVERBrec1);
               (* other attributes retain their default values *)
         >
      DECOMP
         <
          C1: ((CLAUSErec2.retro = true) AND
               (CLAUSErec2.aspect = perfective) AND
               (isaux IN VERBrec2.perfauxs) AND
               (VERBrec2.modus = pastpart) AND
                (VERBrec3 = COPYT_subverbtoverb(SUBVERBrec1)) AND
                (SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1)) AND
                (SUBVERBrec1.lastaffix = noaffix) AND
                (VERBrec3 =
                { 
                  number       : omeganumber   
                  persons      : []   
                  eORenForm    : NoForm   
                  modus        : omegamodus
                  tense        : omegatense  
                  status       : bareV
                }
                )
                (* the default values for these attributes *)
              ) 
          A1: CLAUSErec1 := CLAUSErec2;
              CLAUSErec1.retro := false;
              VERBrec1 := VERBrec2;
              VERBrec1.modus := omegamodus;
         >

>
&
\end{verbatim}
\newpage
\begin{description}
\item[* name:] Rretroperfective
\item[* relevant examples:]
 CL(.....geslapen hebben)\\
 CL(.....gevallen zijn)
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Retrospectivity rules
\item[* date of creation:] 10-JUN-1987 
\item[* author:] Lisette appelo
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 02/02/88\ \ \ \ \ author: Lisette Appelo
\item date: 16/10/90\ \ \ \ \ author: Lisette Appelo\\
Allowed also omegaaspect retro adverbials
\end{enumerate}
\item[* task:] Between the reference interval Re and the reference Rs holds a
relation "until".\\
This rule is meant for a clause that is marked for perfective aspect and that
contains a variable that has for its attribute retro the value true.\\
The auxiliary verb {\em hebben} or {\em zijn}
 is introduced to the right of the most right
verb of the input clause which is given
the modus form pastpart and the resulting clause is
marked for retrospectivity.
\item[\ \ strategy:] deviation from accepted proposal of doc. 53. There is no 
reference adverbial variable introduced by this rule; this is done by a rule 
class following the retrospectivity rule class.
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:] T1 stands for a variable for a reference 
adverbial of category ADVP, PREPP or SENTENCE. T2 stands for the auxiliary verb 
{\em hebben} or {\em zijn}.
\item[\ \ clarification of the splitting up into subrules:]
1: for verbs that take HEBBEN as auxiliary for the "voltooide tijden" 
(attribute perfauxs)\\
2: for verbs that take ZIJN as auxiliary for the "voltooide tijden" (attribute
perfauxs)\\
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of
 parameters) 
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] function application (see also task)\\
This rule has the same semantics as Rretroimperfective of Dutch
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\ 

\item rules:\\ Perfective aspect rule and rule for insertion of a retrospective 
time adverbial variable are applied.

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\
This rule has the same semantics as Rretroimperfective

\item in other languages:\\
This rule corresponds to the Rretro rules in other grammars
\end{enumerate}
\item[* relevant literature/documents:] doc 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: CONJSENT has been substituted by SENTENCE. Therefore, the 
generalisation over the time attribute {\em retro} was no longer possible. the 
rule had to be split up in 3 parts. This makes here 6 subrules.\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% TRANSFORMATION Tpassivegewordendeletion
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            predrel/VERBP{VERBPrec1}
                   [mu2,
                    rel1/VERB{VERBrec1}[mu3],  
                    auxrel/VERB{VERBrec2}
                          [head/SUBVERB{SUBVERBrec1}
                               [head/BVERB(AUX_wordenbverbkey){BVERBrec1}]
                          ],
                     auxrel/VERB{VERBrec3}
                           [head/SUBVERB{SUBVERBrec2}
                                [head/BVERB(AUX_zijnbverbkey){BVERBrec2}]
                           ]
                    ]
             ]
>

< m :CLAUSE{CLAUSErec1}
           [mu1,
            predrel/VERBP{VERBPrec1}
                   [mu2,
                    rel1/VERB{VERBrec1}[mu3],  
                    auxrel/VERB{VERBrec3}
                          [head/SUBVERB{SUBVERBrec2}
                              [head/BVERB(AUX_zijnbverbkey){BVERBrec2}]
                          ]
                    ]
             ]

>
      COMP
         <
          C1: ((CLAUSErec1.voice = passive) AND
               (VERBrec1.modus = pastpart) AND
               (VERBrec2.modus = pastpart)) AND
               SUBVERBrec1 = COPYT_bverbtosubverb(BVERBrec1) AND
               SUBVERBrec1.lastaffix = noaffix AND
               VERBrec2 = COPYT_subverbtoverb(SUBVERBrec1) AND
                (VERBrec2 =
                { 
                  number       : omeganumber   
                  persons      : []   
                  eORenForm    : NoForm   
                  tense        : omegatense  
                  status       : bareV
                }
                )
                (* the default values for these attributes *)
          A1: @
         >
      DECOMP
         <
          C1: ((CLAUSErec1.voice = passive) AND
               (VERBrec1.modus = pastpart))
          A1: SUBVERBrec1 := COPYT_bverbtosubverb(BVERBrec1);
              VERBrec2 := COPYT_subverbtoverb(SUBVERBrec1);
              VERBrec2.modus := pastpart
              (* other values retain the default values *)
         >

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Tpassivegewordendeletion
\item[* relevant examples:] geslagen geworden zijn <--> geslagen zijn
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Passivegewordendeletion transformations
\item[* date of creation:] 13-FEB-1987 16:30:23  
\item[* author:] Lisette Appelo
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Delete "geworden" that resulted from the passive auxiliary
"worden" and the application of the perfective retrospective rule.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] no
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\ passive voice rule that introduces the auxiliary "worden"
and gives the (main) verb the modus pastpart.\\
Perfective retrospective rule that introduces the auxiliary "zijn" and gives
"worden" the modus pastpart.

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% FILTER Fpassivegewordendeletion
< m:CLAUSE{CLAUSErec1}
           [mu1,
            predrel/VERBP{VERBPrec1}
                   [mu2,
                    rel1/VERB{VERBrec1}[mu3],  
                    auxrel/VERB{VERBrec2}
                          [head/SUBVERB{SUBVERBrec1}
                               [head/BVERB(AUX_wordenbverbkey){BVERBrec1}]
                          ],
                     auxrel/VERB{VERBrec3}
                           [head/SUBVERB{SUBVERBrec2}
                                [head/BVERB(AUX_zijnbverbkey){BVERBrec2}]
                           ]
                    ]
             ]
>

         <
          C1: ((CLAUSErec1.voice = passive) AND
               (VERBrec1.modus = pastpart) AND
               (VERBrec2.modus = pastpart))
          A1: @
         >

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Fpassivegewordendeletion
\item[* relevant examples:] geslagen geworden zijn <--> geslagen zijn
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] Passivegewordendeletion filters
\item[* date of creation:] 14-MAR-1988 
\item[* author:] Lisette Appelo
\item[* copied from:] Tpassivegewordendeletion
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Filter "geworden" that resulted from the passive auxiliary
"worden" and the application of the perfective retrospective rule.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:] no
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\ passive voice rule that introduces the auxiliary "worden"
and gives the (main) verb the modus pastpart.\\
Perfective retrospective rule that introduces the auxiliary "zijn" and gives
"worden" the modus pastpart.

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
%
%
