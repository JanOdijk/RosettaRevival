DUTCH 12
&
\newpage
\begin{verbatim}
%
% TRANSFORMATION TSpruning1
< m1:CLAUSE{CLAUSErec1}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ I3:mu2,
                      complrel/I1::SENTENCE{SENTENCErec1}[I2:mu3],
                      I4:rel1/VERB{VERBrec1}
                             [ rel2/VERB{VERBrec2}[mu6],
                               rel3/VERB{VERBrec3}[mu7]
                             ],
                      I8:mu8
                    ],
             mu5 
           ]
>

< m :CLAUSE{CLAUSErec2}
           [ mu1,
             predrel/VERBP{VERBPrec1}
                    [ I3:mu2,
                      I2:mu3,
                      I4:rel1/VERB{VERBrec1}
                             [ rel2/VERB{VERBrec2}[mu6],
                               rel3/VERB{VERBrec3}[mu7]
                             ],
                      I8:mu8
                    ],
             mu5 
           ]
>

   MATCHCONDITIONS
      <
       I1 : SENTENCErec1.VRcompl = true
       I2 : ALL(mu3, I12:rel4/..)
       I3 : NOT EXIST(mu2, [I12:rel4/..])
       I4 : rel1 IN [head, auxrel, progauxrel]
       I8 : ALL(mu8, I18:rel5/..)
            I18: rel5 IN AUX_postverbrels
       I12: rel4 IN [partrel, head, auxrel, progauxrel ]
      >


<


   SUBRULE            (* wil zwemmen, probeert te zwemmen *)
      <mu3: [mu9]>
      <mu3: [mu9]>

   MATCHCONDITIONS
      <
       mu3: NOT EXIST(mu9,[head/..])
      >

      COMP
         <
          C1: (rel2 <> auxrel OR [VERBrec3.status] * [VV] = []) AND
              VERBrec1.Verbraiser IN [optionalVR, obligatoryVR] AND
              CLAUSErec1.synvpefs * AUX_sentvps <> [] AND
              CLAUSErec1.adjuncts = []                AND
              SENTENCErec1 =
	       {
	       req         : [pospol, negpol, omegapol]
	       env         : [pospol, negpol, omegapol]
	       mood        : declarative
	       senttype    : subordinateclause
	       voice       : omegavoice
	       modus       : infinitive
               thetavp     : VERBrec3.thetavp
	       aspect      : omegaAspect
	       deixis      : Omegadeixis
	       retro       : false
	       finiteness  : infinite
	       infsort     : inf
	       superdeixis : omegadeixis  
	       VRcompl     : true
	       conjkey     : 0
	       adverbial   : false
	       temporal    : false
	       conjclass   : omegaTimeAdvClass
	       conjdeixis  : omegadeixis
	       conjaspect  : omegaAspect
	       conjretro   : false
	       } AND


               SENTENCErec1.synvpefs * VERBrec3.synvps <> [] AND
               QUOTE_checkaktarts(VERBrec3.classes, SENTENCErec1.aktionsarts) 
               C11: CLAUSErec1.synvpefs * AUX_opensentvps <> [] AND
                    SENTENCErec1.PROsubject = true
               A11: CLAUSErec2 := CLAUSErec1;
                    CLAUSErec2.synvpefs := 
                              CLAUSErec1.synvpefs * AUX_opensentvps 
               C12: CLAUSErec1.synvpefs * AUX_closedsentvps <> [] AND
                    SENTENCErec1.PROsubject = false
               A12: CLAUSErec2 := CLAUSErec1;
                    CLAUSErec2.synvpefs :=
                              CLAUSErec1.synvpefs * AUX_closedsentvps
          A1: CLAUSErec2.adjuncts := SENTENCErec1.adjuncts;
         >
      DECOMP
         <
          C1: (rel2 <> auxrel OR [VERBrec3.status] * [VV] = []) AND
              VERBrec1.Verbraiser IN [optionalVR, obligatoryVR] AND
              CLAUSErec2.synvpefs * AUX_sentvps <> [] 
              C11: CLAUSErec2.synvpefs * AUX_opensentvps <> [] 
              A11: SENTENCErec1.PROsubject  := true;
                   CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs :=  
                             CLAUSErec2.synvpefs * AUX_opensentvps
              C12: CLAUSErec2.synvpefs * AUX_closedsentvps <> [] 
              A12: SENTENCErec1.PROsubject  := false;
                   CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs :=  
                             CLAUSErec2.synvpefs * AUX_closedsentvps
          A1: SENTENCErec1 :=
              {
	       req         : [pospol, negpol, omegapol]
	       env         : [pospol, negpol, omegapol]
	       mood        : declarative
	       senttype    : subordinateclause
	       voice       : omegavoice
	       synvpefs    : VERBrec3.synvps
               adjuncts    : CLAUSErec2.adjuncts
	       thetavp     : VERBrec3.thetavp
	       modus       : infinitive
	       aspect      : omegaAspect
	       deixis      : Omegadeixis
	       retro       : false
	       finiteness  : infinite
	       infsort     : inf
	       superdeixis : omegadeixis  
	       VRcompl     : true
	       conjkey     : 0
	       adverbial   : false
	       temporal    : false
	       conjclass   : omegaTimeAdvClass
	       conjdeixis  : omegadeixis
	       conjaspect  : omegaAspect
	       conjretro   : false
	       } ;
	       QUOTE_assignAktarts(VERBrec3.classes, SENTENCErec1.aktionsarts);
               CLAUSErec1.adjuncts := [];
         >


          
   SUBRULE     (* heeft zien zwemmen *)
      <mu3: [mu9]
       mu7: [mu11, adjoinrel/VERB{VERBrec4}[mu10]]
      >
      
      <mu3: [mu9]
       mu7: [mu11, adjoinrel/VERB{VERBrec4}[mu10]]
      >

   MATCHCONDITIONS
      <
       mu3: NOT EXIST(mu9,[head/..])
      >

      COMP
         <
          C1: rel2 = auxrel AND VERBrec3.status IN [VV] AND
              VERBrec1.Verbraiser IN [optionalVR, obligatoryVR] AND
              CLAUSErec1.synvpefs * AUX_sentvps <> [] AND
              CLAUSErec1.adjuncts = []                AND
              SENTENCErec1 =
	       {
	       req         : [pospol, negpol, omegapol]
	       env         : [pospol, negpol, omegapol]
	       mood        : declarative
	       senttype    : subordinateclause
	       voice       : omegavoice
	       modus       : infinitive
               thetavp     : VERBrec4.thetavp
	       aspect      : omegaAspect
	       deixis      : Omegadeixis
	       retro       : false
	       finiteness  : infinite
	       infsort     : inf
	       superdeixis : omegadeixis  
	       VRcompl     : true
	       conjkey     : 0
	       adverbial   : false
	       temporal    : false
	       conjclass   : omegaTimeAdvClass
	       conjdeixis  : omegadeixis
	       conjaspect  : omegaAspect
	       conjretro   : false
	       } AND


               SENTENCErec1.synvpefs * VERBrec4.synvps <> [] AND
               QUOTE_checkaktarts(VERBrec4.classes, SENTENCErec1.aktionsarts) 
               C11: CLAUSErec1.synvpefs * AUX_opensentvps <> [] AND
                    SENTENCErec1.PROsubject = true
               A11: CLAUSErec2 := CLAUSErec1;
                    CLAUSErec2.synvpefs := 
                              CLAUSErec1.synvpefs * AUX_opensentvps 
               C12: CLAUSErec1.synvpefs * AUX_closedsentvps <> [] AND
                    SENTENCErec1.PROsubject = false
               A12: CLAUSErec2 := CLAUSErec1;
                    CLAUSErec2.synvpefs :=
                              CLAUSErec1.synvpefs * AUX_closedsentvps
          A1:  CLAUSErec2.adjuncts := SENTENCErec1.adjuncts;
         >
      DECOMP
         <
          C1: rel2 = auxrel AND VERBrec3.status IN [VV] AND
              VERBrec1.Verbraiser IN [optionalVR, obligatoryVR] AND
              CLAUSErec2.synvpefs * AUX_sentvps <> [] 
              C11: CLAUSErec2.synvpefs * AUX_opensentvps <> [] 
              A11: SENTENCErec1.PROsubject  := true;
                   CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs :=  
                             CLAUSErec2.synvpefs * AUX_opensentvps
              C12: CLAUSErec2.synvpefs * AUX_closedsentvps <> [] 
              A12: SENTENCErec1.PROsubject  := false;
                   CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs :=  
                             CLAUSErec2.synvpefs * AUX_closedsentvps
          A1: SENTENCErec1 :=
              {
	       req         : [pospol, negpol, omegapol]
	       env         : [pospol, negpol, omegapol]
	       mood        : declarative
	       senttype    : subordinateclause
	       voice       : omegavoice
	       synvpefs    : VERBrec4.synvps
	       thetavp     : VERBrec4.thetavp
               adjuncts    : CLAUSErec2.adjuncts
	       modus       : infinitive
	       aspect      : omegaAspect
	       deixis      : Omegadeixis
	       retro       : false
	       finiteness  : infinite
	       infsort     : inf
	       superdeixis : omegadeixis  
	       VRcompl     : true
	       conjkey     : 0
	       adverbial   : false
	       temporal    : false
	       conjclass   : omegaTimeAdvClass
	       conjdeixis  : omegadeixis
	       conjaspect  : omegaAspect
	       conjretro   : false
	       } ;
	       QUOTE_assignAktarts(VERBrec4.classes, SENTENCErec1.aktionsarts);
               CLAUSErec1.adjuncts := [];

         >


   SUBRULE   (* gekocht kan hebben, opgebeld probeert te hebben *)
      <mu3: [mu9]>
      <mu3: [mu9]>

   MATCHCONDITIONS
      <
       mu3: EXIST(mu9,[head/VERB{VERBrec4}[mu10]])
      >

      COMP
         <
          C1: VERBrec1.Verbraiser IN [optionalVR, obligatoryVR] AND
              CLAUSErec1.synvpefs * AUX_sentvps <> [] AND
              VERBrec3.status IN [bareV, teV] AND
              VERBrec3.subc IN [hebbenaux, zijnaux, wordenaux] AND
              CLAUSErec1.adjuncts = []                AND
              SENTENCErec1 =
	       {
	       req         : [pospol, negpol, omegapol]
	       env         : [pospol, negpol, omegapol]
	       mood        : declarative
	       senttype    : subordinateclause
	       voice       : omegavoice
	       modus       : infinitive
               thetavp     : VERBrec4.thetavp
	       aspect      : omegaAspect
	       deixis      : Omegadeixis
	       retro       : false
	       finiteness  : infinite
	       infsort     : inf
	       superdeixis : omegadeixis  
	       VRcompl     : true
	       conjkey     : 0
	       adverbial   : false
	       temporal    : false
	       conjclass   : omegaTimeAdvClass
	       conjdeixis  : omegadeixis
	       conjaspect  : omegaAspect
	       conjretro   : false
	       } AND
               SENTENCErec1.synvpefs * VERBrec4.synvps <> [] AND
               QUOTE_checkaktarts(VERBrec4.classes, SENTENCErec1.aktionsarts)
               C11: CLAUSErec1.synvpefs * AUX_opensentvps <> [] AND
                    SENTENCErec1.PROsubject = true
               A11: CLAUSErec2 := CLAUSErec1;
                    CLAUSErec2.synvpefs := 
                              CLAUSErec1.synvpefs * AUX_opensentvps 
               C12: CLAUSErec1.synvpefs * AUX_closedsentvps <> [] AND
                    SENTENCErec1.PROsubject = false
               A12: CLAUSErec2 := CLAUSErec1;
                    CLAUSErec2.synvpefs :=
                              CLAUSErec1.synvpefs * AUX_closedsentvps
          A1:  CLAUSErec2.adjuncts := SENTENCErec1.adjuncts;
         >
      DECOMP
         <
          C1: VERBrec1.Verbraiser IN [optionalVR, obligatoryVR] AND
              CLAUSErec2.synvpefs * AUX_sentvps <> [] AND
              VERBrec3.status IN [bareV, teV] AND
              VERBrec3.subc IN [hebbenaux, zijnaux, wordenaux] 
              C11: CLAUSErec2.synvpefs * AUX_opensentvps <> [] 
              A11: SENTENCErec1.PROsubject  := true;
                   CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs :=  
                             CLAUSErec2.synvpefs * AUX_opensentvps
              C12: CLAUSErec2.synvpefs * AUX_closedsentvps <> [] 
              A12: SENTENCErec1.PROsubject  := false;
                   CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs :=  
                             CLAUSErec2.synvpefs * AUX_closedsentvps
          A1: SENTENCErec1 :=
              {
	       req         : [pospol, negpol, omegapol]
	       env         : [pospol, negpol, omegapol]
	       mood        : declarative
	       senttype    : subordinateclause
	       voice       : omegavoice
	       synvpefs    : VERBrec4.synvps
	       thetavp     : VERBrec4.thetavp
               adjuncts    : CLAUSErec2.adjuncts
	       modus       : infinitive
	       aspect      : omegaAspect
	       deixis      : Omegadeixis
	       retro       : false
	       finiteness  : infinite
	       infsort     : inf
	       superdeixis : omegadeixis  
	       VRcompl     : true
	       conjkey     : 0
	       adverbial   : false
	       temporal    : false
	       conjclass   : omegaTimeAdvClass
	       conjdeixis  : omegadeixis
	       conjaspect  : omegaAspect
	       conjretro   : false
	       } ;
	       QUOTE_assignAktarts(VERBrec4.classes, SENTENCErec1.aktionsarts);
               CLAUSErec1.adjuncts := [];

         >


   SUBRULE   (* gekocht kan moeten hebben, opgebeld kan proberen te hebben *)
      <mu3: [mu9]>
      <mu3: [mu9]>

   MATCHCONDITIONS
      <
       mu3: EXIST(mu9,[head/VERB{VERBrec4}[mu10]])
      >

      COMP
         <
          C1: VERBrec1.status IN [VV, teVV] AND
              VERBrec1.Verbraiser IN [optionalVR, obligatoryVR] AND
              CLAUSErec1.synvpefs * AUX_sentvps <> [] AND
              VERBrec3.status IN [VV, teVV] AND
              CLAUSErec1.adjuncts = []                AND
              SENTENCErec1 =
	       {
	       req         : [pospol, negpol, omegapol]
	       env         : [pospol, negpol, omegapol]
	       mood        : declarative
	       senttype    : subordinateclause
	       voice       : omegavoice
	       modus       : infinitive
               thetavp     : VERBrec3.thetavp
	       aspect      : omegaAspect
	       deixis      : Omegadeixis
	       retro       : false
	       finiteness  : infinite
	       infsort     : inf
	       superdeixis : omegadeixis  
	       VRcompl     : true
	       conjkey     : 0
	       adverbial   : false
	       temporal    : false
	       conjclass   : omegaTimeAdvClass
	       conjdeixis  : omegadeixis
	       conjaspect  : omegaAspect
	       conjretro   : false
	       } AND
               SENTENCErec1.synvpefs * VERBrec3.synvps <> [] AND
               QUOTE_checkaktarts(VERBrec3.classes, SENTENCErec1.aktionsarts)
               C11: CLAUSErec1.synvpefs * AUX_opensentvps <> [] AND
                    SENTENCErec1.PROsubject = true
               A11: CLAUSErec2 := CLAUSErec1;
                    CLAUSErec2.synvpefs := 
                              CLAUSErec1.synvpefs * AUX_opensentvps 
               C12: CLAUSErec1.synvpefs * AUX_closedsentvps <> [] AND
                    SENTENCErec1.PROsubject = false
               A12: CLAUSErec2 := CLAUSErec1;
                    CLAUSErec2.synvpefs :=
                              CLAUSErec1.synvpefs * AUX_closedsentvps
          A1:  CLAUSErec2.adjuncts := SENTENCErec1.adjuncts;
         >
      DECOMP
         <
          C1: VERBrec1.status IN [VV, teVV] AND
              VERBrec1.Verbraiser IN [optionalVR, obligatoryVR] AND
              CLAUSErec2.synvpefs * AUX_sentvps <> []  AND
              VERBrec3.status IN [VV, teVV] 
              C11: CLAUSErec2.synvpefs * AUX_opensentvps <> [] 
              A11: SENTENCErec1.PROsubject  := true;
                   CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs :=  
                             CLAUSErec2.synvpefs * AUX_opensentvps
              C12: CLAUSErec2.synvpefs * AUX_closedsentvps <> [] 
              A12: SENTENCErec1.PROsubject  := false;
                   CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs :=  
                             CLAUSErec2.synvpefs * AUX_closedsentvps
          A1: SENTENCErec1 :=
              {
	       req         : [pospol, negpol, omegapol]
	       env         : [pospol, negpol, omegapol]
	       mood        : declarative
	       senttype    : subordinateclause
	       voice       : omegavoice
	       synvpefs    : VERBrec3.synvps
	       thetavp     : VERBrec3.thetavp
               adjuncts    : CLAUSErec2.adjuncts
	       modus       : infinitive
	       aspect      : omegaAspect
	       deixis      : Omegadeixis
	       retro       : false
	       finiteness  : infinite
	       infsort     : inf
	       superdeixis : omegadeixis  
	       VRcompl     : true
	       conjkey     : 0
	       adverbial   : false
	       temporal    : false
	       conjclass   : omegaTimeAdvClass
	       conjdeixis  : omegadeixis
	       conjaspect  : omegaAspect
	       conjretro   : false
	       } ;
	       QUOTE_assignAktarts(VERBrec3.classes, SENTENCErec1.aktionsarts);
               CLAUSErec1.adjuncts := [];

         >


   SUBRULE   (* gekocht had kunnen hebben, opgebeld had proberen te hebben *)
      <mu3: [mu9]
       mu7: [mu11, adjoinrel/VERB{VERBrec5}[mu10]]
      >
      <mu3: [mu9]
       mu7: [mu11, adjoinrel/VERB{VERBrec5}[mu10]]
      >

   MATCHCONDITIONS
      <
       mu3: EXIST(mu9,[head/VERB{VERBrec4}[mu10]])
      >

      COMP
         <
          C1: VERBrec1.status IN [AuxV, teAuxV]   AND
              VERBrec3.Verbraiser IN [optionalVR, obligatoryVR] AND
              CLAUSErec1.synvpefs * AUX_sentvps <> [] AND
              VERBrec5.status IN [bareV, teV] AND
              VERBrec5.subc IN [hebbenaux, zijnaux, wordenaux] AND
              CLAUSErec1.adjuncts = []                AND
              SENTENCErec1 =
	       {
	       req         : [pospol, negpol, omegapol]
	       env         : [pospol, negpol, omegapol]
	       mood        : declarative
	       senttype    : subordinateclause
	       voice       : omegavoice
	       modus       : infinitive
               thetavp     : VERBrec4.thetavp
	       aspect      : omegaAspect
	       deixis      : Omegadeixis
	       retro       : false
	       finiteness  : infinite
	       infsort     : inf
	       superdeixis : omegadeixis  
	       VRcompl     : true
	       conjkey     : 0
	       adverbial   : false
	       temporal    : false
	       conjclass   : omegaTimeAdvClass
	       conjdeixis  : omegadeixis
	       conjaspect  : omegaAspect
	       conjretro   : false
	       } AND
               SENTENCErec1.synvpefs * VERBrec4.synvps <> [] AND
               QUOTE_checkaktarts(VERBrec4.classes, SENTENCErec1.aktionsarts)
               C11: CLAUSErec1.synvpefs * AUX_opensentvps <> [] AND
                    SENTENCErec1.PROsubject = true
               A11: CLAUSErec2 := CLAUSErec1;
                    CLAUSErec2.synvpefs := 
                              CLAUSErec1.synvpefs * AUX_opensentvps 
               C12: CLAUSErec1.synvpefs * AUX_closedsentvps <> [] AND
                    SENTENCErec1.PROsubject = false
               A12: CLAUSErec2 := CLAUSErec1;
                    CLAUSErec2.synvpefs :=
                              CLAUSErec1.synvpefs * AUX_closedsentvps
          A1:  CLAUSErec2.adjuncts := SENTENCErec1.adjuncts;
         >
      DECOMP
         <
          C1: VERBrec1.status IN [AuxV, teAuxV]   AND
              VERBrec3.Verbraiser IN [optionalVR, obligatoryVR] AND
              CLAUSErec2.synvpefs * AUX_sentvps <> [] AND
              VERBrec5.status IN [bareV, teV] AND
              VERBrec5.subc IN [hebbenaux, zijnaux, wordenaux] 
              C11: CLAUSErec2.synvpefs * AUX_opensentvps <> [] 
              A11: SENTENCErec1.PROsubject  := true;
                   CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs :=  
                             CLAUSErec2.synvpefs * AUX_opensentvps
              C12: CLAUSErec2.synvpefs * AUX_closedsentvps <> [] 
              A12: SENTENCErec1.PROsubject  := false;
                   CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs :=  
                             CLAUSErec2.synvpefs * AUX_closedsentvps
          A1: SENTENCErec1 :=
              {
	       req         : [pospol, negpol, omegapol]
	       env         : [pospol, negpol, omegapol]
	       mood        : declarative
	       senttype    : subordinateclause
	       voice       : omegavoice
	       synvpefs    : VERBrec4.synvps
	       thetavp     : VERBrec4.thetavp
               adjuncts    : CLAUSErec2.adjuncts
	       modus       : infinitive
	       aspect      : omegaAspect
	       deixis      : Omegadeixis
	       retro       : false
	       finiteness  : infinite
	       infsort     : inf
	       superdeixis : omegadeixis  
	       VRcompl     : true
	       conjkey     : 0
	       adverbial   : false
	       temporal    : false
	       conjclass   : omegaTimeAdvClass
	       conjdeixis  : omegadeixis
	       conjaspect  : omegaAspect
	       conjretro   : false
	       } ;
	       QUOTE_assignAktarts(VERBrec4.classes, SENTENCErec1.aktionsarts);
               CLAUSErec1.adjuncts := [];

         >


   SUBRULE   (* gekocht had kunnen willen hebben, 
                        opgebeld had proberen te willen hebben *)
      <mu3: [mu9]
       mu7: [mu11, adjoinrel/VERB{VERBrec5}[mu10]]
      >
      <mu3: [mu9]
       mu7: [mu11, adjoinrel/VERB{VERBrec5}[mu10]]
      >

   MATCHCONDITIONS
      <
       mu3: EXIST(mu9,[head/VERB{VERBrec4}[mu10]])
      >

      COMP
         <
          C1: VERBrec1.status IN [AuxV, teAuxV]   AND
              VERBrec3.Verbraiser IN [optionalVR, obligatoryVR] AND
              CLAUSErec1.synvpefs * AUX_sentvps <> [] AND
              VERBrec5.status IN [VV, teVV] AND
              CLAUSErec1.adjuncts = []                AND
              SENTENCErec1 =
	       {
	       req         : [pospol, negpol, omegapol]
	       env         : [pospol, negpol, omegapol]
	       mood        : declarative
	       senttype    : subordinateclause
	       voice       : omegavoice
	       modus       : infinitive
               thetavp     : VERBrec5.thetavp
	       aspect      : omegaAspect
	       deixis      : Omegadeixis
	       retro       : false
	       finiteness  : infinite
	       infsort     : inf
	       superdeixis : omegadeixis  
	       VRcompl     : true
	       conjkey     : 0
	       adverbial   : false
	       temporal    : false
	       conjclass   : omegaTimeAdvClass
	       conjdeixis  : omegadeixis
	       conjaspect  : omegaAspect
	       conjretro   : false
	       } AND
               SENTENCErec1.synvpefs * VERBrec5.synvps <> [] AND
               QUOTE_checkaktarts(VERBrec5.classes, SENTENCErec1.aktionsarts)
               C11: CLAUSErec1.synvpefs * AUX_opensentvps <> [] AND
                    SENTENCErec1.PROsubject = true
               A11: CLAUSErec2 := CLAUSErec1;
                    CLAUSErec2.synvpefs := 
                              CLAUSErec1.synvpefs * AUX_opensentvps 
               C12: CLAUSErec1.synvpefs * AUX_closedsentvps <> [] AND
                    SENTENCErec1.PROsubject = false
               A12: CLAUSErec2 := CLAUSErec1;
                    CLAUSErec2.synvpefs :=
                              CLAUSErec1.synvpefs * AUX_closedsentvps
          A1:  CLAUSErec2.adjuncts := SENTENCErec1.adjuncts;
         >
      DECOMP
         <
          C1: VERBrec1.status IN [AuxV, teAuxV]   AND
              VERBrec3.Verbraiser IN [optionalVR, obligatoryVR] AND
              CLAUSErec2.synvpefs * AUX_sentvps <> [] AND
              VERBrec5.status IN [VV, teVV]
              C11: CLAUSErec2.synvpefs * AUX_opensentvps <> [] 
              A11: SENTENCErec1.PROsubject  := true;
                   CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs :=  
                             CLAUSErec2.synvpefs * AUX_opensentvps
              C12: CLAUSErec2.synvpefs * AUX_closedsentvps <> [] 
              A12: SENTENCErec1.PROsubject  := false;
                   CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs :=  
                             CLAUSErec2.synvpefs * AUX_closedsentvps
          A1: SENTENCErec1 :=
              {
	       req         : [pospol, negpol, omegapol]
	       env         : [pospol, negpol, omegapol]
	       mood        : declarative
	       senttype    : subordinateclause
	       voice       : omegavoice
	       synvpefs    : VERBrec5.synvps
	       thetavp     : VERBrec5.thetavp
               adjuncts    : CLAUSErec2.adjuncts
	       modus       : infinitive
	       aspect      : omegaAspect
	       deixis      : Omegadeixis
	       retro       : false
	       finiteness  : infinite
	       infsort     : inf
	       superdeixis : omegadeixis  
	       VRcompl     : true
	       conjkey     : 0
	       adverbial   : false
	       temporal    : false
	       conjclass   : omegaTimeAdvClass
	       conjdeixis  : omegadeixis
	       conjaspect  : omegaAspect
	       conjretro   : false
	       } ;
	       QUOTE_assignAktarts(VERBrec5.classes, SENTENCErec1.aktionsarts);
               CLAUSErec1.adjuncts := [];

         >


>
&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] TSpruning1
\item[* relevant examples:]
..dat hij de mensen [op] [probeerde te bellen $\rightarrow$
..dat hij de mensen op [probeerde te bellen]\\
..dat hij de mensen [gebeld] [kan hebben] $\rightarrow$
..dat hij de menen gebeld [kan hebben]\\
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] (name of rule, transformation or filter class) TC:Sentpruning
\item[* date of creation:] 8-MAY-1987 16:39:03  
\item[* author:] Jan Odijk
\item[* copied from:]--
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To prune the SENTENCE node of VRcomplements
\item[\ \ strategy:] (also: deviations from accepted proposals)

 31-MAR-1988 17:22:34 :
It is assumed that the values of the attributes
voice, infsort are set to omegavoice and inf in the VerbRaising
rules. 

The attributes req, env   have default values:
[pospol, negpol, omegapol].

Superdeixis has been set to omegadeixis by Lisette in the superdeixisadaptation
rules 

The attribute PROsubject is dealt with in this rule.

The following attributes have a fixed value:

mood        : declarative
modus       : infinitive
aspect      : omegaAspect
deixis      : Omegadeixis
finiteness  : infinite
VRcompl     : true
retro       : false
conjkey     : 0
adverbial   : false
temporal    : false
conjclass   : omegaTimeAdvClass
conjdeixis  : omegadeixis
conjaspect  : omegaAspect
conjretro   : false

\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]dna
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]none
\item[\  \ suggested semantics:]dna
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

It is presupposed that the attributes VERbraiser and synvps of VERBrec1
are equal to the first nonauxiliary verb on the left(i.e. the matrix
verb ) in the verbcluster. The surface parser should account for this.
\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% TRANSFORMATION TSpruning0


< m1: CLAUSE{CLAUSErec1}
           [ mu1, 
             predrel/VERBP{VERBPrec1}[mu2],
             mu3 
           ]
>
< m : CLAUSE{CLAUSErec2}
           [ mu1, 
             predrel/VERBP{VERBPrec1}[mu2],
             mu3 
           ]
>

   MATCHCONDITIONS
      <
       m1 : NOT EXIST(mu2, [complrel/I11::SENTENCE{SENTENCErec1}[mu4]]) OR
            EXIST(mu1, [../I12::ADVP{ADVPrec1}[mu5]])
       m  : NOT EXIST(mu2, [complrel/I11::SENTENCE{SENTENCErec1}[mu4]]) OR
            EXIST(mu1, [../I12::ADVP{ADVPrec1}[mu5]])
            I11: SENTENCErec1.VRcompl = true
            I12: ADVPrec1.advpatternefs * 
                   [synOPENINFSENT, synCLOSEDINFSENT] <> []
      >

<
   SUBRULE
      <mu1:[mu6] >
      <mu1:[mu6] >

   MATCHCONDITIONS
      <
       mu1: NOT EXIST(mu1, [../I13::ADVP{ADVPrec2}[mu7]])
            I13: ADVPrec2.advpatternefs * 
                   [synOPENINFSENT, synCLOSEDINFSENT] <> []
      >


      COMP
         <
          C1: true
              C11: NOT EXIST(mu3, [extraposrel/..]) AND
                   ((CLAUSErec1.synvpefs - AUX_sentvps) <> [])
              A11: CLAUSErec2 := CLAUSErec1;
                   CLAUSErec2.synvpefs := CLAUSErec1.synvpefs - AUX_sentvps;
              C12: EXIST(mu3, [extraposrel/..]) AND
                   ((CLAUSErec1.synvpefs - AUX_oblVRvps) <> [])
              A12: CLAUSErec2 := CLAUSErec1;
                   CLAUSErec2.synvpefs := CLAUSErec1.synvpefs - AUX_oblVRvps; 
          A1: @
         >
      DECOMP
         <
          C1: true
              C11: NOT EXIST(mu3, [extraposrel/..]) AND
                   ((CLAUSErec2.synvpefs - AUX_sentvps) <> [])
              A11: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs := CLAUSErec2.synvpefs - AUX_sentvps;
              C12: EXIST(mu3, [extraposrel/..]) AND
                   ((CLAUSErec2.synvpefs - AUX_oblVRvps) <> [])
              A12: CLAUSErec1 := CLAUSErec2;
                   CLAUSErec1.synvpefs := CLAUSErec2.synvpefs - AUX_oblVRvps; 
          A1: @
         >

   SUBRULE
      <mu1:[mu6] >
      <mu1:[mu6] >

   MATCHCONDITIONS
      <
       mu1: EXIST(mu1, [../I13::ADVP{ADVPrec2}[mu7]])
            I13: ADVPrec2.advpatternefs * 
                   [synOPENINFSENT, synCLOSEDINFSENT] <> []
      >


      COMP
         <
          C1: true
          A1: CLAUSErec2 := CLAUSErec1;
         >
      DECOMP
         <
          C1: true
          A1: CLAUSErec1 := CLAUSErec2;
         >


>
&

\end{verbatim}

\newpage
\begin{description}
\item[* name:] TSpruning0
\item[* relevant examples:]

\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] (name of rule, transformation or filter class) FC:Sentpruning
\item[* date of creation:]  12-MAY-1987 13:00:07 
\item[* author:] Jan Odijk
\item[* copied from:]--
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] to pass non VR structures.

\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]dna
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]none
\item[\  \ suggested semantics:]dna
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


%%
