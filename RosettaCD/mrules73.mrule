DUTCH 73
&
\newpage
\begin{verbatim}
%
% TRANSFORMATION Tnosuperdeixisadaptation
< m1:CLAUSE{CLAUSErec1}
           [I1: mu1]
>

< m :CLAUSE{CLAUSErec1}
           [I1: mu1]

>
   MATCHCONDITIONS
      <
       I1: (NOT EXIST(mu1, [I11: rel1/T1])) AND
           (NOT EXIST(mu1, [predrel/VERBP{VERBPrec1}[I12: mu2]]))
       I11: (rel1 IN [complrel, prepobjrel, subjrel, extraposrel]) AND
             (T1.CAT IN [SENTENCE] WITH T1.REC.temporal = false)
       I12: (EXIST (mu2, [I121: rel2/T2])) OR
            (EXIST (mu2, [prepobjrel/PREPP{PREPPrec1}[I122: mu3]])) OR
            (EXIST (mu2, [predrel/ADJP{ADJPrec1}[I123: mu4]]))
       I121: ((rel2 IN [complrel, prepobjrel]) AND
              (T2.CAT = SENTENCE)
             ) OR
             ((rel2 IN [complrel, dirargrel, locargrel, predrel]) AND
              (T2.CAT IN [OPENADJPPROP, CLOSEDADJPPROP, OPENNPPROP,
                          CLOSEDNPPROP, OPENADVPPROP, CLOSEDADVPPROP, 
                          OPENVERBPPROP, CLOSEDVERBPPROP, OPENPREPPPROP,
                          CLOSEDPREPPPROP]
              )
             )
       I122: EXIST(mu3, [I1221: rel3/T3])
       I1221: (rel3 IN [complrel, objrel]) AND
              (T3.CAT IN [OPENADJPPROP, CLOSEDADJPPROP, OPENNPPROP,
                          CLOSEDNPPROP, OPENADVPPROP, CLOSEDADVPPROP, 
                          OPENVERBPPROP, CLOSEDVERBPPROP, OPENPREPPPROP,
                          CLOSEDPREPPPROP, SENTENCE]
              )
       I123: EXIST (mu4, [I1231: rel4/T4])
       I1231: ((rel4 IN [voorobjrel, hoprel, degreemodrel]) AND
               (T4.CAT IN [NP, ADVP, PREPP, QP])
              ) OR
              ((rel4 = complrel) AND
               (T4.CAT = SENTENCE)
              )

      >
      COMP
         <
          C1:true
          A1: @
         >

      DECOMP
         <
          C1:true
          A1: @
         >


&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Tnosuperdeixisadaptation
\item[* relevant examples:]
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:]  XPPROPtoCLAUSE
\item[* class:] TC: Superdeixisadaptation
\item[* date of creation:] 05-APR-1988 
\item[* author:] Lisette Appelo
\item[* copied from:] Tsuperdeixisadaption1
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 14/08/89\ \ \ \ \ author: Lisette Appelo\\
Added condition for complrel/SENTENCE under ADJP.
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Default rule for the case there was no proposition substitution 
before the time rules.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:] Filters after every superdeixisadaptation 
transformation.
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc. nr 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% TRANSFORMATION Tsuperdeixisadaptation1
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            I1:rel1/SENTENCE{SENTENCErec1}[mu8,
                                           predrel/VERBP{VERBPrec1}[mu2],
                                           mu9
                                          ],
            mu3
           ]
>

< m :CLAUSE{CLAUSErec1}
           [mu1,
            I1:rel1/SENTENCE{SENTENCErec2}[mu8,
                                           predrel/VERBP{VERBPrec1}[mu2],
                                           mu9
                                          ],
            mu3
           ]

>
   MATCHCONDITIONS
      <
       I1: rel1 IN [complrel, prepobjrel, subjrel, extraposrel]
      >

<
   SUBRULE (* 1 no hebben/zijn *)
      <mu2: [I2: mu4] >
      <mu2: [I2: mu4] >

   MATCHCONDITIONS
      <
        I2:(NOT EXIST(mu4, [auxrel/I21::VERB{VERBrec1}[mu5 ]])) AND
           (NOT EXIST(mu4, [I22:rel1/VERB{VERBrec2}[I23:mu6 ]]))

        I21: (VERBrec1.status IN [bareV, teV]) AND 
             (VERBrec1.subc IN [hebbenaux, zijnaux]) 
        I22: rel1 IN [head, auxrel, progauxrel] AND 
             VERBrec2.status IN [AuxV, teAuxV]
        I23: EXIST(mu6, [auxrel/I24::VERB{VERBrec3}[mu7]])
        I24: VERBrec3.subc IN [hebbenaux, zijnaux]
      >

      COMP
         <
          C1:true
                 (* independent complement clause *)
             C11:CLAUSErec1.synvpefs * AUX_tempindepcomplvps <> [] AND
                 SENTENCErec1.superdeixis = omegadeixis AND
                 ((SENTENCErec1.deixis = presentdeixis AND
                   ((QUOTE_temprefnotfound(mu8) AND
                     CLAUSErec1.deixis <> presentdeixis AND
                     CLAUSErec1.superdeixis <> presentdeixis 
                    ) OR
                    (NOT (QUOTE_temprefnotfound(mu8))
                    )
                   )
                  ) OR
                  ((SENTENCErec1.deixis = pastdeixis) AND
                   ((QUOTE_temprefnotfound(mu8) AND
                     CLAUSErec1.deixis <> pastdeixis AND
                     CLAUSErec1.superdeixis <> pastdeixis
                    ) OR
                    (NOT (QUOTE_temprefnotfound(mu8))
                    )
                   )
                  ) OR
                  (SENTENCErec1.deixis = omegadeixis AND
                   NOT (QUOTE_temprefnotfound(mu8))
                  )
                 )
             A11: SENTENCErec2 := SENTENCErec1;

                 (* dependent complement clauses *)
             C12:CLAUSErec1.synvpefs * AUX_tempdepcomplvps <> []
                  
                       (* present *)
                 C121: SENTENCErec1.superdeixis = presentdeixis AND
                       SENTENCErec1.deixis = omegadeixis AND
                       (
                        (
                         CLAUSErec1.deixis = presentdeixis AND
                         CLAUSErec1.superdeixis = omegadeixis
                        ) OR
                        (
                         CLAUSErec1.deixis = omegadeixis AND
                         CLAUSErec1.superdeixis = presentdeixis
                        )
                       )

                       C1211: SENTENCErec1.finiteness = finite
                       A1211: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := presentdeixis;

                       C1212: SENTENCErec1.finiteness = infinite
                       A1212: SENTENCErec2 := SENTENCErec1;


                 A121: SENTENCErec2.superdeixis := omegadeixis;

                      (* past *)
                 C122:SENTENCErec1.deixis = omegadeixis AND
                      SENTENCErec1.superdeixis = pastdeixis AND
                      (
                       (
                        CLAUSErec1.deixis = pastdeixis AND
                        CLAUSErec1.superdeixis = omegadeixis
                       ) OR
                       (
                        CLAUSErec1.deixis = omegadeixis AND
                        CLAUSErec1.superdeixis = pastdeixis
                       )
                      )

                       C1221: SENTENCErec1.finiteness = finite
                       A1221: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := pastdeixis;

                       C1222: SENTENCErec1.finiteness = infinite
                       A1222: SENTENCErec2 := SENTENCErec1;

                 A122: SENTENCErec2.superdeixis := omegadeixis;
                       

              A12: @

          A1: @
         >

      DECOMP
         <
          C1:true
                 (* independent complement clause *)
             C11:CLAUSErec1.synvpefs * AUX_tempindepcomplvps <> [] AND
                 SENTENCErec2.superdeixis = omegadeixis AND
                 ((SENTENCErec2.deixis = presentdeixis AND
                   ((QUOTE_temprefnotfound(mu8) AND
                     CLAUSErec1.deixis <> presentdeixis AND
                     CLAUSErec1.superdeixis <> presentdeixis 
                    ) OR
                    (NOT (QUOTE_temprefnotfound(mu8))
                    )
                   )
                  ) OR
                  (SENTENCErec2.deixis = pastdeixis AND
                   ((QUOTE_temprefnotfound(mu8) AND
                     CLAUSErec1.deixis <> pastdeixis AND
                     CLAUSErec1.superdeixis <> pastdeixis 
                    ) OR
                    (NOT (QUOTE_temprefnotfound(mu8))
                    )
                   )
                  ) OR
                  (SENTENCErec2.deixis = omegadeixis AND
                   NOT (QUOTE_temprefnotfound(mu8))
                  )
                 )
                 
             A11: SENTENCErec1 := SENTENCErec2;

                 (* dependent complement clauses *)
             C12:CLAUSErec1.synvpefs * AUX_tempdepcomplvps <> []
                  
                       (* present *)
                 C121: SENTENCErec2.superdeixis = omegadeixis AND
                       (
                        (
                         CLAUSErec1.deixis = presentdeixis AND
                         CLAUSErec1.superdeixis = omegadeixis
                        ) OR
                        (
                         CLAUSErec1.deixis = omegadeixis AND
                         CLAUSErec1.superdeixis = presentdeixis
                        )
                       )

                       C1211: SENTENCErec2.deixis = presentdeixis AND
                              SENTENCErec2.finiteness = finite
                       A1211: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1212: SENTENCErec2.deixis = omegadeixis AND
                              SENTENCErec2.finiteness = infinite
                       A1212: SENTENCErec1 := SENTENCErec2;


                 A121: SENTENCErec1.superdeixis := presentdeixis;

                       (* past *)
                 C122:SENTENCErec2.superdeixis = omegadeixis AND
                       (
                        (
                         CLAUSErec1.deixis = pastdeixis AND
                         CLAUSErec1.superdeixis = omegadeixis
                        ) OR
                        (
                         CLAUSErec1.deixis = omegadeixis AND
                         CLAUSErec1.superdeixis = pastdeixis
                        )
                       )

                       C1221:SENTENCErec2.deixis = pastdeixis AND
                             SENTENCErec2.finiteness = finite
                       A1221: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1222: SENTENCErec2.deixis = omegadeixis AND
                              SENTENCErec2.finiteness = infinite
                       A1222: SENTENCErec1 := SENTENCErec2;

                 A122: SENTENCErec1.superdeixis := pastdeixis;
                       

              A12: @

          A1: @
         >

   SUBRULE (* 2 hebben/zijn *)
         <mu2: [I2: mu4] >
         <mu2: [I2: mu4] >

    MATCHCONDITIONS
        <
         I2:EXIST(mu4, [auxrel/I21::VERB{VERBrec1}[mu5 ]]) OR
            EXIST(mu4, [I22:rel1/VERB{VERBrec2}[I23:mu6 ]])

         I21: VERBrec1.status IN [bareV, teV] AND 
              VERBrec1.subc IN [hebbenaux, zijnaux] 
         I22: rel1 IN [head, auxrel, progauxrel] AND 
              VERBrec2.status IN [AuxV, teAuxV]
         I23: EXIST(mu6, [auxrel/I24::VERB{VERBrec3}[mu7]])
         I24: VERBrec3.subc IN [hebbenaux, zijnaux]
       >
      COMP
         <
          C1:true
                 (* independent complement clause *)
             C11:CLAUSErec1.synvpefs * AUX_tempindepcomplvps <> [] AND
                 SENTENCErec1.superdeixis = omegadeixis AND
                 ((SENTENCErec1.deixis = presentdeixis AND
                   ((QUOTE_temprefnotfound(mu8) AND
                     CLAUSErec1.deixis <> presentdeixis AND
                     CLAUSErec1.superdeixis <> presentdeixis
                    ) OR 
                    ( NOT (QUOTE_temprefnotfound(mu8))
                    )
                   )
                  ) OR
                  (SENTENCErec1.deixis = pastdeixis AND
                   ((QUOTE_temprefnotfound(mu8) AND
                     CLAUSErec1.deixis <> pastdeixis AND
                     CLAUSErec1.superdeixis <> pastdeixis
                    ) OR 
                    ( NOT (QUOTE_temprefnotfound(mu8))
                    )
                   )
                  ) OR
                  (SENTENCErec1.deixis = omegadeixis AND
                   NOT (QUOTE_temprefnotfound(mu8))
                  )
                 )
                 
             A11: SENTENCErec2 := SENTENCErec1;

                 (* dependent complement clauses *)
             C12:CLAUSErec1.synvpefs * AUX_tempdepcomplvps <> []
                  
                       (* present *)
                 C121: SENTENCErec1.superdeixis = presentdeixis AND
                       SENTENCErec1.deixis = omegadeixis AND
                       (
                        (
                         CLAUSErec1.deixis = presentdeixis AND
                         CLAUSErec1.superdeixis = omegadeixis
                        ) OR
                        (
                         CLAUSErec1.deixis = omegadeixis AND
                         CLAUSErec1.superdeixis = presentdeixis
                        )
                       )

                       C1211: SENTENCErec1.finiteness = finite
                       A1211: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := presentdeixis;

                       C1212: SENTENCErec1.finiteness = infinite
                       A1212: SENTENCErec2 := SENTENCErec1;


                 A121: SENTENCErec2.superdeixis := omegadeixis;

                      (* past *)
                 C122:SENTENCErec1.deixis = omegadeixis AND
                      SENTENCErec1.superdeixis = pastdeixis AND
                      (
                       (
                        CLAUSErec1.deixis = pastdeixis AND
                        CLAUSErec1.superdeixis = omegadeixis
                       ) OR
                       (
                        CLAUSErec1.deixis = omegadeixis AND
                        CLAUSErec1.superdeixis = pastdeixis
                       )
                      )

                       C1221: SENTENCErec1.finiteness = finite
                       A1221: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := pastdeixis;

                       C1222: SENTENCErec1.finiteness = infinite
                       A1222: SENTENCErec2 := SENTENCErec1;

                 A122: SENTENCErec2.superdeixis := omegadeixis;
                       

              A12: @

          A1: @
         >

      DECOMP
         <
          C1:true
                 (* independent complement clause *)
             C11:CLAUSErec1.synvpefs * AUX_tempindepcomplvps <> [] AND
                 SENTENCErec2.superdeixis = omegadeixis AND
                 ((SENTENCErec2.deixis = presentdeixis AND
                   ((QUOTE_temprefnotfound(mu8) AND
                     CLAUSErec1.deixis <> presentdeixis AND
                     CLAUSErec1.superdeixis <> presentdeixis
                    ) OR 
                    ( NOT (QUOTE_temprefnotfound(mu8))
                    )
                   )
                  ) OR
                  (SENTENCErec2.deixis = pastdeixis AND
                   ((QUOTE_temprefnotfound(mu8) AND
                     CLAUSErec1.deixis <> pastdeixis AND
                     CLAUSErec1.superdeixis <> pastdeixis
                    ) OR 
                    ( NOT (QUOTE_temprefnotfound(mu8))
                    )
                   )
                  ) OR
                  (SENTENCErec2.deixis = omegadeixis AND
                   NOT (QUOTE_temprefnotfound(mu8))
                  )
                 )
             A11: SENTENCErec1 := SENTENCErec2;

                 (* dependent complement clauses *)
             C12:CLAUSErec1.synvpefs * AUX_tempdepcomplvps <> []
                  
                       (* present *)
                 C121: SENTENCErec2.superdeixis = omegadeixis AND
                       (
                        (
                         CLAUSErec1.deixis = presentdeixis AND
                         CLAUSErec1.superdeixis = omegadeixis
                        ) OR
                        (
                         CLAUSErec1.deixis = omegadeixis AND
                         CLAUSErec1.superdeixis = presentdeixis
                        )
                       )

                       C1211: SENTENCErec2.deixis = presentdeixis AND
                              SENTENCErec2.finiteness = finite
                       A1211: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1212: SENTENCErec2.deixis = omegadeixis AND
                              SENTENCErec2.finiteness = infinite
                       A1212: SENTENCErec1 := SENTENCErec2;


                 A121: SENTENCErec1.superdeixis := presentdeixis;

                       (* past *)
                 C122:SENTENCErec2.superdeixis = omegadeixis AND
                      (
                       (
                        CLAUSErec1.deixis = pastdeixis AND
                        CLAUSErec1.superdeixis = omegadeixis
                       ) OR
                       (
                        CLAUSErec1.deixis = omegadeixis AND
                        CLAUSErec1.superdeixis = pastdeixis
                       )
                      )

                       C1221:SENTENCErec2.deixis = pastdeixis AND
                             SENTENCErec2.finiteness = finite
                       A1221:SENTENCErec1 := SENTENCErec2;
                             SENTENCErec1.deixis := omegadeixis;

                       C1222:SENTENCErec2.deixis = omegadeixis AND
                             SENTENCErec2.finiteness = infinite
                       A1222:SENTENCErec1 := SENTENCErec2;

                 A122: SENTENCErec1.superdeixis := pastdeixis;
                       

              A12: @

          A1: @
         >

>

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Tsuperdeixisadaptation1
\item[* relevant examples:]
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:]  XPPROPtoCLAUSE
\item[* class:] TC: Superdeixisadaptation
\item[* date of creation:] 19-FEB-1988 15:11:24  
\item[* author:] Lisette Appelo
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 27/07/88\ \ \ \ \ author: LA
\item date: 22/01/90\ \ \ \ \ author: LA\\
It must be possible to have independent infinitive clauses without {\em 
hebben/zijn} for cases as {\em de boeken om morgen te lezen} and {\em hij
beweert morgen te komen}. The splitting into two subrules can be removed
(after testing).
\end{enumerate}
\item[* task:] Check superdeixis of complementsentence with superdeixis or 
deixis of the higher clause in case of temporally dependent complement 
sentences. The superdeixis of the complement sentence is set omega/given a 
value present or past and the deixis value is given a value present or past/ 
set omega in cases necessary. (This is needed for efficiency 
reasons of the surface parser.) For temporally independent sentences this rule 
does nothing. 
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
A complement sentence with infinitive {\em hebben/zijn} may be independent, 
while other infinitive complement sentences are considered to be dependent.
Subrule 1 is for all complement clauses without {\em hebben/zijn}. Subrule 2 is 
for complement clauses with {\em hebben/zijn}. 
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc. nr 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:The combination of an independent presentdeixis 
complement clause with a present(super)deixis higher clause is ruled out. It is 
supposed that these cases are always dependent.\\
The rule is split up into two subrules. Only infinitive complement sentences 
with {\em hebben/zijn} may be independent.
\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% TRANSFORMATION Tsuperdeixisadaptation2
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            predrel/VERBP{VERBPrec1}
                   [mu2,
                    I1:rel1/SENTENCE{SENTENCErec1}
                                    [mu10,
                                     predrel/VERBP{VERBPrec2}[mu3],
                                     mu11
                                    ],
                    mu4
                   ],
            mu5
           ]
>

< m :CLAUSE{CLAUSErec1}
           [mu1,
            predrel/VERBP{VERBPrec1}
                   [mu2, 
                    I1:rel1/SENTENCE{SENTENCErec2}
                                    [mu10,
                                     predrel/VERBP{VERBPrec2}[mu3],
                                     mu11
                                    ],
                    mu4
                   ],
            mu5
           ]

>
   MATCHCONDITIONS
      <
       I1: rel1 IN [complrel, prepobjrel]
      >
<
   SUBRULE (* no hebben/zijn *)
      <mu3: [I2:mu6] >
      <mu3: [I2:mu6] >

   MATCHCONDITIONS
      <
        I2:(NOT EXIST(mu6, [auxrel/I21::VERB{VERBrec1}[mu7 ]])) AND
           (NOT EXIST(mu6, [I22:rel1/VERB{VERBrec2}[I23:mu8 ]]))

        I21: (VERBrec1.status IN [bareV,teV]) AND 
             (VERBrec1.subc IN [hebbenaux, zijnaux]) 
        I22: rel1 IN [head, auxrel, progauxrel] AND 
             VERBrec2.status IN [AuxV, teAuxV]
        I23: EXIST(mu8, [auxrel/I24::VERB{VERBrec3}[mu9]])
        I24: VERBrec3.subc IN [hebbenaux, zijnaux]
    
      >

      COMP
         <
          C1:true
                 (* independent complement clause *)
             C11:CLAUSErec1.synvpefs * AUX_tempindepcomplvps <> [] AND
                 SENTENCErec1.superdeixis = omegadeixis AND
                 ((SENTENCErec1.deixis = presentdeixis AND
                   QUOTE_temprefnotfound(mu10) AND
                   CLAUSErec1.deixis <> presentdeixis AND
                   CLAUSErec1.superdeixis <> presentdeixis 
                  ) OR
                  (SENTENCErec1.deixis = pastdeixis AND
                   QUOTE_temprefnotfound(mu10) AND
                   CLAUSErec1.deixis <> pastdeixis AND
                   CLAUSErec1.superdeixis <> pastdeixis
                  ) OR
                  (NOT (QUOTE_temprefnotfound(mu10))
                  )
                 )
             A11: SENTENCErec2 := SENTENCErec1;

                 (* dependent complement clauses *)
             C12:CLAUSErec1.synvpefs * AUX_tempdepcomplvps <> []
                  
                       (* present *)
                 C121: SENTENCErec1.superdeixis = presentdeixis AND
                       SENTENCErec1.deixis = omegadeixis AND
                       (
                        (
                         CLAUSErec1.deixis = presentdeixis AND
                         CLAUSErec1.superdeixis = omegadeixis
                        ) OR
                        (
                         CLAUSErec1.deixis = omegadeixis AND
                         CLAUSErec1.superdeixis = presentdeixis
                        )
                       )

                       C1211: SENTENCErec1.finiteness = finite
                       A1211: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := presentdeixis;

                       C1212: SENTENCErec1.finiteness = infinite
                       A1212: SENTENCErec2 := SENTENCErec1;


                 A121: SENTENCErec2.superdeixis := omegadeixis;

                      (* past *)
                 C122:SENTENCErec1.deixis = omegadeixis AND
                      SENTENCErec1.superdeixis = pastdeixis AND
                      (
                       (
                        CLAUSErec1.deixis = pastdeixis AND
                        CLAUSErec1.superdeixis = omegadeixis
                       ) OR
                       (
                        CLAUSErec1.deixis = omegadeixis AND
                        CLAUSErec1.superdeixis = pastdeixis
                       )
                      )

                       C1221: SENTENCErec1.finiteness = finite
                       A1221: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := pastdeixis;

                       C1222: SENTENCErec1.finiteness = infinite
                       A1222: SENTENCErec2 := SENTENCErec1;

                 A122: SENTENCErec2.superdeixis := omegadeixis;
                       

              A12: @

          A1: @
         >

      DECOMP
         <
          C1:true
                 (* independent complement clause *)
             C11:CLAUSErec1.synvpefs * AUX_tempindepcomplvps <> [] AND
                 SENTENCErec2.superdeixis = omegadeixis AND
                 ((SENTENCErec2.deixis = presentdeixis AND
                   QUOTE_temprefnotfound(mu10) AND
                   CLAUSErec1.deixis <> presentdeixis AND
                   CLAUSErec1.superdeixis <> presentdeixis 
                  ) OR
                  (SENTENCErec2.deixis = pastdeixis AND
                   QUOTE_temprefnotfound(mu10) AND
                   CLAUSErec1.deixis <> pastdeixis AND
                   CLAUSErec1.superdeixis <> pastdeixis 
                  ) OR
                  (NOT (QUOTE_temprefnotfound(mu10))
                  )
                 )
                 
             A11: SENTENCErec1 := SENTENCErec2;

                 (* dependent complement clauses *)
             C12:CLAUSErec1.synvpefs * AUX_tempdepcomplvps <> []
                  
                       (* present *)
                 C121: SENTENCErec2.superdeixis = omegadeixis AND
                       (
                        (
                         CLAUSErec1.deixis = presentdeixis AND
                         CLAUSErec1.superdeixis = omegadeixis
                        ) OR
                        (
                         CLAUSErec1.deixis = omegadeixis AND
                         CLAUSErec1.superdeixis = presentdeixis
                        )
                       )

                       C1211: SENTENCErec2.deixis = presentdeixis AND
                              SENTENCErec2.finiteness = finite
                       A1211: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1212: SENTENCErec2.deixis = omegadeixis AND
                              SENTENCErec2.finiteness = infinite
                       A1212: SENTENCErec1 := SENTENCErec2;


                 A121: SENTENCErec1.superdeixis := presentdeixis;

                       (* past *)
                 C122:SENTENCErec2.superdeixis = omegadeixis AND
                      (
                       (
                        CLAUSErec1.deixis = pastdeixis AND
                        CLAUSErec1.superdeixis = omegadeixis
                       ) OR
                       (
                        CLAUSErec1.deixis = omegadeixis AND
                        CLAUSErec1.superdeixis = pastdeixis
                       )
                      )

                       C1221:SENTENCErec2.deixis = pastdeixis AND
                             SENTENCErec2.finiteness = finite
                       A1221: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1222: SENTENCErec2.deixis = omegadeixis AND
                              SENTENCErec2.finiteness = infinite
                       A1222: SENTENCErec1 := SENTENCErec2;

                 A122: SENTENCErec1.superdeixis := pastdeixis;
                       

              A12: @

          A1: @
         >

   SUBRULE (* hebben/zijn *)
      <mu3: [I2: mu6] >
      <mu3: [I2: mu6] >

   MATCHCONDITIONS
      <
         I2:(EXIST(mu6, [auxrel/I21::VERB{VERBrec1}[mu7 ]])) OR
            (EXIST(mu6, [I22:rel1/VERB{VERBrec2}[I23:mu8 ]]))

         I21: (VERBrec1.status IN [bareV, teV]) AND 
              (VERBrec1.subc IN [hebbenaux, zijnaux]) 
         I22: rel1 IN [head, auxrel, progauxrel] AND 
              VERBrec2.status IN [AuxV, teAuxV]
         I23: EXIST(mu8, [auxrel/I24::VERB{VERBrec3}[mu9]])
         I24: VERBrec3.subc IN [hebbenaux, zijnaux]

      >
      COMP
         <
          C1:true
                 (* independent complement clause *)
             C11:((CLAUSErec1.synvpefs * AUX_tempindepcomplvps <> []) AND
                  (SENTENCErec1.superdeixis = omegadeixis) AND
                  (((SENTENCErec1.deixis = presentdeixis) AND
                    (((QUOTE_temprefnotfound(mu10)) AND
                      (CLAUSErec1.deixis <> presentdeixis) AND
                      (CLAUSErec1.superdeixis <> presentdeixis)
                     ) OR 
                     ( NOT (QUOTE_temprefnotfound(mu10))
                     )
                    )
                   ) OR
                   ((SENTENCErec1.deixis = pastdeixis) AND
                    (((QUOTE_temprefnotfound(mu10)) AND
                      (CLAUSErec1.deixis <> pastdeixis) AND
                      (CLAUSErec1.superdeixis <> pastdeixis)
                     ) OR 
                     ( NOT (QUOTE_temprefnotfound(mu10))
                     )
                    )
                   ) OR
                   ((SENTENCErec1.deixis = omegadeixis) AND
                    ( NOT (QUOTE_temprefnotfound(mu10)))
                   )
                  )
                 )
             A11: SENTENCErec2 := SENTENCErec1;

                 (* dependent complement clauses *)
             C12:(CLAUSErec1.synvpefs * AUX_tempdepcomplvps <> [])
                  
                       (* present *)
                 C121: (SENTENCErec1.superdeixis = presentdeixis) AND
                       (SENTENCErec1.deixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = presentdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = presentdeixis)
                        )
                       )

                       C1211: (SENTENCErec1.finiteness = finite)
                       A1211: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := presentdeixis;

                       C1212: (SENTENCErec1.finiteness = infinite)
                       A1212: SENTENCErec2 := SENTENCErec1;


                 A121: SENTENCErec2.superdeixis := omegadeixis;

                      (* past *)
                 C122:(SENTENCErec1.deixis = omegadeixis) AND
                      (SENTENCErec1.superdeixis = pastdeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = pastdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = pastdeixis)
                        )
                       )

                       C1221: (SENTENCErec1.finiteness = finite)
                       A1221: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := pastdeixis;

                       C1222: (SENTENCErec1.finiteness = infinite)
                       A1222: SENTENCErec2 := SENTENCErec1;

                 A122: SENTENCErec2.superdeixis := omegadeixis;
                       

              A12: @

          A1: @
         >

      DECOMP
         <
          C1:true
                 (* independent complement clause *)
             C11:((CLAUSErec1.synvpefs * AUX_tempindepcomplvps <> []) AND
                  (SENTENCErec2.superdeixis = omegadeixis) AND
                  (((SENTENCErec2.deixis = presentdeixis) AND
                    (((QUOTE_temprefnotfound(mu10)) AND
                      (CLAUSErec1.deixis <> presentdeixis) AND
                      (CLAUSErec1.superdeixis <> presentdeixis)
                     ) OR 
                     ( NOT (QUOTE_temprefnotfound(mu10))
                     )
                    )
                   ) OR
                   ((SENTENCErec2.deixis = pastdeixis) AND
                    (((QUOTE_temprefnotfound(mu10)) AND
                      (CLAUSErec1.deixis <> pastdeixis) AND
                      (CLAUSErec1.superdeixis <> pastdeixis)
                     ) OR 
                     ( NOT (QUOTE_temprefnotfound(mu10))
                     )
                    )
                   ) OR
                   ((SENTENCErec2.deixis = omegadeixis) AND
                    ( NOT (QUOTE_temprefnotfound(mu10)))
                   )
                  )
                 )
             A11: SENTENCErec1 := SENTENCErec2;

                 (* dependent complement clauses *)
             C12:(CLAUSErec1.synvpefs * AUX_tempdepcomplvps <> [])
                  
                       (* present *)
                 C121: (SENTENCErec2.superdeixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = presentdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = presentdeixis)
                        )
                       )

                       C1211: (SENTENCErec2.deixis = presentdeixis) AND
                              (SENTENCErec2.finiteness = finite)
                       A1211: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1212: (SENTENCErec2.deixis = omegadeixis) AND
                              (SENTENCErec2.finiteness = infinite)
                       A1212: SENTENCErec1 := SENTENCErec2;


                 A121: SENTENCErec1.superdeixis := presentdeixis;

                       (* past *)
                 C122:(SENTENCErec2.superdeixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = pastdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = pastdeixis)
                        )
                       )

                       C1221:(SENTENCErec2.deixis = pastdeixis) AND
                              (SENTENCErec2.finiteness = finite)
                       A1221: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1222: (SENTENCErec2.deixis = omegadeixis) AND
                              (SENTENCErec2.finiteness = infinite)
                       A1222: SENTENCErec1 := SENTENCErec2;

                 A122: SENTENCErec1.superdeixis := pastdeixis;
                       

              A12: @

          A1: @
         >

>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Tsuperdeixisadaptation2
\item[* relevant examples:]
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:]  XPPROPtoCLAUSE
\item[* class:] TC: Superdeixisadaptation
\item[* date of creation:] 9-MAR-1988 
\item[* author:] Lisette Appelo
\item[* copied from:] Tsuperdeixisadaptaion1
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 27/07/88\ \ \ \ \ author: LA
\item date: 22/01/90\ \ \ \ \ author: LA\\
It must be possible to have independent infinitive clause without {\em hebben/
zijn} in clause such as  {\em de boeken om morgen te lezen} and {\em hij
beweert morgen te komen}. The splitting into two subrules can be removed 
(after testing).
\end{enumerate}
\item[* task:] Check superdeixis of complementsentence with superdeixis or 
deixis of the higher clause in case of temporally dependent complement 
sentences. The superdeixis of the complement sentence is set omega/given a 
value present or past and the deixis value is given a value present or past/ 
set omega in cases necessary. (This is needed for efficiency 
reasons of the surface parser.) For temporally independent sentences this rule 
does nothing. 
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
Only infinitive complement clauses with {\em hebben/zijn} can be independent. 
subrule 1 is for the cases without {\em hebben/zijn}. Subrule 2 is for 
{\em hebben/zijn}.
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc. nr 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The combination of an independent presentdeixis 
complement clause with a present(super)deixis higher clause is ruled out. It is 
supposed that these cases are always dependent.\\
The rule is split into to subrules, because only infinitive complement clauses 
with {\em hebben/zijn} can be independent.\\
\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% TRANSFORMATION Tsuperdeixisadaptation5
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            predrel/VERBP{VERBPrec1}
                   [mu2,
                    prepobjrel/PREPP{PREPPrec1}
                              [mu10,
                               objrel/SENTENCE{SENTENCErec1}
                                     [mu12,
                                      predrel/VERBP{VERBPrec2}[mu3],
                                      mu13
                                     ], 
                               mu11], 
                    mu4
                   ],
            mu5
           ]
>

< m :CLAUSE{CLAUSErec1}
           [mu1,
            predrel/VERBP{VERBPrec1}
                   [mu2, 
                    prepobjrel/PREPP{PREPPrec1}
                              [mu10,
                               objrel/SENTENCE{SENTENCErec2}
                                     [mu12,
                                      predrel/VERBP{VERBPrec2}[mu3],
                                      mu13
                                     ],
                               mu11], 
                    mu4
                   ],
            mu5
           ]

>
   MATCHCONDITIONS
      <
      >
<
   SUBRULE (* no hebben/zijn *)
      <mu3: [I2:mu6] >
      <mu3: [I2:mu6] >

   MATCHCONDITIONS
      <
        I2:(NOT EXIST(mu6, [auxrel/I21::VERB{VERBrec1}[mu7 ]])) AND
           (NOT EXIST(mu6, [I22:rel1/VERB{VERBrec2}[I23:mu8 ]]))

        I21: (VERBrec1.status IN [bareV, teV]) AND 
             (VERBrec1.subc IN [hebbenaux, zijnaux]) 
        I22: rel1 IN [head, auxrel, progauxrel] AND 
             VERBrec2.status IN [AuxV, teAuxV]
        I23: EXIST(mu8, [auxrel/I24::VERB{VERBrec3}[mu9]])
        I24: VERBrec3.subc IN [hebbenaux, zijnaux]
    
      >

      COMP
         <
          C1:true
                 (* independent complement clause *)
             C11:((CLAUSErec1.synvpefs * AUX_tempindepcomplvps <> []) AND
                  (SENTENCErec1.superdeixis = omegadeixis) AND
                  (((SENTENCErec1.deixis = presentdeixis) AND
                    (QUOTE_temprefnotfound(mu10)) AND
                    (CLAUSErec1.deixis <> presentdeixis) AND
                    (CLAUSErec1.superdeixis <> presentdeixis) 
                   ) OR
                   ((SENTENCErec1.deixis = pastdeixis) AND
                    (QUOTE_temprefnotfound(mu10)) AND
                    (CLAUSErec1.deixis <> pastdeixis) AND
                    (CLAUSErec1.superdeixis <> pastdeixis)
                   ) OR
                   (NOT (QUOTE_temprefnotfound(mu10))
                   )
                  )
                 )
             A11: SENTENCErec2 := SENTENCErec1;

                 (* dependent complement clauses *)
             C12:(CLAUSErec1.synvpefs * AUX_tempdepcomplvps <> [])
                  
                       (* present *)
                 C121: (SENTENCErec1.superdeixis = presentdeixis) AND
                       (SENTENCErec1.deixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = presentdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = presentdeixis)
                        )
                       )

                       C1211: (SENTENCErec1.finiteness = finite)
                       A1211: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := presentdeixis;

                       C1212: (SENTENCErec1.finiteness = infinite)
                       A1212: SENTENCErec2 := SENTENCErec1;


                 A121: SENTENCErec2.superdeixis := omegadeixis;

                      (* past *)
                 C122:(SENTENCErec1.deixis = omegadeixis) AND
                      (SENTENCErec1.superdeixis = pastdeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = pastdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = pastdeixis)
                        )
                       )

                       C1221: (SENTENCErec1.finiteness = finite)
                       A1221: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := pastdeixis;

                       C1222: (SENTENCErec1.finiteness = infinite)
                       A1222: SENTENCErec2 := SENTENCErec1;

                 A122: SENTENCErec2.superdeixis := omegadeixis;
                       

              A12: @

          A1: @
         >

      DECOMP
         <
          C1:true
                 (* independent complement clause *)
             C11:((CLAUSErec1.synvpefs * AUX_tempindepcomplvps <> []) AND
                  (SENTENCErec2.superdeixis = omegadeixis) AND
                  (((SENTENCErec2.deixis = presentdeixis) AND
                    (QUOTE_temprefnotfound(mu10)) AND
                    (CLAUSErec1.deixis <> presentdeixis) AND
                    (CLAUSErec1.superdeixis <> presentdeixis) 
                   ) OR
                   ((SENTENCErec2.deixis = pastdeixis) AND
                    (QUOTE_temprefnotfound(mu10)) AND
                    (CLAUSErec1.deixis <> pastdeixis) AND
                    (CLAUSErec1.superdeixis <> pastdeixis) 
                   ) OR
                   (NOT (QUOTE_temprefnotfound(mu10))
                   )
                  )
                 )
             A11: SENTENCErec1 := SENTENCErec2;

                 (* dependent complement clauses *)
             C12:(CLAUSErec1.synvpefs * AUX_tempdepcomplvps <> [])
                  
                       (* present *)
                 C121: (SENTENCErec2.superdeixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = presentdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = presentdeixis)
                        )
                       )

                       C1211: (SENTENCErec2.deixis = presentdeixis) AND
                              (SENTENCErec2.finiteness = finite)
                       A1211: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1212: (SENTENCErec2.deixis = omegadeixis) AND
                              (SENTENCErec2.finiteness = infinite)
                       A1212: SENTENCErec1 := SENTENCErec2;


                 A121: SENTENCErec1.superdeixis := presentdeixis;

                       (* past *)
                 C122:(SENTENCErec2.superdeixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = pastdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = pastdeixis)
                        )
                       )

                       C1221:(SENTENCErec2.deixis = pastdeixis) AND
                              (SENTENCErec2.finiteness = finite)
                       A1221: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1222: (SENTENCErec2.deixis = omegadeixis) AND
                              (SENTENCErec2.finiteness = infinite)
                       A1222: SENTENCErec1 := SENTENCErec2;

                 A122: SENTENCErec1.superdeixis := pastdeixis;
                       

              A12: @

          A1: @
         >

   SUBRULE (* hebben/zijn *)
      <mu3: [I2: mu6] >
      <mu3: [I2: mu6] >

   MATCHCONDITIONS
      <
         I2:(EXIST(mu6, [auxrel/I21::VERB{VERBrec1}[mu7 ]])) OR
            (EXIST(mu6, [I22:rel1/VERB{VERBrec2}[I23:mu8 ]]))

         I21: (VERBrec1.status IN [bareV, teV]) AND 
              (VERBrec1.subc IN [hebbenaux, zijnaux]) 
         I22: rel1 IN [head, auxrel, progauxrel] AND 
              VERBrec2.status IN [AuxV,teAuxV]
         I23: EXIST(mu8, [auxrel/I24::VERB{VERBrec3}[mu9]])
         I24: VERBrec3.subc IN [hebbenaux, zijnaux]

      >
      COMP
         <
          C1:true
                 (* independent complement clause *)
             C11:((CLAUSErec1.synvpefs * AUX_tempindepcomplvps <> []) AND
                  (SENTENCErec1.superdeixis = omegadeixis) AND
                  (((SENTENCErec1.deixis = presentdeixis) AND
                    (((QUOTE_temprefnotfound(mu10)) AND
                      (CLAUSErec1.deixis <> presentdeixis) AND
                      (CLAUSErec1.superdeixis <> presentdeixis)
                     ) OR 
                     ( NOT (QUOTE_temprefnotfound(mu10))
                     )
                    )
                   ) OR
                   ((SENTENCErec1.deixis = pastdeixis) AND
                    (((QUOTE_temprefnotfound(mu10)) AND
                      (CLAUSErec1.deixis <> pastdeixis) AND
                      (CLAUSErec1.superdeixis <> pastdeixis)
                     ) OR 
                     ( NOT (QUOTE_temprefnotfound(mu10))
                     )
                    )
                   ) OR
                   ((SENTENCErec1.deixis = omegadeixis) AND
                    ( NOT (QUOTE_temprefnotfound(mu10)))
                   )
                  )
                 )
             A11: SENTENCErec2 := SENTENCErec1;

                 (* dependent complement clauses *)
             C12:(CLAUSErec1.synvpefs * AUX_tempdepcomplvps <> [])
                  
                       (* present *)
                 C121: (SENTENCErec1.superdeixis = presentdeixis) AND
                       (SENTENCErec1.deixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = presentdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = presentdeixis)
                        )
                       )

                       C1211: (SENTENCErec1.finiteness = finite)
                       A1211: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := presentdeixis;

                       C1212: (SENTENCErec1.finiteness = infinite)
                       A1212: SENTENCErec2 := SENTENCErec1;


                 A121: SENTENCErec2.superdeixis := omegadeixis;

                      (* past *)
                 C122:(SENTENCErec1.deixis = omegadeixis) AND
                      (SENTENCErec1.superdeixis = pastdeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = pastdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = pastdeixis)
                        )
                       )

                       C1221: (SENTENCErec1.finiteness = finite)
                       A1221: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := pastdeixis;

                       C1222: (SENTENCErec1.finiteness = infinite)
                       A1222: SENTENCErec2 := SENTENCErec1;

                 A122: SENTENCErec2.superdeixis := omegadeixis;
                       

              A12: @

          A1: @
         >

      DECOMP
         <
          C1:true
                 (* independent complement clause *)
             C11:((CLAUSErec1.synvpefs * AUX_tempindepcomplvps <> []) AND
                  (SENTENCErec2.superdeixis = omegadeixis) AND
                  (((SENTENCErec2.deixis = presentdeixis) AND
                    (((QUOTE_temprefnotfound(mu10)) AND
                      (CLAUSErec1.deixis <> presentdeixis) AND
                      (CLAUSErec1.superdeixis <> presentdeixis)
                     ) OR 
                     ( NOT (QUOTE_temprefnotfound(mu10))
                     )
                    )
                   ) OR
                   ((SENTENCErec2.deixis = pastdeixis) AND
                    (((QUOTE_temprefnotfound(mu10)) AND
                      (CLAUSErec1.deixis <> pastdeixis) AND
                      (CLAUSErec1.superdeixis <> pastdeixis)
                     ) OR 
                     ( NOT (QUOTE_temprefnotfound(mu10))
                     )
                    )
                   ) OR
                   ((SENTENCErec2.deixis = omegadeixis) AND
                    ( NOT (QUOTE_temprefnotfound(mu10)))
                   )
                  )
                 )
             A11: SENTENCErec1 := SENTENCErec2;

                 (* dependent complement clauses *)
             C12:(CLAUSErec1.synvpefs * AUX_tempdepcomplvps <> [])
                  
                       (* present *)
                 C121: (SENTENCErec2.superdeixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = presentdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = presentdeixis)
                        )
                       )

                       C1211: (SENTENCErec2.deixis = presentdeixis) AND
                              (SENTENCErec2.finiteness = finite)
                       A1211: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1212: (SENTENCErec2.deixis = omegadeixis) AND
                              (SENTENCErec2.finiteness = infinite)
                       A1212: SENTENCErec1 := SENTENCErec2;


                 A121: SENTENCErec1.superdeixis := presentdeixis;

                       (* past *)
                 C122:(SENTENCErec2.superdeixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = pastdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = pastdeixis)
                        )
                       )

                       C1221:(SENTENCErec2.deixis = pastdeixis) AND
                              (SENTENCErec2.finiteness = finite)
                       A1221: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1222: (SENTENCErec2.deixis = omegadeixis) AND
                              (SENTENCErec2.finiteness = infinite)
                       A1222: SENTENCErec1 := SENTENCErec2;

                 A122: SENTENCErec1.superdeixis := pastdeixis;
                       

              A12: @

          A1: @
         >

>
&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Tsuperdeixisadaptation5
\item[* relevant examples:]
\item[* language:] Dutch
\item[* kind of rule:] M-rule
\item[* subgrammar:]  XPPROPtoCLAUSE
\item[* class:] TC: Superdeixisadaptation
\item[* date of creation:] 27-JUL-1988 
\item[* author:] Lisette Appelo
\item[* copied from:] Tsuperdeixisadaptation2
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 22/01/90\ \ \ \ \ author: LA\\
Added independent infinitve clause without hebben/zijn. the splitting into
two subrules can be removed. 
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Check superdeixis of complementsentence with superdeixis or 
deixis of the higher clause in case of temporally dependent complement 
sentences in prepositional objects.
 The superdeixis of the complement sentence is set omega/given a 
value present or past and the deixis value is given a value present or past/ 
set omega in cases necessary. (This is needed for efficiency 
reasons of the surface parser.) For temporally independent sentences this rule 
does nothing. 
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
Only infinitive complement clauses with {\em hebben/zijn} can be independent. 
subrule 1 is for the cases without {\em hebben/zijn}. Subrule 2 is for 
{\em hebben/zijn}.
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:] doc. nr 53
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications: The combination of an independent presentdeixis 
complement clause with a present(super)deixis higher clause is ruled out. It is 
supposed that these cases are always dependent.\\
The rule is split into to subrules, because only infinitive complement clauses 
with {\em hebben/zijn} can be independent.\\
\end{enumerate}
\end{description}



\newpage
\begin{verbatim}
% TRANSFORMATION Tsuperdeixisadaptation8
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            I1:rel1/SENTENCE{SENTENCErec1}[mu8,
                                           predrel/VERBP{VERBPrec1}[mu2],
                                           mu9
                                          ],
            mu3
           ]
>

< m :CLAUSE{CLAUSErec1}
           [mu1,
            I2:rel1/SENTENCE{SENTENCErec2}[mu8,
                                           predrel/VERBP{VERBPrec1}[mu2],
                                           mu9
                                          ],
            mu3
           ]

>
   MATCHCONDITIONS
      <
       I1: (rel1 IN [leftdislocrel,sentadvrel,postsentadvrel] OR 
            SENTENCErec1.adverbial = true)                        AND
           (SENTENCErec1.temporal = false)
       I2: (rel1 IN [leftdislocrel,sentadvrel,postsentadvrel] OR 
            SENTENCErec2.adverbial = true)                        AND
           (SENTENCErec2.temporal = false)
      >


      COMP
         <
          C1:true
                 (* dependent sentences *)
             C12: true
                  
                       (* present *)
                 C121: (SENTENCErec1.superdeixis = presentdeixis) AND
                       (SENTENCErec1.deixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = presentdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = presentdeixis)
                        )
                       )

                       C1211: (SENTENCErec1.finiteness = finite)
                       A1211: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := presentdeixis;

                       C1212: (SENTENCErec1.finiteness = infinite)
                       A1212: SENTENCErec2 := SENTENCErec1;


                 A121: SENTENCErec2.superdeixis := omegadeixis;

                      (* past *)
                 C122:(SENTENCErec1.deixis = omegadeixis) AND
                      (SENTENCErec1.superdeixis = pastdeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = pastdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = pastdeixis)
                        )
                       )

                       C1221: (SENTENCErec1.finiteness = finite)
                       A1221: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := pastdeixis;

                       C1222: (SENTENCErec1.finiteness = infinite)
                       A1222: SENTENCErec2 := SENTENCErec1;

                 A122: SENTENCErec2.superdeixis := omegadeixis;
                       

              A12: @

          A1: @
         >

      DECOMP
         <
          C1:true

                 (* dependent sentences *)
             C12: true
                  
                       (* present *)
                 C121: (SENTENCErec2.superdeixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = presentdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = presentdeixis)
                        )
                       )

                       C1211: (SENTENCErec2.deixis = presentdeixis) AND
                              (SENTENCErec2.finiteness = finite)
                       A1211: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1212: (SENTENCErec2.deixis = omegadeixis) AND
                              (SENTENCErec2.finiteness = infinite)
                       A1212: SENTENCErec1 := SENTENCErec2;


                 A121: SENTENCErec1.superdeixis := presentdeixis;

                       (* past *)
                 C122:(SENTENCErec2.superdeixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = pastdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = pastdeixis)
                        )
                       )

                       C1221:(SENTENCErec2.deixis = pastdeixis) AND
                              (SENTENCErec2.finiteness = finite)
                       A1221: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1222: (SENTENCErec2.deixis = omegadeixis) AND
                              (SENTENCErec2.finiteness = infinite)
                       A1222: SENTENCErec1 := SENTENCErec2;

                 A122: SENTENCErec1.superdeixis := pastdeixis;
                       

              A12: @

          A1: @
         >


&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Tsuperdeixisadaptation8
\item[* relevant examples:]
\item[* language:] Dutch 
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] tc:superdeixisadaptation
\item[* date of creation:] 18-FEB-1989 12:44:43  
\item[* author:] Lisette Appelo/Jan Odijk
\item[* copied from:] Tsuperdeixisadaptation1
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 01/03/89\ \ \ \ \ author: Lisette Appelo\\
Deleted part for independent sentences.
\item date: 27/06/89\ \ \ \ \ author: Lisette Appelo\\
Removed splitting into subrules
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Adapt superdeixis of a sentence in leftdislocrel or adverbial 
sentences, except for temporal sentences.
\item[\ \ strategy:] This rule is recursive, because more ocurrences of such 
sentences are allowed in one clause.
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% FILTER Fsuperdeixisadaptation8
< m:CLAUSE{CLAUSErec1}
           [mu1,
            I1:rel1/SENTENCE{SENTENCErec1}[mu8,
                                           predrel/VERBP{VERBPrec1}[mu2],
                                           mu9
                                          ],
            mu3
           ]
>

   MATCHCONDITIONS
      <
       I1: (rel1 IN [leftdislocrel,sentadvrel,postsentadvrel] OR 
            SENTENCErec1.adverbial = true)                        AND
           (SENTENCErec1.temporal = false)
      >


         <
          C1:true
                 (* dependent sentences *)
             C12: true
                  
                       (* present *)
                 C121: (SENTENCErec1.superdeixis = presentdeixis) AND
                       (SENTENCErec1.deixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = presentdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = presentdeixis)
                        )
                       )

                       C1211: (SENTENCErec1.finiteness = finite)
                       A1211: @
                       C1212: (SENTENCErec1.finiteness = infinite)
                       A1212: @

                 A121: @

                      (* past *)
                 C122:(SENTENCErec1.deixis = omegadeixis) AND
                      (SENTENCErec1.superdeixis = pastdeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = pastdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = pastdeixis)
                        )
                       )

                       C1221: (SENTENCErec1.finiteness = finite)
                       A1221: @
                       C1222: (SENTENCErec1.finiteness = infinite)
                       A1222: @
                 A122: @                       

              A12: @

          A1: @
         >


&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Fsuperdeixisadaptation8
\item[* relevant examples:]
\item[* language:] Dutch 
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] tc:superdeixisadaptation
\item[* date of creation:] 24-FEB-1989 
\item[* author:] Lisette Appelo
\item[* copied from:] Tsuperdeixisadaptation8
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 01/03/89\ \ \ \ \ author: Lisette Appelo\\
Deleted part for independent sentences.
\item date: 27/06/89\ \ \ \ \ author: Lisette Appelo\\
Removed splitting into subrules.
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Filter for adaptation of
 superdeixis of a sentence in leftdislocrel or adverbial 
sentences, except for temporal sentences.
\item[\ \ strategy:] This rule is recursive, because more ocurrences of such 
sentences are allowed in one clause.
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}


\newpage
\begin{verbatim}
% FILTER Ftempindep1
< m :CLAUSE{CLAUSErec1}
           [mu1,
            I1:rel1/SENTENCE{SENTENCErec1}[mu8,
                                           predrel/VERBP{VERBPrec1}[mu2],
                                           mu9
                                          ],
            mu3
           ]

>
   MATCHCONDITIONS
      <
       I1: rel1 IN [leftdislocrel, postsentadvrel] AND
           SENTENCErec1.temporal = false
      >


         <
          C1:true
                 (* independent sentence *)
             C11: (
                  (SENTENCErec1.superdeixis = omegadeixis) AND
                  (((SENTENCErec1.deixis = presentdeixis) AND
                    ((QUOTE_temprefnotfound(mu8)) AND
                     (CLAUSErec1.deixis = presentdeixis) OR
                     (CLAUSErec1.superdeixis = presentdeixis) 
                    )  
                 ) OR
                   ((SENTENCErec1.deixis = pastdeixis) AND
                    ((QUOTE_temprefnotfound(mu8)) AND
                     (CLAUSErec1.deixis = pastdeixis) OR
                     (CLAUSErec1.superdeixis = pastdeixis)
                    ) 
                   ) 
                  )
                 )
             A11: @
         A1: @
>

&
\end{verbatim}
  \newpage
\begin{description}
\item[* name:] Ftempindep1
\item[* relevant examples:]
\item[* language:] Dutch 
\item[* kind of rule:] M-rule
\item[* subgrammar:] Xpproptoclause
\item[* class:] ?
\item[* date of creation:] 1-MAR-1989 09:27:12  
\item[* author:] Lisette Appelo
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 19/04/89\ \ \ \ \ author: Lisette Appelo\\
Changed conditions on relation of sentence. This filter is only meant for 
sentences that are not dealt with Tsuperdeixisadaptation1, but in 
Tsuperdeixisadaptation8.
\item date: 27/06/89\ \ \ \ \ author: Lisette Appelo\\
Removed splitting into subrules.
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] To filter temporal independent clauses in case:\\
1: present - present, without temporal adverbial in dependent clause\\
2: past - past, without temporal adverbial in dependent clause\\
These are not considered plausible within Rosetta3.

\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% TRANSFORMATION Tsuperdeixisadaptation10
< m1:CLAUSE{CLAUSErec1}
           [mu1,
            I1:tempadvrel/SENTENCE{SENTENCErec1}[mu8,
                                           predrel/VERBP{VERBPrec1}[mu2],
                                           mu9
                                          ],
            mu3
           ]
>

< m :CLAUSE{CLAUSErec1}
           [mu1,
            I2:tempadvrel/SENTENCE{SENTENCErec2}[mu8,
                                           predrel/VERBP{VERBPrec1}[mu2],
                                           mu9
                                          ],
            mu3
           ]

>
   MATCHCONDITIONS
      <
       I1: (SENTENCErec1.adverbial = true) AND
           (SENTENCErec1.temporal = true) AND
           (SENTENCErec1.conjclass IN [duration, frequential] OR
            (SENTENCErec1.conjclass = reference AND
             SENTENCERec1.conjretro = true
            )
           )    
       I2: (SENTENCErec2.adverbial = true) AND
           (SENTENCErec2.temporal = true) AND
           (SENTENCErec2.conjclass IN [duration, frequential] OR
            (SENTENCErec2.conjclass = reference AND
             SENTENCERec2.conjretro = true
            )
           )    
      >


      COMP
         <
          C1:true

                 (* independent sentences *)
             C11: SENTENCErec1.conjretro = true AND
                  SENTENCErec1.deixis = pastdeixis AND
                  CLAUSErec1.retro = true AND
                  CLAUSErec1.deixis <> pastdeixis AND
                  CLAUSErec1.superdeixis <> pastdeixis
             A11: SENTENCErec2 := SENTENCErec1;

                 (* dependent sentences *)
             C12: true
                  
                       (* present *)
                 C121: (SENTENCErec1.superdeixis = presentdeixis) AND
                       (SENTENCErec1.deixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = presentdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = presentdeixis)
                        )
                       )

                       C1211: (SENTENCErec1.finiteness = finite)
                       A1211: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := presentdeixis;

                       C1212: (SENTENCErec1.finiteness = infinite)
                       A1212: SENTENCErec2 := SENTENCErec1;


                 A121: SENTENCErec2.superdeixis := omegadeixis;

                      (* past *)
                 C122:(SENTENCErec1.deixis = omegadeixis) AND
                      (SENTENCErec1.superdeixis = pastdeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = pastdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = pastdeixis)
                        )
                       )

                       C1221: (SENTENCErec1.finiteness = finite)
                       A1221: SENTENCErec2 := SENTENCErec1;
                              SENTENCErec2.deixis := pastdeixis;

                       C1222: (SENTENCErec1.finiteness = infinite)
                       A1222: SENTENCErec2 := SENTENCErec1;

                 A122: SENTENCErec2.superdeixis := omegadeixis;
                       

              A12: @

          A1: @
         >

      DECOMP
         <
          C1:true
                 (* independent sentences *)
             C11: SENTENCErec2.conjretro = true AND
                  SENTENCErec2.deixis = pastdeixis AND
                  CLAUSErec1.retro = true AND
                  CLAUSErec1.deixis <> pastdeixis AND
                  CLAUSErec1.superdeixis <> pastdeixis
             A11: SENTENCErec1 := SENTENCErec2;

                 (* dependent sentences *)
             C12: true
                  
                       (* present *)
                 C121: (SENTENCErec2.superdeixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = presentdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = presentdeixis)
                        )
                       )

                       C1211: (SENTENCErec2.deixis = presentdeixis) AND
                              (SENTENCErec2.finiteness = finite)
                       A1211: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1212: (SENTENCErec2.deixis = omegadeixis) AND
                              (SENTENCErec2.finiteness = infinite)
                       A1212: SENTENCErec1 := SENTENCErec2;


                 A121: SENTENCErec1.superdeixis := presentdeixis;

                       (* past *)
                 C122:(SENTENCErec2.superdeixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = pastdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = pastdeixis)
                        )
                       )

                       C1221:(SENTENCErec2.deixis = pastdeixis) AND
                              (SENTENCErec2.finiteness = finite)
                       A1221: SENTENCErec1 := SENTENCErec2;
                              SENTENCErec1.deixis := omegadeixis;

                       C1222: (SENTENCErec2.deixis = omegadeixis) AND
                              (SENTENCErec2.finiteness = infinite)
                       A1222: SENTENCErec1 := SENTENCErec2;

                 A122: SENTENCErec1.superdeixis := pastdeixis;
                       

              A12: @

          A1: @
         >


&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Tsuperdeixisadaptation10
\item[* relevant examples:] 
Dependent:\\
Hij sliep zolang hij ziek was (*is)\\
hij zal zolang hij ziek is (*was) slapen\\
Hij werkt sinds hij daar woont (*woonde)\\
Hij werkte sinds hij daar woonde (*woont)\\
Hij werkt sinds hij daar gewoond heeft (*had)\\
Hij werkte sinds hij daar gewoond had (*heeft)\\
Hij heeft gewerkt sinds hij daar woont/woonde\\
HIj had gewerkt sinds hij daar woonde (*woont)\\
Hij zal gewerkt hebben sinds hij daar woont (*woonde)\\
Hij zou gewerkt hebben sinds hij daar woonde (*woont)\\
Independent:\\
hij werkt sinds hij daar woonde\\
*hij werkt sinds hij daar woont\\
*hij werkte sinds hij daar woonde/woont\\
hij heeft gewerkt sinds hij daar woonde\\
*hij had gewerkt sinds hij daar woonde\\
hij zal gewerkt hebben sinds hij daar woonde (* woont)
\item[* language:] Dutch 
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] tc:superdeixisadaptation
\item[* date of creation:] 18-OCT-1990 
\item[* author:] Lisette Appelo
\item[* copied from:] Tsuperdeixisadaptation8
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Adapt superdeixis of duration, frequential and retrospective
temporal sentences. Only retrospective sentences can be independent in case
they have pastdeixis and the main clause has not pastdeixis. In these cases
they show their referential character more than their durative character.
(It would be better to distinguish between these two interpretations of 
retrospective sentences, but this is not possible, because the aspect and 
retrospective properties have not been set by the surface parser and in the 
cycle of the temporal sentence itself it is too late.) 
\item[\ \ strategy:] This is an optional rule with filter, because it is 
assumed that there will only be one duration, frequential or retrospective
temporal sentence. If this turns out not to be true, it has to be changed to
iterative rule 
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

\newpage
\begin{verbatim}
% FILTER Fsuperdeixisadaptation10
< m:CLAUSE{CLAUSErec1}
           [mu1,
            I1:tempadvrel/SENTENCE{SENTENCErec1}[mu8,
                                           predrel/VERBP{VERBPrec1}[mu2],
                                           mu9
                                          ],
            mu3
           ]
>


   MATCHCONDITIONS
      <
       I1: (SENTENCErec1.adverbial = true) AND
           (SENTENCErec1.temporal = true) AND
           (SENTENCErec1.conjclass IN [duration, frequential] OR
            (SENTENCErec1.conjclass = reference AND
             SENTENCERec1.conjretro = true
            )
           )    
      >


         <
          C1:true

                 (* independent sentences *)
             C11: SENTENCErec1.conjretro = true AND
                  SENTENCErec1.deixis = pastdeixis AND
                  CLAUSErec1.retro = true AND
                  CLAUSErec1.deixis <> pastdeixis AND
                  CLAUSErec1.superdeixis <> pastdeixis
             A11: @

                 (* dependent sentences *)
             C12: true
                  
                       (* present *)
                 C121: (SENTENCErec1.superdeixis = presentdeixis) AND
                       (SENTENCErec1.deixis = omegadeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = presentdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = presentdeixis)
                        )
                       )

                       C1211: (SENTENCErec1.finiteness = finite)
                       A1211: @
                       C1212: (SENTENCErec1.finiteness = infinite)
                       A1212: @

                 A121: @
                      (* past *)
                 C122:(SENTENCErec1.deixis = omegadeixis) AND
                      (SENTENCErec1.superdeixis = pastdeixis) AND
                       (
                        (
                         (CLAUSErec1.deixis = pastdeixis) AND
                         (CLAUSErec1.superdeixis = omegadeixis)
                        ) OR
                        (
                         (CLAUSErec1.deixis = omegadeixis) AND
                         (CLAUSErec1.superdeixis = pastdeixis)
                        )
                       )

                       C1221: (SENTENCErec1.finiteness = finite)
                       A1221: @
                       C1222: (SENTENCErec1.finiteness = infinite)
                       A1222: @
                 A122: @                       

              A12: @

          A1: @
         >



&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] Fsuperdeixisadaptation10
\item[* relevant examples:] 
Dependent:\\
Hij sliep zolang hij ziek was (*is)\\
hij zal zolang hij ziek is (*was) slapen\\
Hij werkt sinds hij daar woont (*woonde)\\
Hij werkte sinds hij daar woonde (*woont)\\
Hij werkt sinds hij daar gewoond heeft (*had)\\
Hij werkte sinds hij daar gewoond had (*heeft)\\
Hij heeft gewerkt sinds hij daar woont/woonde\\
HIj had gewerkt sinds hij daar woonde (*woont)\\
Hij zal gewerkt hebben sinds hij daar woont (*woonde)\\
Hij zou gewerkt hebben sinds hij daar woonde (*woont)\\
Independent:\\
hij werkt sinds hij daar woonde\\
*hij werkt sinds hij daar woont\\
*hij werkte sinds hij daar woonde/woont\\
hij heeft gewerkt sinds hij daar woonde\\
*hij had gewerkt sinds hij daar woonde\\
hij zal gewerkt hebben sinds hij daar woonde (* woont)
\item[* language:] Dutch 
\item[* kind of rule:] M-rule
\item[* subgrammar:] XPPROPtoCLAUSE
\item[* class:] tc:superdeixisadaptation
\item[* date of creation:] 18-OCT-1990 
\item[* author:] Lisette Appelo
\item[* copied from:] Tsuperdeixisadaptation10
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] 
Filter to adapt superdeixis of duration, frequential and retrospective
temporal sentences. Only retrospective sentences can be independent in case
they have pastdeixis and the main clause has not pastdeixis. In these cases
they show their referential character more than their durative character.
(It would be better to distinguish between these two interpretations of 
retrospective sentences, but this is not possible, because the aspect and 
retrospective properties have not been set by the surface parser and in the 
cycle of the temporal sentence itself it is too late.) 
\item[\ \ strategy:] This is an optional rule with filter, because it is 
assumed that there will only be one duration, frequential or retrospective
temporal sentence. If this turns out not to be true, it has to be changed to
iterative rule 
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
%
%
