 
%DUTCH
&


%UTT

REGULAREXPRESSION:

UTT = NP/1   | ([EXCLAM/3 .[PUNC/4]] .SENTENCE/2)  | 
      ADJP/1 | PREPP/1 | ADVP/1 | EXCLAM/1

CONDITIONSANDACTIONS:

<*
 HINIT:BEGIN
       END;

1     :<*
        LOCALCONDITION: TRUE
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head
                          END
        *>

2: 
       <*
         LOCALCONDITION: (%SENTENCE.senttype = mainclause)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;

                            END
       *>


3: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := modrel;
                            END
       *>


4: 
       <*
         LOCALCONDITION:%PUNC.key = KEY_kommaPUNCkey
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := puncrel;
                            END
       *>

HFINAL: #CONDITION: TRUE
        #ACTION: BEGIN
                 MAKET_UTT;
                 END
*>
END;
&





  

%Vcomplex

REGULAREXPRESSION:

VERB = 

(TE/1 . VERB/2)       |
(PART/3 . VERB/4)     |
(VERB/5 . VERB/6)     |
(VERB/7 . VERB/8)     |
(VERB/9 . VERB/10)    |
(VERB/11 . VERB/12)   |
(VERB/13 . VERB/14)   |
(VERB/15 . VERB/16)   |
(PREP/17 . ART/18 . VERB/19) |
(PREP/20 . GLUE/21 . VERB/22) |
(PREP/20 . VERB/23)



CONDITIONSANDACTIONS:

!(*
teV;  1,2                     te komen
partteV  3,4                  op te bellen
VV       5,6                  wilde opbellen; wilde bellen; willen bellen;
                              probeerde op te bellen; probeerde te bellen
auxV     7,8                  heeft/wordt/is gebeld; hebben/zijn/worden opgebeld
VV (komen wou)  9,10          
auxV (zat te werken)  11,12
auxV (heeft zitten werken) 13,14
auxV [aan het werken] is geweest)  15,16
aan het V 17,18,19
(het bos is) ingereden 20,21,22
(het bos probeerde) in te rijden 20,23
*)
 



VAR

   adjunctsvar      :: adjunctSETtype;
   reqvar           :: polarityEFFSETtype;
   conjclassesvar   :: conjclasssettype;
   particlevar      :: keytype;
   numbervar        :: numbertype;
   personsvar       :: personsettype;
   eORenFormvar     :: eorenformtype;
   modusvar         :: modustype;
   tensevar         :: tensetype;
   possvoicesvar    ::: voicesettype;
   reflexivityvar   :: reflexivetype;
   synvpsvar        :: synpatternsettype;
   synvpefsvar2     :: synpatternEFFSETtype;
   thetavpvar       :: thetavptype;
   CaseAssignervar  :: caseassignertype;
   subcvar          :: verbsubctype;
   foundauxesvar    ::: verbsubcsettype;
   perfauxsvar      :: perfauxsettype;
   prepkey1var      :: keytype;
   prepkey2var      :: keytype;
   controllervar    :: controllertype;
   verbraiservar    :: verbraisertype;
   IPPvar           :: ipptype;
   statusvar        :: vstatustype;
   classesvar       :: classSETtype;
  
   partkeyvar       ::: keytype;
   reqvar2          :: polarityEFFSETtype;
 

?
HELP 

!(*moved to lssurfquo:FUNCTION perfauxok(pa::perfauxSETtype):BOOLEAN;
BEGIN
perfauxok :=
(
 (passive IN possvoicesvar)                                             OR
 (
  ((NOT (hebaux IN pa)) OR (hebbenaux IN foundauxesvar)) AND
  ((NOT (isaux  IN pa)) OR (zijnaux   IN foundauxesvar))  
 )
)                                                                          AND
(
 (NOT (passive IN possvoicesvar))                                      OR
 (
  ((NOT (hebaux IN pa))                    OR 
   (foundauxesvar * [hebbenaux, zijnaux, wordenaux] <> [])
  )                                                    AND
  ((NOT (isaux IN pa)) OR 
   (foundauxesvar * [zijnaux, wordenaux] <> [])
  )
 )
);*)
!(*
It checks whether the auxiliary combined  with some verb is compatible with it;

If the verb cannot in passive, then the auxiliary must be hebben, if it 
requires hebben as a perfaux; zijn, if it requires zijn as a perfaux

If the verb can occur in passive, then the auxiliary must be
hebben, zijn or worden if it requires hebben as a perfaux; zijn or worden
if it requires zijn as a perfaux.

Due to the extremely primitive programming language used, this condition is 
totally unreadable.
*)
!(*END;*) !(*perfauxok*)
?


<* 

HINIT: BEGIN
         adjunctsvar        := [];
	 reqvar             := [pospol, negpol ,omegapol];
	 conjclassesvar     := [3];
	 particlevar        := 0;
	 numbervar          := omeganumber;
	 personsvar         := [];
	 eORenFormvar       := NoForm;
	 modusvar           := infinitive;
	 tensevar           := omegatense;
	 possvoicesvar      := [active,passive,DoorActive];
	 reflexivityvar     := notreflexive;
	 synvpsvar          := [];
         synvpefsvar2       := [];
	 thetavpvar         := omegathetavp;
	 CaseAssignervar    := true;
	 subcvar            := mainverb;
	 foundauxesvar      := [];
	 perfauxsvar        := [hebaux];
	 prepkey1var        := 0;
	 prepkey2var        := 0;
	 controllervar      := none;
	 verbraiservar      := noVR;
	 IPPvar             := NOIPP;
	 statusvar          := bareV;
         classesvar         := [];
          

         partkeyvar         := 0;
	 reqvar2            := [pospol, negpol, omegapol];
       END;
 

 
1: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := terel
                            END



       *>

2: 
       <*
         LOCALCONDITION: (%VERB.status = bareV ) AND
                         (%VERB.modus = infinitive)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
			      reqvar             := %VERB.req; 
			      conjclassesvar     := %VERB.conjclasses;
			      particlevar        := %VERB.particle;
			      numbervar          := %VERB.number;
			      personsvar         := %VERB.persons;
			      eORenFormvar       := %VERB.eORenForm;
			      modusvar           := %VERB.modus;
			      tensevar           := %VERB.tense;
			      possvoicesvar      := %VERB.possvoices;
			      reflexivityvar     := %VERB.reflexivity;
			      synvpsvar          := %VERB.synvps;
			      thetavpvar         := %VERB.thetavp;
			      CaseAssignervar    := %VERB.CaseAssigner;
			      subcvar            := %VERB.subc;
			      foundauxesvar      := %VERB.foundauxes;
			      perfauxsvar        := %VERB.perfauxs;
			      prepkey1var        := %VERB.prepkey1;
			      prepkey2var        := %VERB.prepkey2;
			      controllervar      := %VERB.controller;
			      verbraiservar      := %VERB.Verbraiser;
			      IPPvar             := %VERB.IPP;
                              classesvar         := %VERB.classes;
                              adjunctsvar        := %VERB.adjuncts;

			      statusvar          := teV;
                            END
       *>

3: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := partrel;
                              partkeyvar := %PART.key
                            END
       *>


4: 
       <*
         LOCALCONDITION: (%VERB.status = teV)  AND
                         (%VERB.modus = infinitive)
         GLOBAL: #CONDITION: %VERB.particle = partkeyvar
                 #ACTION:   BEGIN
                              SYNREL := head;
			      reqvar             := %VERB.req; 
			      conjclassesvar     := %VERB.conjclasses;
			      particlevar        := %VERB.particle;
			      numbervar          := %VERB.number;
			      personsvar         := %VERB.persons;
			      eORenFormvar       := %VERB.eORenForm;
			      modusvar           := %VERB.modus;
			      tensevar           := %VERB.tense;
			      possvoicesvar      := %VERB.possvoices;
			      reflexivityvar     := %VERB.reflexivity;
			      synvpsvar          := %VERB.synvps;
			      thetavpvar         := %VERB.thetavp;
			      CaseAssignervar    := %VERB.CaseAssigner;
			      subcvar            := %VERB.subc;
			      foundauxesvar      := %VERB.foundauxes;
			      perfauxsvar        := %VERB.perfauxs;
			      prepkey1var        := %VERB.prepkey1;
			      prepkey2var        := %VERB.prepkey2;
			      controllervar      := %VERB.controller;
			      verbraiservar      := %VERB.Verbraiser;
			      IPPvar             := %VERB.IPP;
                              classesvar         := %VERB.classes;
                              adjunctsvar        := %VERB.adjuncts;

			      statusvar          := partteV;
                            END
       *>


5: 
       <*
         LOCALCONDITION: (%VERB.status IN [bareV, teV])        AND
                         (%VERB.subc IN [Mainverb, Modalverb, latenverb]) AND
                         (%VERB.Verbraiser in [optionalVR, obligatoryVR]) AND
                         ((%VERB.modus <> pastpart) OR
                          (%VERB.IPP <> OBLIGATORYIPP)
                         )                                       AND
                         NOT (%VERB.modus IN [prespart, imperative])
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
			      reqvar             := %VERB.req; 
			      conjclassesvar     := %VERB.conjclasses;
			      numbervar          := %VERB.number;
			      personsvar         := %VERB.persons;
			      eORenFormvar       := %VERB.eORenForm;
			      modusvar           := %VERB.modus;
			      tensevar           := %VERB.tense;
			      possvoicesvar      := %VERB.possvoices;
			      synvpsvar          := %VERB.synvps;
			      thetavpvar         := %VERB.thetavp;
			      CaseAssignervar    := %VERB.CaseAssigner;
			      subcvar            := %VERB.subc;
			      foundauxesvar      := [];
			      perfauxsvar        := %VERB.perfauxs;
			      controllervar      := %VERB.controller;
			      verbraiservar      := %VERB.Verbraiser;
			      IPPvar             := %VERB.IPP;
                              classesvar         := %VERB.classes;

                              IF    %VERB.status in [teV]
                              THEN  statusvar    := teVV
                              ELSE  statusvar    := VV;
                            END
       *>

6: 
       <*
         LOCALCONDITION: %VERB.modus = infinitive
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := adjoinrel;
                              reqvar2 := %VERB.req;

                              IF (NOT(%VERB.status IN [partV, partteV]))
                              THEN particlevar := %VERB.particle;

			      reflexivityvar     := %VERB.reflexivity;
			      prepkey1var        := %VERB.prepkey1;
			      prepkey2var        := %VERB.prepkey2;
                              adjunctsvar        := %VERB.adjuncts;
                              IF   ( %VERB.synvpefs2 <> [])
                              THEN synvpefsvar2 := %VERB.synvpefs2
                              ELSE synvpefsvar2 := %VERB.synvps;
                            END
       *>

7: 
       <*
         LOCALCONDITION: (%VERB.status IN [bareV, teV])   AND
                         (%VERB.subc IN [hebbenaux, zijnaux, wordenaux] ) AND
                         (NOT(%VERB.modus IN [imperative, pastpart, prespart]))
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := auxrel;
			      conjclassesvar     := %VERB.conjclasses;
			      numbervar          := %VERB.number;
			      personsvar         := %VERB.persons;
			      eORenFormvar       := %VERB.eORenForm;
			      modusvar           := %VERB.modus;
			      tensevar           := %VERB.tense;
			      foundauxesvar      := %VERB.foundauxes + 
                                                     [%VERB.subc];
                              IF      %VERB.status IN [teV] 
                              THEN    statusvar  := teAuxV
                              ELSE    statusvar  := AuxV;
                            END
       *>


8: 
       <*
         LOCALCONDITION: (%VERB.modus = pastpart)   AND
                         (%VERB.eORenform = NoForm) AND
                         (%VERB.subc <> zijnaux)
         GLOBAL: #CONDITION: perfauxok(rec^,%VERB.perfauxs)
                 #ACTION:   BEGIN
                              SYNREL := head;
			      reqvar             := %VERB.req; 
			      possvoicesvar      := %VERB.possvoices;
			      reflexivityvar     := %VERB.reflexivity;
			      synvpsvar          := %VERB.synvps;
			      thetavpvar         := %VERB.thetavp;
			      CaseAssignervar    := %VERB.CaseAssigner;
			      subcvar            := %VERB.subc;
			      perfauxsvar        := %VERB.perfauxs;
			      prepkey1var        := %VERB.prepkey1;
			      prepkey2var        := %VERB.prepkey2;
                              adjunctsvar        := %VERB.adjuncts;
			      controllervar      := %VERB.controller;
			      verbraiservar      := %VERB.Verbraiser;
			      IPPvar             := %VERB.IPP;
                              classesvar         := %VERB.classes;

                              IF (NOT(%VERB.status IN [partV]))
                              THEN particlevar := %VERB.particle;
                            END
       *>



9: 
       <*
         LOCALCONDITION: (%VERB.modus = infinitive)         AND
                         (%VERB.status IN [ bareV, partV, prepV])  AND
                         ( (NOT (%VERB.status =bareV)) OR
                           (%VERB.particle = 0)
                         )
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := adjoinrel;
                              reqvar2:= %VERB.req;
                              IF (NOT(%VERB.status IN [partV ]))
                              THEN particlevar := %VERB.particle;
			      reflexivityvar     := %VERB.reflexivity;
			      prepkey1var        := %VERB.prepkey1;
			      prepkey2var        := %VERB.prepkey2;
                              synvpefsvar2       := %VERB.synvps;
                              adjunctsvar        := %VERB.adjuncts;
                            
                            END

       *>


10: 
       <*
         LOCALCONDITION: (%VERB.subc = modalverb) AND 
                         (%VERB.modus = indicative)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
			      reqvar             := %VERB.req; 
			      conjclassesvar     := %VERB.conjclasses;
			      numbervar          := %VERB.number;
			      personsvar         := %VERB.persons;
			      eORenFormvar       := %VERB.eORenForm;
			      modusvar           := %VERB.modus;
			      tensevar           := %VERB.tense;
			      possvoicesvar      := %VERB.possvoices;
			      synvpsvar          := %VERB.synvps;
			      thetavpvar         := %VERB.thetavp;
			      CaseAssignervar    := %VERB.CaseAssigner;
			      subcvar            := %VERB.subc;
			      foundauxesvar      := [];
			      perfauxsvar        := %VERB.perfauxs;
			      controllervar      := %VERB.controller;
			      verbraiservar      := %VERB.Verbraiser;
			      IPPvar             := %VERB.IPP;
                              classesvar         := %VERB.classes;

			      statusvar          := VV;
                            END
       *>



11: 
       <*
         LOCALCONDITION: (%VERB.subc = progaux)  AND
                         (%VERB.status IN [bareV, teV]) AND
                         (NOT(%VERB.modus IN [imperative, prespart, pastpart]))
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := progauxrel;
			      reqvar             := %VERB.req; 
			      conjclassesvar     := %VERB.conjclasses;
			      numbervar          := %VERB.number;
			      personsvar         := %VERB.persons;
			      eORenFormvar       := %VERB.eORenForm;
			      modusvar           := %VERB.modus;
			      tensevar           := %VERB.tense;
			      subcvar            := %VERB.subc;
			      foundauxesvar      := [progaux];
                              IF   %VERB.status in [teV]
                              THEN statusvar     := teAUXV
			      ELSE statusvar     := auxV;
                            END
       *>

12: 
       <*
         LOCALCONDITION: (%VERB.status IN [teV, partteV, prepteV, teVV])
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := adjoinrel;
			      possvoicesvar      := %VERB.possvoices;
			      reflexivityvar     := %VERB.reflexivity;
			      synvpsvar          := %VERB.synvps;
			      thetavpvar         := %VERB.thetavp;
			      CaseAssignervar    := %VERB.CaseAssigner;
			      perfauxsvar        := %VERB.perfauxs;
			      prepkey1var        := %VERB.prepkey1;
			      prepkey2var        := %VERB.prepkey2;
                              adjunctsvar        := %VERB.adjuncts;
			      controllervar      := %VERB.controller;
			      verbraiservar      := %VERB.Verbraiser;
			      IPPvar             := %VERB.IPP;
                              classesvar         := %VERB.classes;
                              IF   ( %VERB.synvpefs2 <> [])
                              THEN synvpefsvar2  := %VERB.synvpefs2;

			      reqvar2            := %VERB.req; 

                              IF (NOT(%VERB.status IN [partteV]))
                              THEN particlevar := %VERB.particle;
                            END
       *>


13: 
       <*
         LOCALCONDITION: (%VERB.subc IN  [hebbenaux, zijnaux]) AND
                         (%VERB.status IN [bareV, teV])        AND
                         (NOT(%VERB.modus IN [imperative, pastpart, prespart]))
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := auxrel;
			      conjclassesvar     := %VERB.conjclasses;
			      numbervar          := %VERB.number;
			      personsvar         := %VERB.persons;
			      eORenFormvar       := %VERB.eORenForm;
			      modusvar           := %VERB.modus;
			      tensevar           := %VERB.tense;
			      foundauxesvar      := [%VERB.subc];
                              IF   %VERB.status in [teV]
                              THEN statusvar     := teAuxV
                              ELSE statusvar     := AuxV;
                            END
       *>

14: 
       <*
         LOCALCONDITION: (%VERB.status in [VV, auxV]) AND
                         (%VERB.modus = infinitive)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
			      reqvar            := %VERB.req; 
			      particlevar        := %VERB.particle;
			      possvoicesvar      := %VERB.possvoices;
			      reflexivityvar     := %VERB.reflexivity;
			      synvpsvar          := %VERB.synvps;
			      thetavpvar         := %VERB.thetavp;
			      CaseAssignervar    := %VERB.CaseAssigner;
			      subcvar            := %VERB.subc;
			      perfauxsvar        := %VERB.perfauxs;
			      prepkey1var        := %VERB.prepkey1;
			      prepkey2var        := %VERB.prepkey2;
                              adjunctsvar        := %VERB.adjuncts;
			      controllervar      := %VERB.controller;
			      verbraiservar      := %VERB.Verbraiser;
			      IPPvar             := %VERB.IPP;
                              classesvar         := %VERB.classes;
                              IF   ( %VERB.synvpefs2 <> [])
                              THEN synvpefsvar2  := %VERB.synvpefs2;
                            END
       *>


15: 
       <*
         LOCALCONDITION: (%VERB.subc = zijnaux)  AND
                         (%VERB.status IN [bareV, teV]) AND
                         (NOT(%VERB.modus IN [imperative, prespart, pastpart]))
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := auxrel;
			      conjclassesvar     := %VERB.conjclasses;
			      numbervar          := %VERB.number;
			      personsvar         := %VERB.persons;
			      eORenFormvar       := %VERB.eORenForm;
			      modusvar           := %VERB.modus;
			      tensevar           := %VERB.tense;
			      foundauxesvar      := [%VERB.subc];
                              IF    %VERB.status in [teV]
                              THEN  statusvar    := teAuxV
                              ELSE  statusvar    := AuxV;;
                            END
       *>


16: 
       <*
         LOCALCONDITION: (%VERB.subc = zijnaux) AND
                         (%VERB.modus = pastpart) AND
                         (%VERB.eORenform = NoForm)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := adjoinrel;
			      possvoicesvar      := %VERB.possvoices;
			      reflexivityvar     := %VERB.reflexivity;
			      synvpsvar          := %VERB.synvps;
			      thetavpvar         := %VERB.thetavp;
			      CaseAssignervar    := %VERB.CaseAssigner;
			      subcvar            := %VERB.subc;
			      foundauxesvar      := foundauxesvar + [zijnaux]; 
			      perfauxsvar        := %VERB.perfauxs;
			      prepkey1var        := %VERB.prepkey1;
			      prepkey2var        := %VERB.prepkey2;
                              adjunctsvar        := %VERB.adjuncts;
			      controllervar      := %VERB.controller;
			      verbraiservar      := %VERB.Verbraiser;
			      IPPvar             := %VERB.IPP;
                              classesvar         := %VERB.classes;

                              IF (NOT(%VERB.status IN [partV ]))
                              THEN particlevar := %VERB.particle;
                            END
       *>


17: 
       <*
         LOCALCONDITION: %PREP.key = KEY_aanioprepkey
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := modrel
                            END
       *>


18: 
       <*
         LOCALCONDITION: (%ART.key = KEY_hetARTkey)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := detrel
                            END
       *>



19: 
       <*
         LOCALCONDITION: (%VERB.modus = infinitive)  AND
                         (%VERB.status IN [bareV, partV] )
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
			      reqvar             := %VERB.req; 
			      conjclassesvar     := %VERB.conjclasses;
			      numbervar          := %VERB.number;
			      personsvar         := %VERB.persons;
			      eORenFormvar       := %VERB.eORenForm;
			      modusvar           := %VERB.modus;
			      tensevar           := %VERB.tense;
			      possvoicesvar      := %VERB.possvoices;
			      reflexivityvar     := %VERB.reflexivity;
			      synvpsvar          := %VERB.synvps;
			      thetavpvar         := %VERB.thetavp;
			      CaseAssignervar    := %VERB.CaseAssigner;
			      subcvar            :=  %VERB.subc;
			      foundauxesvar      := %VERB.foundauxes;
			      perfauxsvar        := %VERB.perfauxs;
			      prepkey1var        := %VERB.prepkey1;
			      prepkey2var        := %VERB.prepkey2;
                              adjunctsvar        := %VERB.adjuncts;
			      controllervar      := %VERB.controller;
			      verbraiservar      := %VERB.Verbraiser;
			      IPPvar             := %VERB.IPP;
                              classesvar         := %VERB.classes;

			      statusvar          := aanhetV;

			      particlevar        := 0;

                            END
       *>

20: 
       <*
         LOCALCONDITION: (%PREP.preptype = postprep) AND
                         (dir IN %PREP.subcs)        AND
                         (%PREP.postform IN [both, post])
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := partrel;
                            END
       *>

21: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := gluerel;
                            END
       *>


22: 
       <*
         LOCALCONDITION: (%VERB.status = bareV)   AND
                         (%VERB.synvps * AUX_dirargvps<> [])
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
			      reqvar             := %VERB.req; 
			      conjclassesvar     := %VERB.conjclasses;
			      numbervar          := %VERB.number;
			      personsvar         := %VERB.persons;
			      eORenFormvar       := %VERB.eORenForm;
			      modusvar           := %VERB.modus;
			      tensevar           := %VERB.tense;
			      possvoicesvar      := %VERB.possvoices;
			      reflexivityvar     := %VERB.reflexivity;
			      synvpsvar          := %VERB.synvps;
			      thetavpvar         := %VERB.thetavp;
			      CaseAssignervar    := %VERB.CaseAssigner;
			      subcvar            := %VERB.subc;
			      foundauxesvar      := %VERB.foundauxes;
			      perfauxsvar        := %VERB.perfauxs;
			      prepkey1var        := %VERB.prepkey1;
			      prepkey2var        := %VERB.prepkey2;
                              adjunctsvar        := %VERB.adjuncts;
			      controllervar      := %VERB.controller;
			      verbraiservar      := %VERB.Verbraiser;
			      IPPvar             := %VERB.IPP;
                              classesvar         := %VERB.classes;

			      statusvar          := prepV;

			      particlevar        := 0;

                            END
       *>

23: 
       <*
         LOCALCONDITION:(%VERB.status = teV)   AND
                         (%VERB.synvps * AUX_dirargvps<> [])
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
			      reqvar             := %VERB.req; 
			      conjclassesvar     := %VERB.conjclasses;
			      numbervar          := %VERB.number;
			      personsvar         := %VERB.persons;
			      eORenFormvar       := %VERB.eORenForm;
			      modusvar           := %VERB.modus;
			      tensevar           := %VERB.tense;
			      possvoicesvar      := %VERB.possvoices;
			      reflexivityvar     := %VERB.reflexivity;
			      synvpsvar          := %VERB.synvps;
			      thetavpvar         := %VERB.thetavp;
			      CaseAssignervar    := %VERB.CaseAssigner;
			      subcvar            := %VERB.subc;
			      foundauxesvar      := %VERB.foundauxes;
			      perfauxsvar        := %VERB.perfauxs;
			      prepkey1var        := %VERB.prepkey1;
			      prepkey2var        := %VERB.prepkey2;
                              adjunctsvar        := %VERB.adjuncts;
			      controllervar      := %VERB.controller;
			      verbraiservar      := %VERB.Verbraiser;
			      IPPvar             := %VERB.IPP;
                              classesvar         := %VERB.classes;

			      statusvar          := prepteV;

			      particlevar        := 0;

                            END
       *>


HFINAL: #CONDITION: true
        #ACTION: BEGIN
		     MAKET_VERB;
		     IF   (reqvar2 = [pospol, negpol, omegapol]) OR 
                          (reqvar2 = reqvar)
		     THEN $VERB.req := reqvar;
		     IF   (reqvar = [pospol, negpol, omegapol]) 
		     THEN $VERB.req := reqvar2;
		     $VERB.conjclasses := conjclassesvar;
		     $VERB.particle       := particlevar;
		     $VERB.number         := numbervar;
		     $VERB.persons        := personsvar;
		     $VERB.eORenForm      := eORenFormvar;
		     $VERB.modus          := modusvar;
		     $VERB.tense          := tensevar;
		     $VERB.possvoices     := possvoicesvar;
		     $VERB.reflexivity    := reflexivityvar;
		     $VERB.synvps         := synvpsvar;
		     $VERB.thetavp        := thetavpvar;
		     $VERB.CaseAssigner   := CaseAssignervar;
		     $VERB.subc           := subcvar;
		     $VERB.foundauxes     := foundauxesvar;
		     $VERB.perfauxs       := perfauxsvar;
		     $VERB.prepkey1       := prepkey1var;
		     $VERB.prepkey2       := prepkey2var;
		     $VERB.controller     := controllervar;
		     $VERB.Verbraiser     := verbraiservar;
		     $VERB.IPP            := IPPvar;
                     $VERB.classes        := classesvar;
		     $VERB.status         := statusvar;
                     $VERB.synvpefs2      := synvpefsvar2;
                     $VERB.adjuncts       := adjunctsvar;
                 END
*>
END;
& !(* Vcomplex *) 




!(*
It is assumed (19/8/87) that a head Verb is obligatorily present in VERBP.
If there is no head verb, then there is no VERBP. The relevant part must be
parsed then in SENTENCE. This will have to contain a copy (or almost) of the
rule described here.

The computation of reqvar and envvar must still be added

The adverbial part must be extended with agvpadvrel

*)

%VP

REGULAREXPRESSION:

VERBP = VPADVS . VRPART . COMPLS . [PART/17] . VERBS . POSTPPS

VPADVS = {PREPP/25   |  ADVP/26  | PREPP/27 | ADVP/28}
          
VRPART = [NP/32 | NP/33] .{NP/24}

COMPLS =  ( [ IO ] . [DO] . [REST] ) 

IO = NP/1 | PREPP/2 | PREPP/3 | PREPP/21    

DO = NP/4 | NP/31 | PROSENT/36 | PROSENT/37

REST  =  ( REST1 . [PREPP/14 | PREPP/15 | PREPP/16] )   |
         ( (PREPP/14 | PREPP/15 | PREPP/16) . PPS)

REST1 = (
          PPS      | 
	  ADVP/7   |
	  ADVP/9   |
	  ADVP/11  |
	  NP/12    |
	  ADJP/13  |
          NP/34    |
          VERBP/35
        )

PPS  = 	( PREPP/5  | PREPP/6  | PREPP/8  | PREPP/10 )

VERBS =  VERB/18 .[VERB/19 | VERB/29] . [VERB/20 | VERB/30]

POSTPPS = {PREPP/22 } . {PREPP/23}
 


CONDITIONSANDACTIONS:

!(*indobj(1), aanobj(2), voorobj(3), prepobjrel (21)*)


!(*vpadvrel,agvpadvrel,25/26; doorbyrel/27*)

    !(* prepobj,5 *)
    !(* dirargrel,6 *)
    !(* dirargrel,7 *)
    !(* locargrel,8 *)
    !(* locargrel,9 *)
    !(* predrel,10 *)
    !(* predrel,11 *)
    !(* predrel,12 *)
    !(* predrel,13 *)

         !(*strand,16*)              !(*head,18*)   !(*progaux,19*) !(* aux,20*)
!(* postVporel 22, postVrel,23*)
 

VAR

   aanactivefound     :: BOOLEAN;
   aanobjrelfound     ::: BOOLEAN;
   accobjfound        :: BOOLEAN;
   adjppredrelfound   :: BOOLEAN;
   adjpprepkeyvar     :: keytype;
   adjunctsvar        :: adjunctSETtype;
   adjvpefsvar        :: synpatternEFFSETtype;
   advppredrelfound   :: BOOLEAN;
   anterelativeokvar  :: BOOLEAN;
   argrelfound        ::: BOOLEAN;
   auxrelfound        :: BOOLEAN;
   classesvar         :: classSETtype;
   countenfoundvar    :: BOOLEAN;
   dirargrelfound     :: BOOLEAN;
   dirargnpfound      :: BOOLEAN;
   doorbyfound        ::: BOOLEAN;
   doorbyrelfound     ::: BOOLEAN;
   eORenparticiplefound ::: BOOLEAN;
   envvar             :: polarityEFFSETtype;
   expparticle        :: keytype;
   foundauxesvar      :: verbsubcsettype;
   headmodusvar       ::: modustype;
   headstatusvar      ::: Vstatustype;
   headvarstatusvar   :: Vstatustype;
   ionpfound          ::: BOOLEAN;
   locargrelfound     :: BOOLEAN;
   modusvar           ::: modustype;
   nodetnpfound       :: BOOLEAN;
   nodetnpfound2      :: BOOLEAN;
   nodetnpidvps       :: synpatternEFFSETtype;
   nodetnpidvps2      :: synpatternEFFSETtype;
   nppredrelfound     :: BOOLEAN;
   objfound           :: BOOLEAN;
   particlekey        :: keytype;
   perfauxsvar        :: perfauxSETtype;
   perfauxverb        :: Verbsubctype;
   possvoicesvar      :: voiceSETtype;
   postvporelfound    :: BOOLEAN;
   postvrelfound      :: BOOLEAN;
   preadvok           :: BOOLEAN;
   prepkeyvar1        :: keytype;
   prepkeyvar2        :: keytype;
   prepobj1found      ::: BOOLEAN;
   prepobj2found      ::: BOOLEAN;
   prepobjrelfound    :: BOOLEAN;
   prepppredrelfound  :: BOOLEAN;
   preprepobjrelfound ::: BOOLEAN;
   progauxmodusvar    ::: modustype;
   progauxrelfound    :: BOOLEAN;
   progauxstatusvar   :: Vstatustype;
   prosentfound       :: BOOLEAN;
   reflexivityvar     :: reflexivetype;
   reqvar             :: polarityEFFSETtype;
   statusvar          :: Vstatustype;
   strandedPPfound    ::: BOOLEAN;
   strandedrelfound   :: BOOLEAN;
   synaanactivefound  :: BOOLEAN;
   synvpefsvar        :: synpatterneffsettype;
   synvpefsvar2       :: synpatternEFFSETtype;
   tensevar           :: tensetype;
   thetavpvar         :: thetavptype;
   unreducedsynvpsvar :: synpatterneffsettype;
   unreducedsynvpsvar2:: synpatterneffsettype;
   verbadjuncts       :: adjunctSETtype;
   verbnumbervar      :: numbertype;
   verbpersonsvar     :: personSETtype;
   verbprepkeyvar1    :: keytype;
   verbprepkeyvar2    :: keytype;
   verbraiservar      :: Verbraisertype; 
   voicevar           :: voicetype;
   voorobjrelfound    ::: BOOLEAN;
   vpcomplrelfound    :: BOOLEAN;
   vrfound            :: BOOLEAN;
   VRionpfound        ::: BOOLEAN;
   VRobjfound         ::: BOOLEAN;


?
HELP 

FUNCTION nodetNP(t:LSSTREE_pStree):BOOLEAN;
!(* 
pre: t=NP<NPrec1>[mu1] & mu1<>[]
post: nodetNP(t) <=>
(NPrec1.number = singular) AND
(NPrec1.actcomas = [count]) AND
(NPrec1.NPhead = otherNP)  AND
(EXIST(mu1, [head/CN<>[mu]]) AND
(NOT EXIST(mu1, [detrel/..])
*)
VAR result, detfound, cnfound : BOOLEAN;
    sonlist :LSSTREE_pRelnode;
BEGIN
  result := ((t^.ls^.NPfield^.number=singular) AND
             (t^.ls^.NPfield^.actcomas=[count]) AND
             (t^.ls^.NPfield^.NPhead=otherNP)
            );
  IF result THEN BEGIN
     sonlist:= t^.sons;
     detfound := false;
     cnfound := false;
     WHILE (sonlist<>NIL) AND ((NOT detfound) OR (NOT cnfound)) DO BEGIN
        IF (NOT detfound) THEN detfound := (sonlist^.relation=detrel);
        IF (NOT cnfound)  THEN cnfound := (sonlist^.relation=head) AND
                                          (sonlist^.node^.ls^.cat=CN);
        sonlist:=sonlist^.brother
     END;
  END;

  nodetNP := result AND cnfound AND (NOT detfound);
END !(*nodetNPok*);

FUNCTION argandVRok:BOOLEAN;
BEGIN
argandVRok :=
( (NOT argrelfound)                                  OR
  ( (verbraiservar IN [optionalVR,obligatoryVR]) OR
    (modusvar = infinitive)
  )
);
!(*
If an argrel has been found, then we must be dealing with a case of Verb
Raising, hence 
either verbraiservar has the value optionalVR or obligatoryVR
or     the matrix verb is in second position, and there is an infinitive
       in the VERBP. Hence modusvar = infinitive
       (e.g. [Hij kan] dit boek gelezen hebben)    
*)
END !(*argandVRok*);


FUNCTION bareVR:BOOLEAN;
BEGIN
bareVR :=
(
 (verbraiservar IN [optionalVR, obligatoryVR])        AND
 (headstatusvar IN [aanhetV, bareV])                  AND
 ((NOT auxrelfound)  OR (statusvar=bareV))            AND
 ((NOT progauxrelfound) OR (progauxstatusvar = bareV))
);


!(*
If a verb allows or requires verb raising, and it is 
not in a verb cluster (and Vmatrixhead is true), 
then the verb is used without a sentential
complement. This allows one to further reduce the synvpefs.

*)
END !(*bareVR*);


FUNCTION dirargnpok:BOOLEAN;
BEGIN
  dirargnpok := ((NOT dirargnpfound) OR 
                  NOT (headstatusvar IN [bareV,partV,teV,partTeV])
                );
END {dirargnpok};


FUNCTION findaanactive(t:LSSTREE_pStree):BOOLEAN;
VAR result : BOOLEAN;
BEGIN
  result := false;
  IF (t <> NIL)
  THEN BEGIN
    IF    (aanactive IN t^.ls^.VERBfield^.possvoices)
    THEN  result := true
    ELSE  BEGIN
      result := (t^.sons <> NIL);
      IF result THEN result := (t^.sons^.brother <> NIL);
      IF result THEN result := findaanactive(t^.sons^.brother^.node)
    END
  END;
  findaanactive := result;
END !(*findaanactive*);


FUNCTION findsynaanactive(t:LSSTREE_pStree):BOOLEAN;
VAR result : BOOLEAN;
BEGIN
  result := false;
  IF (t <> NIL)
  THEN BEGIN
    IF    (synaanactive IN t^.ls^.VERBfield^.synvps)
    THEN  result := true
    ELSE  BEGIN
      result := (t^.sons <> NIL);
      IF result THEN result := findsynaanactive(t^.sons^.node)
    END
  END;
  findsynaanactive := result;
END !(*findsynaanactive*);



FUNCTION GetPk(t1:LSSTREE_pSTREE):LSDOMAINT_keytype;
VAR sonlist:LSSTREE_prelnode;
    pk     : LSDOMAINT_keytype;
    headfound:BOOLEAN;
BEGIN
pk := 0;
headfound := false;
sonlist := t1^.sons;
WHILE (NOT headfound) AND (sonlist <> NIL) DO BEGIN
 IF (sonlist^.node^.cat = ADJ) AND
    (sonlist^.relation = head )
    THEN BEGIN
      headfound := true;
      pk := sonlist^.node^.ls^.ADJfield^.prepkey;
    END;
 sonlist := sonlist^.brother;
END; 
GetPk := Pk
END !(*GetPk*);

FUNCTION iodoandVRok:BOOLEAN;
BEGIN
iodoandVRok :=
(
 ( (NOT VRionpfound)                                  OR
   ( (verbraiservar IN [optionalVR,obligatoryVR]) OR
     (modusvar = infinitive)
   )
 )                                                             AND
 ( (NOT VRobjfound)                                  OR
   ( (verbraiservar IN [optionalVR,obligatoryVR]) OR
     (modusvar = infinitive)
   )
 )
)
;
!(*
If an VRobj, or VRionp has been found, then we must be dealing with a case of
Verb Raising, hence 
either verbraiservar has the value optionalVR or obligatoryVR
or     the matrix verb is in second position, and there is an infinitive
       in the VERBP. Hence modusvar = infinitive
       (e.g. [Hij kan] dit boek gelezen hebben)    
*)
END !(*iodoandVRok*);




FUNCTION NOplural45(ps::personSETtype;n::numbertype):BOOLEAN;
BEGIN
  Noplural45 :=
   ( NOT ( ( (ps = [4]) OR
             (ps = [5]) OR
             (ps = [4,5])
           )                                       AND
           (n = plural)
         )
   );
!(*
This function is true if the verb form is not only 
fourth or fifth person plural
*)
END !(*NOplural45*);



FUNCTION Norealobjoriobjfound:BOOLEAN;
BEGIN
  Norealobjoriobjfound :=
      (
        ( (NOT ionpfound)  OR
          (VRionpfound)
        )                                         AND
        ( (NOT objfound)   OR
          (VRobjfound)
        )
      );
END !(*Norealobjoriobjfound*);




FUNCTION partinVcluster:BOOLEAN;
BEGIN
partinVcluster :=
(NOT ( (headstatusvar IN [teV, bareV]) AND
       (expparticle <> 0)              AND
       (particlekey <> 0)
     )
);
!(* If a particle can be combined in a verb cluster, then it must be combined 
inside it 
The condition excludes: VP[PART V[te V]] and allows
                        VP[ V[ PART V[te V]]]
*)
END !(*partinVcluster*);



FUNCTION passauxok:BOOLEAN;
BEGIN
passauxok:=
( (NOT auxrelfound)                             OR
  ([wordenaux, zijnaux] * foundauxesvar <> [])
);
!(*
In a passive VERBP either there is no auxiliary (in the case of
anterelatives, or if the auxiliary is in second position
(hence there is no auxrel)), but if
there is one, then it must contain worden OR zijn.
*)
END !(*passauxok*);


FUNCTION passheadok:BOOLEAN;
BEGIN
passheadok:=
( (
    (headmodusvar =  pastpart)                     AND
    (headstatusvar IN [bareV,partV, prepV])
  )                                                      OR
  (
    (headstatusvar IN [auxV, teAuxV])              AND
    ([wordenaux, zijnaux] * foundauxesvar <> [])
  )
);
!(*
In a passive VERBP the head must be a pastparticiple           OR
the head contains the participle preceded by the auxiliary verb
worden OR zijn
*)
END !(*passheadok*);



FUNCTION perfauxok:BOOLEAN;
BEGIN
perfauxok :=
(
 (NOT ( auxrelfound                AND 
        (statusvar IN [bareV,teV])
      )
 )                                      OR
 (
  ((perfauxverb = hebbenaux) AND (hebaux IN perfauxsvar)) OR
  ((perfauxverb = zijnaux  ) AND (isaux  IN perfauxsvar))
 )
)
!(*If an simple auxrel is found, then in active, 
the perfauxverb (i.e. the found perfaux ) must be compatible with
perfauxsvar
*)
END !(*perfauxok*);



FUNCTION prepkeyok(vpk,pk::keytype):BOOLEAN;
BEGIN
  prepkeyok := ((pk = vpk)                                               OR
                ((vpk = KEY_totprepkey) AND (pk = KEY_toeprepkey))       OR
                ((vpk = KEY_metprepkey) AND (pk = KEY_meeprepkey))
               );
END!(*prepkeyok*);


FUNCTION aanvoorprepobjok:BOOLEAN;
BEGIN
aanvoorprepobjok :=
(
   ( (prepkeyvar1 = KEY_aanioprepkey)          AND
     (NOT aanobjrelfound)                      AND
     ((synvpefsvar  * AUX_aanobjvps <> []) OR
      (synvpefsvar2 * AUX_aanobjvps <> []) OR
      aanactivefound
     )                                         AND
     (objfound OR argrelfound)
   )                                                    OR
   ( (prepkeyvar1 = KEY_voorioprepkey)          AND
     (NOT voorobjrelfound)                      AND
     ((synvpefsvar  * AUX_voorobjvps <> []) OR
      (synvpefsvar2 * AUX_voorobjvps <> []) OR
      (benfactPP IN verbadjuncts)
     )                                         AND
     (objfound OR argrelfound)
   )                                                   
)
END !(*aanvoorprepobjok*);


FUNCTION adjpostvpook:BOOLEAN;
BEGIN
adjpostvpook :=
(
   postvporelfound                               AND
   adjppredrelfound                              AND
   (prepkeyok(adjpprepkeyvar, prepkeyvar1) OR
    prepkeyok(adjpprepkeyvar, prepkeyvar2) OR
    (((prepkeyvar1 = KEY_aanioPREPkey) OR
      (prepkeyvar2 = KEY_aanioPREPkey)
     )                                      AND
     (adjvpefsvar * AUX_aanobjvps <> [])
    )
   )
)
END !(*adjpostvpook*);



FUNCTION prepobjok:BOOLEAN;
BEGIN
  prepobjok := false;
  IF  (NOT prepobj1found)
  THEN BEGIN
    prepobjok := true;
  END !(*  IF  (NOT prepobj1found) THEN*)
  ELSE BEGIN
    IF   (NOT prepobj2found)
    THEN BEGIN
      IF  prepkeyok(verbprepkeyvar1, prepkeyvar1) OR
          prepkeyok(verbprepkeyvar2, prepkeyvar1) OR
          aanvoorprepobjok  
      THEN BEGIN
        prepobjok := true;
      END !(*  IF prepkeyok.. THEN
          *)
      ELSE BEGIN
        prepobjok := false;
      END !(* IF prepkeyok..
          *);
    END !(* IF   (NOT prepobj2found) THEN*)
    ELSE BEGIN
      IF  (                                                 !(*1*)
            ( prepkeyok(verbprepkeyvar1, prepkeyvar1) AND 
              prepkeyok(verbprepkeyvar2, prepkeyvar2)
            )                                      OR
            ( prepkeyok(verbprepkeyvar2, prepkeyvar1) AND
              prepkeyok(verbprepkeyvar1, prepkeyvar2)
            )
          )
      THEN BEGIN
        prepobjok := true;
      END !(* IF 1 THEN*)
      ELSE BEGIN
        prepobjok := false;
      END !(* IF 1 ELSE*);
    END; !(* IF   (NOT prepobj2found) ELSE *)
  END; !(*  IF  (NOT prepobj1found) ELSE*)
END !(*function prepobjok*);


PROCEDURE reducematrixvps(VAR vps::synpatternEFFSETtype);
BEGIN
   IF argrelfound 
   THEN vps := vps * AUX_VRvps;
   IF ionpfound  AND
      ([benfactNP] * verbadjuncts = [])
   THEN vps := vps * AUX_indobjvps;
   IF ionpfound AND
      (benfactNP IN verbadjuncts)
   THEN adjunctsvar := adjunctsvar + [resAP];
   IF objfound
   THEN vps := vps * (AUX_objvps + [synzijn]);
   IF accobjfound
   THEN vps := vps * AUX_accobjvps;
END !(*reducematrixvps*);


PROCEDURE reducevps(VAR vps::synpatternEFFSETtype);
BEGIN
   IF aanobjrelfound AND (NOT aanactivefound)
   THEN vps := vps * AUX_aanobjvps;
   IF voorobjrelfound  AND
      ([benfactPP] * verbadjuncts = [])
   THEN vps := vps * AUX_voorobjvps;
   IF voorobjrelfound AND
      (benfactPP IN verbadjuncts)
   THEN adjunctsvar := adjunctsvar + [benfactPP];
   IF preprepobjrelfound
   THEN vps := vps * AUX_preprepobjvps;
   IF prepobjrelfound        OR 
      (postvporelfound   AND
       (NOT adjpostvpook)
      )
   THEN BEGIN
     IF  ((prepkeyvar1 = KEY_aanioprepkey) OR
          (prepkeyvar2 = KEY_aanioprepkey)
         )                                            AND
         (NOT aanobjrelfound AND NOT voorobjrelfound) AND
         (NOT aanactivefound)
     THEN vps := vps * (AUX_prepobjvps + AUX_aanobjvps)
     ELSE IF   ((prepkeyvar1 = KEY_voorioprepkey) OR
	        (prepkeyvar2 = KEY_voorioprepkey)
	       )                                            AND
	       (NOT aanobjrelfound AND NOT voorobjrelfound) 
          THEN IF   ([benfactPP] * verbadjuncts = [])
	       THEN vps := vps * (AUX_prepobjvps + AUX_voorobjvps)
	       ELSE adjunctsvar := adjunctsvar + [benfactPP]
          ELSE vps := vps * AUX_prepobjvps
   END;
   IF locargrelfound AND
      ([locadjunct] * Verbadjuncts = [])
   THEN vps := vps * AUX_locargvps;
   IF locargrelfound AND
      (diradjunct IN verbadjuncts)
   THEN adjunctsvar := adjunctsvar + [locadjunct];
   IF dirargrelfound AND  
      ([diradjunct] * Verbadjuncts = [])
   THEN vps := vps * AUX_dirargvps;
   IF dirargrelfound AND
      (diradjunct IN verbadjuncts)
   THEN adjunctsvar := adjunctsvar + [diradjunct];
   IF advppredrelfound  
   THEN vps := vps * AUX_advppredvps;
   IF adjppredrelfound AND
      ([resAP] * verbadjuncts = [])
   THEN vps := vps * AUX_adjppredvps;
   IF adjppredrelfound AND
      (resAP IN verbadjuncts)
   THEN adjunctsvar := adjunctsvar + [resAP];
   IF nppredrelfound AND
      ([resNP] * verbadjuncts = [])
   THEN vps := vps  * AUX_nppredvps;
   IF nppredrelfound AND
      (resNP in verbadjuncts)
   THEN adjunctsvar := adjunctsvar + [resNP];
   IF prepppredrelfound    AND
      ([resPP] * verbadjuncts = [])
   THEN vps := vps * AUX_prepppredvps;
   IF prepppredrelfound AND
      (resPP in verbadjuncts)
   THEN adjunctsvar := adjunctsvar + [resPP];
   IF   vpcomplrelfound 
   THEN vps := vps * AUX_vpcomplvps;
   IF   prosentfound
   THEN vps := vps * AUX_soprosentvps;
   IF prepobj2found
   THEN vps := vps * AUX_twoprepobjvps;
END!(*reducevps*);


FUNCTION Sunderadjp(t1:LSSTREE_pstree):BOOLEAN;
VAR result:BOOLEAN;
    sonlist:LSSTREE_prelnode;
BEGIN
  result:=FALSE;
  sonlist:=t1^.sons;
  IF sonlist <> NIL THEN BEGIN
     result := ( sonlist^.node^.cat IN [SENTENCE,NEG,POS]) OR
               (sonlist^.relation IN 
                    [reflrel, erposrel,postadjrel,omtemodrel, resultrel,
                     sentadvrel, tempadvrel, locadvrel, agvpadvrel
                    ]
               );
     sonlist:=sonlist^.brother;
  END;
  WHILE (NOT result) AND (sonlist<>NIL) DO BEGIN
       result := ( sonlist^.node^.cat IN [SENTENCE,NEG,POS]) OR
               (sonlist^.relation IN 
                    [reflrel, erposrel,postadjrel,omtemodrel, resultrel,
                     sentadvrel, tempadvrel, locadvrel, agvpadvrel
                    ]
               );
       sonlist:=sonlist^.brother
  END;
  Sunderadjp:=result;
END !(*Sunderadjp*);
!(*This function checks whether an special elements occur under ADJP*)





FUNCTION synvpsok:BOOLEAN;
BEGIN
   synvpsok :=
      ( (synvpefsvar <> [] )    AND
        ( (NOT VRfound) OR
          (synvpefsvar2 <> [])
        )
      );
END !(*synvpsok*);

?



<* 
HINIT: BEGIN

         aanactivefound     := false;
	 aanobjrelfound     := false;
	 accobjfound        := false;
	 adjppredrelfound   := false;
         adjpprepkeyvar     := 0;
         adjunctsvar        := [];
         adjvpefsvar        := [];
	 advppredrelfound   := false;
	 anterelativeokvar  := true;
	 argrelfound        := false;
	 auxrelfound        := false;
	 classesvar         := [];
         countenfoundvar    := false;
	 dirargrelfound     := false;
         dirargnpfound      := false;
         doorbyfound        := false;
	 doorbyrelfound     := false;
	 eORenparticiplefound := false;
	 envvar             := [pospol, negpol, omegapol];
	 expparticle        := 0;
	 foundauxesvar      := [];
	 headmodusvar       := omegamodus;
	 headstatusvar      := bareV;
	 ionpfound          := false;
	 locargrelfound     := false;
	 modusvar           := omegamodus;
	 modusvar           := omegamodus;
         nodetnpfound       := false;
         nodetnpfound2      := false;
         nodetnpidvps       := AUX_nodetNPidvps;
         nodetnpidvps2      := AUX_nodetNPidvps;
	 nppredrelfound     := false;
	 objfound           := false;
	 particlekey        := 0;
	 perfauxsvar        := [];
	 perfauxverb        := hebbenaux;
	 possvoicesvar      := [];
	 postvporelfound    := false;
	 postvrelfound      := false;
	 preadvok           := false;
	 prepkeyvar1        := 0;
	 prepkeyvar2        := 0;
	 prepobj1found      := false;
	 prepobj2found      := false;
	 prepobjrelfound    := false;
	 prepppredrelfound  := false;
	 preprepobjrelfound := false;
	 progauxmodusvar    := omegamodus;
	 progauxrelfound    := false;
         progauxstatusvar   := bareV;
         prosentfound       := false;
	 reflexivityvar     := notreflexive;
	 reqvar             := [pospol, negpol, omegapol];
	 statusvar          := bareV;
         strandedPPfound    := false;
	 strandedrelfound   := false;
         synaanactivefound  := false;
	 synvpefsvar        := [];
         synvpefsvar2       := [];
	 tensevar           := omegatense;
	 thetavpvar         := omegathetavp;
	 unreducedsynvpsvar := [];
	 unreducedsynvpsvar2:= [];
         verbadjuncts       := [];
	 verbnumbervar      := omeganumber;
	 verbpersonsvar     := [];
	 verbprepkeyvar1    := 0;
	 verbprepkeyvar2    := 0;
	 verbraiservar      := noVR; 
	 voicevar           := omegavoice;
	 voorobjrelfound    := false;
         vpcomplrelfound    := false;
         vrfound            := false;
         VRionpfound        := false;
         VRobjfound         := false;
       END;
 

1: 
       <*
         LOCALCONDITION: (%NP.animate in [ yesanimate, omegaanimate]) AND
                         (Dative IN %NP.cases) AND 
                         (NOT(%NP.NPhead IN [reducedpersproNP, jegenNP, 
                            zegenNP, hetNP]))                            
         GLOBAL: #CONDITION: (NOT VRionpfound) AND
                             (NOT argrelfound) AND
                             (NOT VRobjfound)
                 #ACTION:   BEGIN
                              SYNREL := indobjrel;
                              ionpfound := true;
                              IF (%NP.NPhead = enNP) AND
                                 (%NP.actcomas = [count])
                              THEN countenfoundvar := true;
                              IF nodetnp(b) 
                              THEN BEGIN
                                 nodetnpfound := true;
                                 nodetnpidvps := 
                                      nodetnpidvps * AUX_ionodetidvps;
                              END;
                            END
       *>

2: 
       <*
         LOCALCONDITION: (NOT %PREPP.stranded)               AND
                         (%PREPP.headkey = KEY_aanioprepkey) AND
                         (%PREPP.radvkey = 0)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := aanobjrel;
                              aanobjrelfound := true;
                              !(* preadvok := true; *)
                            END
       *>
 

3: 
       <*
         LOCALCONDITION: (NOT %PREPP.stranded)                AND
                         (%PREPP.headkey = KEY_voorioprepkey) AND
                         (%PREPP.radvkey = 0)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := voorobjrel;
                              voorobjrelfound := true;
                              !(* preadvok := true; *)
                            END
       *>



4: 
       <*
         LOCALCONDITION: ([nominative, accusative] * %NP.cases <> []) AND
                         (%NP.cases <> [Nominative]) AND
                         (NOT(%NP.NPhead IN [reducedpersproNP, jegenNP, 
                            zegenNP, hetNP]))                          
         GLOBAL: #CONDITION: (NOT argrelfound)  AND
                             (NOT VRionpfound)  AND
                             (NOT VRobjfound)
                 #ACTION:   BEGIN
                              SYNREL := objrel;
                              IF    NOT (nominative IN %NP.cases) 
                              THEN  accobjfound := true;
                              objfound := true;
                              IF (%NP.NPhead = enNP) AND
                                 (%NP.actcomas = [count])
                              THEN countenfoundvar := true;
                              IF nodetnp(b) 
                              THEN BEGIN
                                 nodetnpfound := true;
                                 nodetnpidvps := 
                                      nodetnpidvps * AUX_donodetidvps;
                              END;
                            END
       *>


5: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (NOT prepobj2found)              AND
                             (%PREPP.radvkey = 0)
                 #ACTION:   BEGIN
                              SYNREL := prepobjrel;
                              prepobjrelfound := true;
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepkeyvar2   := %PREPP.headkey
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepkeyvar1   := %PREPP.headkey
                              END !(*if prepobj1found else*);
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepobj2found := true
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepobj1found := true
                              END !(*if prepobj1found else*);
                              IF   %PREPP.stranded
                              THEN strandedPPfound := true;
                            END
       *>

6: 
       <*
         LOCALCONDITION: (dir IN %PREPP.actsubcefs)
         GLOBAL: #CONDITION: (NOT preprepobjrelfound)  AND
                             (%PREPP.radvkey = 0)
                 #ACTION:   BEGIN
                              SYNREL := dirargrel;
                              dirargrelfound := true;
                              IF   %PREPP.stranded
                              THEN strandedPPfound := true;
                            END
       *>


7: 
       <*
         LOCALCONDITION: (diradv IN %ADVP.actsubcefs)
         GLOBAL: #CONDITION: (NOT preprepobjrelfound)
                 #ACTION:   BEGIN
                              SYNREL := dirargrel;
                              dirargrelfound := true;
                            END
       *>


8: 
       <*
         LOCALCONDITION: (loc IN %PREPP.actsubcefs)
         GLOBAL: #CONDITION: (NOT preprepobjrelfound)  AND
                             (%PREPP.radvkey = 0)
                 #ACTION:   BEGIN
                              SYNREL := locargrel;
                              locargrelfound := true;
                              IF   %PREPP.stranded
                              THEN strandedPPfound := true;
                            END
       *>


9: 
       <*
         LOCALCONDITION: (locadv IN %ADVP.actsubcefs)
         GLOBAL: #CONDITION: (NOT preprepobjrelfound)
                 #ACTION:   BEGIN
                              SYNREL := locargrel;
                              locargrelfound := true;
                            END
       *>



10: 
       <*
         LOCALCONDITION: (%PREPP.actsubcefs * [other] <> [])  AND
                         (NOT %PREPP.stranded)
         GLOBAL: #CONDITION: (NOT preprepobjrelfound)    AND
                             (%PREPP.radvkey = 0)
                 #ACTION:   BEGIN
                              SYNREL := predrel;
                              prepppredrelfound := true;
                            END
       *>

11: 
       <*
         LOCALCONDITION: (%ADVP.actsubcefs * [Locadv, diradv, otherAdv] <> [])
         GLOBAL: #CONDITION: (NOT preprepobjrelfound)
                 #ACTION:   BEGIN
                              SYNREL := predrel;
                              advppredrelfound := true;
                            END
       *>

12: 
       <*
         LOCALCONDITION: (%NP.cases <> [Nominative]) AND
                         (accusative IN %NP.cases)   AND
                         (NOT(%NP.NPhead IN [reducedpersproNP, hetNP, jegenNP,
                                 zegenNP]))          AND
                         (%NP.posspred = true)  !(*NP can be used predicatively*) 
         GLOBAL: #CONDITION: (NOT preprepobjrelfound)
                 #ACTION:   BEGIN
                              SYNREL := predrel;     
                              nppredrelfound :=true;
                              IF (%NP.NPhead = enNP) AND
                                 (%NP.actcomas = [count])
                              THEN countenfoundvar := true;
                            END
       *>


13: 
       <*
         LOCALCONDITION: ( predicative IN %ADJP.actuseefs) AND
                         ( %ADJP.eORenForm = NoForm ) AND 
                         (NOT SunderADJP(b))
         GLOBAL: #CONDITION: (NOT preprepobjrelfound) 
                 #ACTION:   BEGIN
                              SYNREL := predrel;
                              adjppredrelfound := true;
                              adjvpefsvar := %ADJP.adjpatternefs;
                              adjpprepkeyvar := GETPk(b);
                            END
       *>


14: !(* for stranded doorby *) 
       <*
         LOCALCONDITION: (%PREPP.headkey = KEY_doorbyprepkey) AND
                         (%PREPP.stranded)
         GLOBAL: #CONDITION: (NOT doorbyrelfound)  AND
                             (NOT strandedPPfound)
                 #ACTION:   BEGIN
                              SYNREL := strandedrel;
                              doorbyfound := true;
                              strandedrelfound := true;
                            END
       *>

15: !(* for stranded preprep heads *)
       <*
         LOCALCONDITION: (%PREPP.stranded) 
         GLOBAL: #CONDITION: (NOT prepobj2found)      AND
                             (NOT strandedPPfound)    AND
                             (NOT preprepobjrelfound)
                 #ACTION:   BEGIN
                              SYNREL := strandedrel;
                              strandedrelfound := true;
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepkeyvar2   := %PREPP.headkey
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepkeyvar1   := %PREPP.headkey
                              END !(*if prepobj1found else*);
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepobj2found := true
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepobj1found := true
                              END !(*if prepobj1found else*);
                            END
       *>



16: !(* for stranded adverbials *)
       <*
         LOCALCONDITION: (%PREPP.actsubcefs * [instrum,comitative] <> [])  AND 
                         (%PREPP.stranded) 
         GLOBAL: #CONDITION: (NOT strandedPPfound)
                 #ACTION:   BEGIN
                              SYNREL := strandedrel;
                              strandedrelfound := true;
                            END
       *>


17: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := partrel;
                              particlekey := %PART.key;
                            END
       *>


18: 
       <*
         LOCALCONDITION:  Noplural45(%VERB.persons, %VERB.number)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
                              thetavpvar := %VERB.thetavp;
                              synvpefsvar := %VERB.synvps;
                              synvpefsvar2 := %VERB.synvpefs2;
                              verbadjuncts := %VERB.adjuncts;
                              possvoicesvar := %VERB.possvoices;
                              foundauxesvar := %VERB.foundauxes;
                              headmodusvar  := %VERB.modus;
                              modusvar      := %VERB.modus;
                              headstatusvar := %VERB.status;
                              tensevar      := %VERB.tense;
                              statusvar     := %VERB.status;
                              possvoicesvar := %VERB.possvoices;
                              IF   (%VERB.eORenform IN [eForm, enForm])
                              THEN eORenparticiplefound := true;
                              verbprepkeyvar1 := %VERB.prepkey1;
                              verbprepkeyvar2 := %VERB.prepkey2;
                              verbraiservar   := %VERB.verbraiser;
                              IF (NOT(%VERB.status IN [partV, partteV]))
                              THEN expparticle := %VERB.particle;
                              perfauxsvar     := %VERB.perfauxs;
                              classesvar      := %VERB.classes;
                              reflexivityvar  := %VERB.reflexivity;
                              verbpersonsvar  := %VERB.persons;
                              verbnumbervar   := %VERB.number;
                              aanactivefound := findaanactive(b);
                              synaanactivefound := findsynaanactive(b);
                            END
       *>



19: 
       <*
         LOCALCONDITION: (%VERB.subc IN [ progaux, zijnaux ]) AND
                         (%VERB.status IN [bareV, teV])       AND
                         Noplural45(%VERB.persons, %VERB.number)
         GLOBAL: #CONDITION: ((%VERB.subc <> zijnaux) OR
                              (headstatusvar = aanhetV)
                             )                                AND
                         (NOT eORenparticiplefound)
                 #ACTION:   BEGIN
                              SYNREL := progauxrel;
                              foundauxesvar := foundauxesvar + [%VERB.subc];
                              tensevar      := %VERB.tense;
                              progauxmodusvar := %VERB.modus;
                              modusvar      := %VERB.modus;
                              progauxrelfound := true;
                              perfauxsvar     := %VERB.perfauxs;
                              anterelativeokvar := false;
                              verbpersonsvar  := %VERB.persons;
                              verbnumbervar   := %VERB.number;
                              progauxstatusvar:= %VERB.status;
                              statusvar       := %VERB.status;
                            END
       *>


20: 
       <*
         LOCALCONDITION: (%VERB.subc IN  [hebbenaux, zijnaux, wordenaux]) AND
                         (%VERB.status IN [bareV, teV])                   AND
                         Noplural45(%VERB.persons, %VERB.number)
         GLOBAL: #CONDITION: (modusvar = pastpart) AND
                             (NOT eORenparticiplefound)

                 #ACTION:   BEGIN
                              SYNREL := auxrel;
                              IF (%VERB.subc IN [hebbenaux, zijnaux] )
                              THEN perfauxverb := %VERB.subc;
                              
                              auxrelfound := true;
                              modusvar := %VERB.modus;
                              statusvar := %VERB.status;
                              tensevar := %VERB.tense;
                              anterelativeokvar := false;

                              foundauxesvar := foundauxesvar + [%VERB.subc];
                              verbpersonsvar  := %VERB.persons;
                              verbnumbervar   := %VERB.number;
                            END
       *>


21: 
       <*
         LOCALCONDITION: (%PREPP.radvkey = 0)          AND
                         (NOT %PREPP.stranded)
         GLOBAL: #CONDITION: (NOT prepobj2found)
                 #ACTION:   BEGIN
                              SYNREL := prepobjrel;
                              preprepobjrelfound := true;
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepkeyvar2   := %PREPP.headkey
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepkeyvar1   := %PREPP.headkey
                              END !(*if prepobj1found else*);
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepobj2found := true
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepobj1found := true
                              END !(*if prepobj1found else*);
                            END
       *>



22: 
       <*
         LOCALCONDITION:  (NOT %PREPP.stranded)   AND
                          (%PREPP.radvkey = 0)
         GLOBAL: #CONDITION: (NOT prepobj2found)  AND
                             (NOT eORenparticiplefound)
                 #ACTION:   BEGIN
                              SYNREL := postvporel;
                              postvporelfound := true;
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepkeyvar2   := %PREPP.headkey
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepkeyvar1   := %PREPP.headkey
                              END !(*if prepobj1found else*);
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepobj2found := true
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepobj1found := true
                              END !(*if prepobj1found else*);
                              anterelativeokvar := false;
                            END
       *>



23: 
       <*
         LOCALCONDITION:  (NOT %PREPP.stranded)  AND
                          (%PREPP.radvkey = 0)   AND
                          (%PREPP.actsubcefs * [doorby, instrum, 
                                  comitative] <> [])
         GLOBAL: #CONDITION: (NOT eORenparticiplefound)
                 #ACTION:   BEGIN
                              SYNREL := postverbrel;
                              postvrelfound := true;
                              anterelativeokvar := false;
                            END
       *>


24: 
       <*
         LOCALCONDITION: (%NP.cases * [dative, accusative] <> []) AND
                         (NOT(%NP.NPhead IN [reducedpersproNP, jegenNP, 
                            zegenNP, hetNP])) AND
                         (NOT nodetnp(b))
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              argrelfound := true;
                            END
       *>


25: 
       <*
         LOCALCONDITION: (%PREPP.actsubcefs * [instrum, comitative] <> []) AND
                         (%PREPP.radvkey = 0)                              AND
                         (NOT %PREPP.stranded)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := vpadvrel;
                              preadvok := true;
                            END
       *>


26: 
       <*
         LOCALCONDITION: (%ADVP.actsubcefs * [vpadv] <> []) AND
                         (%ADVP.Qstatus = false)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL   := vpadvrel;
                              preadvok := true;
                            END
       *>

27: 
       <*
         LOCALCONDITION: (%PREPP.headkey = KEY_doorbyprepkey)  AND
                         (%PREPP.radvkey = 0)                  AND
                         (NOT %PREPP.stranded)
         GLOBAL: #CONDITION: (NOT doorbyrelfound)              AND
                             (NOT doorbyfound)
                 #ACTION:   BEGIN
                              SYNREL := byobjrel;
                              doorbyrelfound := true;
                              preadvok := true;
                            END
       *>

28: 
       <*
         LOCALCONDITION: (%ADVP.actsubcefs * [agvpadv] <> []) AND
                         (%ADVP.Qstatus = false)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL   := agvpadvrel;
                              preadvok := true;
                            END
       *>


29: 
       <*
         LOCALCONDITION: (%VERB.status IN [VV, teVV, AuxV, teAuxV]) AND
                            Noplural45(%VERB.persons, %VERB.number)
         GLOBAL: #CONDITION: (headstatusvar = aanhetV)  AND
                             (NOT eORenparticiplefound)
                 #ACTION:   BEGIN
                              SYNREL := progauxrel;
                              aanactivefound := findaanactive(b);
                              synaanactivefound := findsynaanactive(b);
                              foundauxesvar   := %VERB.foundauxes;
                              tensevar        := %VERB.tense;
                              progauxmodusvar := %VERB.modus;
                              modusvar        := %VERB.modus;
                              progauxrelfound := true;
                              thetavpvar      := %VERB.thetavp;
                              synvpefsvar2    := synvpefsvar;
                              adjunctsvar     := %VERB.adjuncts;
                              synvpefsvar     := %VERB.synvps;
                              !(*IF   (%VERB.synvpefs2 <> [synzijn] )
                              THEN synvpefsvar2    := %VERB.synvpefs2;*)
                              possvoicesvar   := %VERB.possvoices;
                              statusvar       := %VERB.status;
                              verbprepkeyvar1 := %VERB.prepkey1;
                              verbprepkeyvar2 := %VERB.prepkey2;
                              verbraiservar   := %VERB.verbraiser;
                              perfauxsvar     := %VERB.perfauxs;
                              progauxstatusvar:= %VERB.status;
                              IF   %VERB.status IN [VV, teVV]
                              THEN BEGIN
                                 classesvar := %VERB.classes;
                                 reflexivityvar  := %VERB.reflexivity;
                              END;
                              verbpersonsvar  := %VERB.persons;
                              verbnumbervar   := %VERB.number;

                            END
       *>

30: 
       <*
         LOCALCONDITION: (%VERB.status IN [VV, teVV, AuxV, teAuxV]) AND
                         Noplural45(%VERB.persons, %VERB.number)
         GLOBAL: #CONDITION:(
                             (headmodusvar = pastpart)         OR
                             ((headstatusvar = aanhetV)    AND
                              (progauxmodusvar = pastpart)
                             )  
                            )                                      AND
                            (NOT eORenparticiplefound)            
                 #ACTION:   BEGIN
                              SYNREL := auxrel;
                              aanactivefound := findaanactive(b);
                              synaanactivefound := findsynaanactive(b);
                              auxrelfound     := true;
                              modusvar        := %VERB.modus;
                              tensevar        := %VERB.tense;
                              thetavpvar      := %VERB.thetavp;
                              synvpefsvar2    := synvpefsvar;
                              verbadjuncts    := %VERB.adjuncts;
                              synvpefsvar     := %VERB.synvps;
                              !(*IF   (%VERB.synvpefs2 <> [synzijn] )
                              THEN synvpefsvar2    := %VERB.synvpefs2;*)
                              possvoicesvar   := %VERB.possvoices;
                              statusvar       := %VERB.status;
                              verbprepkeyvar1 := %VERB.prepkey1;
                              verbprepkeyvar2 := %VERB.prepkey2;
                              foundauxesvar   := %VERB.foundauxes;
                              verbraiservar   := %VERB.verbraiser;
                              classesvar      := %VERB.classes;
                              reflexivityvar  := %VERB.reflexivity;
                              verbpersonsvar  := %VERB.persons;
                              verbnumbervar   := %VERB.number;
                            END
       *>


31: 
       <*
         LOCALCONDITION: (%NP.cases * [dative, accusative] <> []) AND
                         (NOT(%NP.NPhead IN [reducedpersproNP, jegenNP, 
                            zegenNP, hetNP]))
         GLOBAL: #CONDITION: (preprepobjrelfound OR
                              aanobjrelfound     OR
                              voorobjrelfound    
                             )                          AND
                             ( (NOT ionpfound) OR
                               (VRionpfound)
                             )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              argrelfound := true;
                              IF nodetnp(b) 
                              THEN BEGIN
                                 nodetnpfound2:= true;
                                 nodetnpidvps2:= 
                                      nodetnpidvps2 * AUX_donodetidvps;
                              END;
                            END
       *>


32: 
       <*
         LOCALCONDITION: (%NP.animate in [ yesanimate, omegaanimate]) AND
                         (Dative IN %NP.cases) AND 
                         (NOT(%NP.NPhead IN [reducedpersproNP, jegenNP, 
                            zegenNP, hetNP]))                            
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL      := indobjrel;
                              ionpfound   := true;
                              VRionpfound := true;
                              IF (%NP.NPhead = enNP) AND
                                 (%NP.actcomas = [count])
                              THEN countenfoundvar := true;
                              IF nodetnp(b) 
                              THEN BEGIN
                                 nodetnpfound := true;
                                 nodetnpidvps := 
                                      nodetnpidvps * AUX_ionodetidvps;
                              END;
                            END
       *>

33: 
       <*
         LOCALCONDITION: ([nominative, accusative] * %NP.cases <> []) AND
                         (%NP.cases <> [Nominative]) AND
                         (NOT(%NP.NPhead IN [reducedpersproNP, jegenNP, 
                            zegenNP, hetNP]))                          
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := objrel;
                              IF    NOT (nominative IN %NP.cases) 
                              THEN  accobjfound := true;
                              objfound := true;
                              VRobjfound := true;
                              IF (%NP.NPhead = enNP) AND
                                 (%NP.actcomas = [count])
                              THEN countenfoundvar := true;
                              IF nodetnp(b) 
                              THEN BEGIN
                                 nodetnpfound := true;
                                 nodetnpidvps := 
                                      nodetnpidvps * AUX_donodetidvps;
                              END;
                            END
       *>

34: 
       <*
         LOCALCONDITION:  ([nominative, accusative] * %NP.cases <> []) AND
                         (%NP.cases <> [Nominative]) AND
                         (NOT(%NP.NPhead IN [reducedpersproNP, jegenNP, 
                            zegenNP, hetNP]))                          
         GLOBAL: #CONDITION: (NOT preprepobjrelfound)
                 #ACTION:   BEGIN
                              SYNREL := dirargrel;
                              dirargrelfound := true;
                              dirargnpfound := true;
                            END
       *>


35: 
       <*
         LOCALCONDITION: (%VERBP.voice = passive)     AND
                         (%VERBP.Vmatrixhead = true)  AND
                         (%VERBP.modus = pastpart)    AND
                         (%VERBP.foundauxes = [])     AND
                         (%VERBP.synvpefs2 =[])       AND
                         (%VERBP.objfound = false)    AND
                         (%VERBP.indobjfound = false) AND
                         (%VERBP.adjvpefs = [])       AND
                         (%VERBP.countenfound = false)AND
                         (%VERBP.vpcomplfound =false) 
         GLOBAL: #CONDITION: (NOT preprepobjrelfound)
                 #ACTION:   BEGIN
                              SYNREL := complrel;
                              vpcomplrelfound := true;
                            END
       *>

36: 
       <*
         LOCALCONDITION: %PROSENT.so = true
         GLOBAL: #CONDITION: (NOT argrelfound)  AND
                             (NOT VRionpfound)  AND
                             (NOT VRobjfound)
                 #ACTION:   BEGIN
                              SYNREL := objrel;
                              prosentfound := true;
                            END
       *>


37: 
       <*
         LOCALCONDITION: %PROSENT.so = true
         GLOBAL: #CONDITION: (preprepobjrelfound OR
                              aanobjrelfound     OR
                              voorobjrelfound    
                             )                          AND
                             ( (NOT ionpfound) OR
                               (VRionpfound)
                             )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              argrelfound := true;
                              prosentfound := true;
                            END
       *>


HFINAL: #CONDITION:  argandVRok                                AND
                     (modusvar <> imperative)                  AND
                     (particlekey = expparticle)               AND
                     partinVcluster                            AND
                     (adjpostvpook OR prepobjok)               AND
                     (verbpersonsvar <> [0])                   AND
                     iodoandVRok                               AND
                     dirargnpok

         #ACTION: BEGIN
                   unreducedsynvpsvar := synvpefsvar;
                   unreducedsynvpsvar2:= synvpefsvar2;

                   VRfound := (synvpefsvar2 <> []);

                   synvpefsvar2 := synvpefsvar2 - AUX_oblVRvps;
                   IF  ((NOT (VRobjfound OR VRionpfound)) OR 
                        (Vrfound)
                       )                                        AND
                       (NOT(argrelfound AND (NOT VRfound)))
                   THEN BEGIN
                     reducematrixvps(synvpefsvar);

                     IF    bareVR
                     THEN  synvpefsvar := synvpefsvar - AUX_oblVRvps;

                     IF    (statusvar IN [VV,teVV])
                     THEN  synvpefsvar := synvpefsvar * AUX_VRvps;

                     IF    (objfound AND (NOT VRobjfound))
                     THEN  synvpefsvar := synvpefsvar - AUX_oblVRvps;

                     IF    (ionpfound AND (NOT VRionpfound))
                     THEN  synvpefsvar := synvpefsvar - AUX_oblVRvps;

		     IF (NOT VRfound)
		     THEN BEGIN
                          reducevps(synvpefsvar);
                          IF    nodetnpfound 
                          THEN  synvpefsvar := synvpefsvar * nodetnpidvps;
		     END !(*(verbraiservar = noVr) OR ...*)
                     ELSE BEGIN
                          reducevps(synvpefsvar2);
                          IF    nodetnpfound2 
                          THEN  synvpefsvar2:= synvpefsvar2* nodetnpidvps2;
                     END;

  
		     IF   synvpsok
		     THEN BEGIN
  !(*Passive*)
			   IF (passive IN possvoicesvar)                  AND
			      (headstatusvar <> aanhetV )                 AND 
			      (NOT progauxrelfound)                       AND
                              (NOT accobjfound)                           AND   
                              passheadok                                  AND
                              passauxok
			   THEN BEGIN
				  MAKET_VERBP;
                                  $VERBP.Vmatrixhead:= true;

				  $VERBP.req        := reqvar;
				  $VERBP.env        := envvar;
				  $VERBP.voice      := passive;
				  $VERBP.synvpefs   := synvpefsvar;
				  $VERBP.thetavp    := thetavpvar;
				  $VERBP.foundauxes := foundauxesvar;
				  $VERBP.modus      := modusvar;
                                  $VERBP.classes    := classesvar;
				  $VERBP.aspect     := omegaaspect;
				  $VERBP.tense      := tensevar;
				  $VERBP.retro      := false;
                                  $VERBP.preadvok   := preadvok;
                                  $VERBP.objfound   := objfound;
                                  $VERBP.indobjfound:= ionpfound;
                                  $VERBP.anterelativeok := anterelativeokvar;
                                  $VERBP.reflexivity := reflexivityvar;
                                  $VERBP.persons     := verbpersonsvar;
                                  $VERBP.number      := verbnumbervar;
                                  $VERBP.synvpefs2   := synvpefsvar2;
                                  $VERBP.adjuncts    := adjunctsvar;
                                  $VERBP.adjvpefs    := adjvpefsvar;
                                  $VERBP.countenfound := countenfoundvar;
                                  $VERBP.locargfound := locargrelfound;
                                  $VERBP.dirargfound := dirargrelfound;
                                  $VERBP.aanobjfound := aanobjrelfound;
                                  $VERBP.prepobjfound := prepobjrelfound;
                                  $VERBP.voorobjfound := voorobjrelfound;
                                  $VERBP.nppredfound := nppredrelfound;
                                  $VERBP.adjpppredfound := adjppredrelfound;
                                  $VERBP.prepppredfound := prepppredrelfound;
                                  $VERBP.strandedfound := strandedrelfound;
                                  $VERBP.postvpofound := postvporelfound;
                                  $VERBP.vpcomplfound := vpcomplrelfound;

				  IF    (modusvar IN [indicative, subjunctive]) 
				  THEN  $VERBP.finiteness := finite
				  ELSE  $VERBP.finiteness := infinite;

				  IF $VERBP.modus = infinitive 
				  THEN BEGIN
				   IF   statusvar IN [bareV, VV, AuxV]
				   THEN $VERBP.infsort := inf
				   ELSE $VERBP.infsort := teinf;
				  END
				  ELSE $VERBP.infsort := omegainf;

			   END !(* if passive IN possvoicesvar etc.*);
  
  !(*Active*)
			   IF  (active IN possvoicesvar)                   AND
			       (NOT (wordenaux IN foundauxesvar))          AND
              	     	       (
                                (VRfound 
                                )                           OR 
                                (
                                 (NOT doorbyrelfound) AND
                                 (NOT doorbyfound) 
                                )
                               )                                           AND 
                               perfauxok
			   THEN BEGIN
				  MAKET_VERBP;
                                  $VERBP.Vmatrixhead:= true;

				  $VERBP.req        := reqvar;
				  $VERBP.env        := envvar;
				  $VERBP.voice      := active;
				  $VERBP.synvpefs   := synvpefsvar;
				  $VERBP.thetavp    := thetavpvar;
				  $VERBP.foundauxes := foundauxesvar;
				  $VERBP.modus      := modusvar;
                                  $VERBP.tense      := tensevar;
                                  $VERBP.classes    := classesvar;
				  $VERBP.aspect     := omegaaspect;
				  $VERBP.retro      := false;
                                  $VERBP.preadvok   := preadvok;
                                  $VERBP.objfound   := objfound;
                                  $VERBP.indobjfound:= ionpfound;
                                  $VERBP.anterelativeok := anterelativeokvar;
                                  $VERBP.reflexivity := reflexivityvar;
                                  $VERBP.persons     := verbpersonsvar;
                                  $VERBP.number      := verbnumbervar;
                                  $VERBP.synvpefs2   := synvpefsvar2;
                                  $VERBP.adjuncts    := adjunctsvar;
                                  $VERBP.adjvpefs    := adjvpefsvar;
                                  $VERBP.countenfound := countenfoundvar;
                                  $VERBP.locargfound := locargrelfound;
                                  $VERBP.dirargfound := dirargrelfound;
                                  $VERBP.aanobjfound := aanobjrelfound;
                                  $VERBP.prepobjfound := prepobjrelfound;
                                  $VERBP.voorobjfound := voorobjrelfound;
                                  $VERBP.nppredfound := nppredrelfound;
                                  $VERBP.adjpppredfound := adjppredrelfound;
                                  $VERBP.prepppredfound := prepppredrelfound;
                                  $VERBP.strandedfound := strandedrelfound;
                                  $VERBP.postvpofound := postvporelfound;
                                  $VERBP.vpcomplfound := vpcomplrelfound;

				  IF    (modusvar IN [indicative, subjunctive]) 
				  THEN  $VERBP.finiteness := finite
				  ELSE  $VERBP.finiteness := infinite;
				  IF $VERBP.modus = infinitive 
				  THEN BEGIN
				     IF   statusvar IN [bareV, VV, AuxV]
				     THEN $VERBP.infsort := inf
				     ELSE $VERBP.infsort := teinf;
				  END!(*finiteness*);
				END !(*headfound; active*)
		     END  !(*synvpefsvar <> []*);
                   END !(*IF  ( (modusvar <> infinitive)  OR
                              (statusvar IN [etc.])
                            ) 
                       *);

!(* modusvar = infinitive, which is not the matrix verb
  eg. (hij kan) de boeken kopen 
*)
                   IF (modusvar = infinitive)                        AND
                      (NOT(statusvar IN [aanhetV]))                  AND
                      (Norealobjoriobjfound)

                   THEN BEGIN
                     IF  VRfound
                     THEN synvpefsvar2 := unreducedsynvpsvar2
                     ELSE synvpefsvar2 := unreducedsynvpsvar;

                     synvpefsvar2 := synvpefsvar2 - AUX_oblVRvps;

                      reducevps(synvpefsvar2);
 
                    IF   (synvpefsvar2 <> [])
                    THEN BEGIN
                       MAKET_VERBP;
                       $VERBP.Vmatrixhead:= false;
                       
                       $VERBP.req        := reqvar;
                       $VERBP.env        := envvar;
		       $VERBP.voice      := active;
                       $VERBP.synvpefs   := [];
                       $VERBP.thetavp    := thetavpvar;
                       $VERBP.foundauxes := foundauxesvar;
                       $VERBP.modus      := modusvar;
                       $VERBP.tense      := tensevar;
                       $VERBP.classes    := classesvar;
                       $VERBP.aspect     := omegaaspect;
                       $VERBP.retro      := false;
                       $VERBP.preadvok   := preadvok;
                       $VERBP.objfound   := objfound;
                       $VERBP.indobjfound:= ionpfound;
                       $VERBP.finiteness := infinite;
                       $VERBP.anterelativeok := false;
                       $VERBP.reflexivity := reflexivityvar;
                       $VERBP.persons     := verbpersonsvar;
                       $VERBP.number      := verbnumbervar;
                       $VERBP.synvpefs2   := synvpefsvar2;
                       $VERBP.adjuncts    := adjunctsvar;
                       $VERBP.adjvpefs    := adjvpefsvar;
                       $VERBP.countenfound := countenfoundvar;
                       $VERBP.locargfound := locargrelfound;
                       $VERBP.dirargfound := dirargrelfound;
                       $VERBP.aanobjfound := aanobjrelfound;
                       $VERBP.prepobjfound := prepobjrelfound;
                       $VERBP.voorobjfound := voorobjrelfound;
                       $VERBP.nppredfound := nppredrelfound;
                       $VERBP.adjpppredfound := adjppredrelfound;
                       $VERBP.prepppredfound := prepppredrelfound;
                       $VERBP.strandedfound := strandedrelfound;
                       $VERBP.postvpofound := postvporelfound;
                       $VERBP.vpcomplfound := vpcomplrelfound;

                       IF $VERBP.modus = infinitive 
                       THEN BEGIN
			  IF   statusvar IN [bareV, partV, VV, AuxV, prepV]
			  THEN $VERBP.infsort := inf
			  ELSE $VERBP.infsort := teinf
                       END!(*$VERBP.modus = infinitive*);
                     END  !(*IF (synvpefsvar <> []) THEN*)
                   END;!(*modusvar = infinitive*)
		 END !(*final action*)


*>
END;
& !(* VP *) 

%%
%DUTCH
&
%NP1rule

REGULAREXPRESSION:

NP = [POSSADJ/1 | DETP/2 | NP/3] . [CN/4] . [THANP/5 | PREPP/6]
                                                         

CONDITIONSANDACTIONS:
  VAR  DETPfound :: BOOLEAN;
       pnunderCNfound :: BOOLEAN;
       specpnfound :: BOOLEAN;
       CNfound :: BOOLEAN;
       CNheadfound :: BOOLEAN;
       possadjfound :: BOOLEAN;
       modifiedADJPinCNfound ::: BOOLEAN;
       qpunderdetpfound ::: BOOLEAN;

       !(*the next four parameters function together; 
        cf. comment in finalaction*)

       defarticlefound :: BOOLEAN;
       nonNUMmodrelfound :: BOOLEAN;
       NUMmodrelfound :: BOOLEAN;
       postmodrelfound :: BOOLEAN; 

       CNoptional :: BOOLEAN;
       WHDETfound ::: BOOLEAN;
       definitepar ::: deftype;
       personpar :: persontype;
       numberspar :: numberSETtype;
       possnumberspar :: numberSETtype;
       casespar :: caseSETtype;
       genderspar :: genderSETtype;
       sexespar :: sexSETtype;
       actsubcspar :: nounsubcSETtype;
       temporalpar :: temporaltype;
       possgenipar :: possgenitype;
       animatepar :: animatetype;
       humanpar :: humantype;
       posscomaspar ::: posscomaSETtype;
       actcomaspar :: posscomaSETtype;
       thetanppar :: thetanptype;
       nounpatternefspar :: synpatternSETtype;
       posspredpar :: posspredtype;
       possnietnppar :: possnietnptype;
       detnpmoodpar :: xpmoodtype;
       syntquantpar :: syntquanttype;
       specQpar     :: specQtype;
       classpar :: timeadvclasstype;
       deixispar  :: deixistype;
       aspectpar  :: aspecttype;
       retropar   :: retrotype;
?
HELP 
FUNCTION noartunderdetp(t1:LSSTREE_pstree):BOOLEAN;
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=TRUE;
     sonlist:=t1^.sons;
     IF sonlist^.brother=NIL THEN
       IF sonlist^.node^.cat IN [ART, DEMADJ] THEN result:=FALSE;
     WHILE result AND (sonlist<>NIL) DO
       BEGIN
       IF sonlist^.node^.cat=DETP THEN 
         IF sonlist^.relation=head THEN
         result:=noartunderdetp(sonlist^.node);
       sonlist:=sonlist^.brother
       END;
     noartunderdetp:=result;
     END; !(*noartunderdetp*)


FUNCTION noeenNUMunderdetp(t1:LSSTREE_pstree):BOOLEAN;  
                            !(* This condition is supposed to be 
                              met if the head of the DETP
                              is not the numeral `een'; FJ, 19-12-88*)
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=TRUE;
     sonlist:=t1^.sons;
     WHILE result AND (sonlist<>NIL) DO
       BEGIN
       IF sonlist^.node^.cat=NUM THEN 
        IF sonlist^.relation=head THEN
         BEGIN
         IF sonlist^.node^.ls^.numfield^.key=KEY_een1NUMkey THEN result:=FALSE;
         END;
       sonlist:=sonlist^.brother
       END;
     noeenNUMunderdetp:=result;
     END; !(*noeenNUMunderdetp*)

FUNCTION defartunderdetp(t1:LSSTREE_pstree):BOOLEAN;  
                            !(* This condition is supposed to be 
                              met if the head of the DETP
                              is a definite article; FJ, 19-12-88.
                              It is relevant to block  headless NPs such as
                              de twee EN, het EN dorp uit, etc. *)
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;
     WHILE NOT (result) AND (sonlist<>NIL) DO
       BEGIN
       IF sonlist^.node^.cat=ART THEN 
        IF sonlist^.relation=head THEN
         BEGIN
         IF sonlist^.node^.ls^.artfield^.definite= def THEN result:= TRUE;
         END;
       sonlist:=sonlist^.brother
       END;
     defARTunderdetp:=result;
     END; !(*defartunderdetp*)

FUNCTION headundercn(t1:LSSTREE_pstree):BOOLEAN; !(*FJ; 03-10-89*)
                                 !(*this function is used to assign
                                  the value ennp for .NPhead in the proper 
                                  cases*)
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;
     WHILE NOT(result) AND (sonlist<>NIL) DO
       BEGIN
       IF ((sonlist^.node^.cat=NOUN) AND (sonlist^.relation=head)) THEN
       result:=TRUE;
       sonlist:=sonlist^.brother
       END;
     headundercn:=result;
END; !(*headundercn*)

FUNCTION nonNUMmodundercn(t1:LSSTREE_pstree):BOOLEAN; !(*FJ; 03-10-89*)
                                 !(*in combination with the function 
                                  defARTunderDETP, nummodundercn, and
                                  postmodundercn, this function is 
                                  relevant to exclude headless NPs such
                                  as 'de twee EN', 'het EN dorp uit'.*)

     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;
     WHILE NOT(result) AND (sonlist<>NIL) DO
       BEGIN
       IF ((sonlist^.node^.cat <> DETP) AND (sonlist^.relation=modrel)) THEN
       result:=TRUE;
       sonlist:=sonlist^.brother
       END;
     nonNUMmodundercn:=result;
END; !(*nonNUMmodundercn*)

FUNCTION NUMmodundercn(t1:LSSTREE_pstree):BOOLEAN; !(*FJ; 03-10-89*)
                                 !(*in combination with the function 
                                  defARTunderDETP, nonnummodundercn, and
                                  postmodundercn, this function is 
                                  relevant to exclude headless NPs such
                                  as 'de twee EN', 'het EN dorp uit'.*)

     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;
     WHILE NOT(result) AND (sonlist<>NIL) DO
       BEGIN
       IF ((sonlist^.node^.cat = DETP) AND (sonlist^.relation=modrel)) THEN
       result:=TRUE;
       sonlist:=sonlist^.brother
       END;
     NUMmodundercn:=result;
END; !(*NUMmodundercn*)

FUNCTION postmodundercn(t1:LSSTREE_pstree):BOOLEAN; !(*FJ; 03-10-89*)
                                 !(*in combination with the function 
                                  defARTunderDETP, nummodundercn, and
                                  postmodundercn, this function is 
                                  relevant to exclude headless NPs such
                                  as 'de twee EN', 'het EN dorp uit'.*)

     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;
     WHILE NOT(result) AND (sonlist<>NIL) DO
       BEGIN
       IF ((sonlist^.node^.cat IN [SENTENCE, PREPP]) 
                        AND (sonlist^.relation = postmodrel)) THEN
       result:=TRUE;
       sonlist:=sonlist^.brother
       END;
     postmodundercn:=result;
END; !(*postmodundercn*)

!(* ook in lssurfquo:*)
FUNCTION qpunderdetp(t1:LSSTREE_pstree):BOOLEAN;
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;
     WHILE NOT(result) AND (sonlist<>NIL) DO
       BEGIN
       IF sonlist^.node^.cat=QP THEN result:=TRUE;
       sonlist:=sonlist^.brother
       END;
     qpunderdetp:=result;
END; !(*qpunderdetp*)

FUNCTION pnundercn(t1:LSSTREE_pstree):BOOLEAN; !(*JO*)
     VAR result:BOOLEAN;
         son, sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;
     WHILE NOT(result) AND (sonlist<>NIL) DO
       BEGIN
       IF sonlist^.node^.cat=NOUN THEN BEGIN 
            result:=TRUE;
            son := sonlist^.node^.sons
                                       END;
       sonlist:=sonlist^.brother
       END;
     IF result THEN result := (son <> NIL);
     IF result THEN BEGIN
                 result := (son^.node^.cat = SUBNOUN);
                 IF result THEN son := son^.node^.sons;
                    END;
     IF result THEN result := (son  <> NIL);
     IF result THEN BEGIN
                 result := (son^.node^.cat = BPROPERNOUN);
                    END;
     pnundercn:=result;
END !(*pnundercn*);

FUNCTION postmodPNundercn(t1:LSSTREE_pstree):BOOLEAN; !(*FJ; 03-10-89*)
                                 !(*this function is 
                                  relevant to determine the set the 
                                  value for definiteness to def in case 
                                  of detless count singular NPs *)

     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;
     WHILE NOT(result) AND (sonlist<>NIL) DO
       BEGIN
       IF ((sonlist^.node^.cat IN [PROPERNOUN]) AND
           (sonlist^.relation = postmodrel)) THEN
       result:=TRUE;
       sonlist:=sonlist^.brother
       END;
     postmodPNundercn:=result;
END; !(*postmodPNundercn*)

FUNCTION pnundercnok : BOOLEAN;
BEGIN
pnundercnok :=  ((NOT pnundercnfound) OR 
               (possadjfound OR detpfound ) 
              );
END !(*pnundercnok*);


?


<*
 HINIT:BEGIN
         pnundercnfound := false;
         specpnfound := false;
         qpunderdetpfound := false;
         possadjfound := false;
         DETPfound := false;
         CNfound := false;
         CNheadfound := false;
         defarticlefound := false;
         nonNUMmodrelfound := false;
         NUMmodrelfound := false;
         postmodrelfound := false;
         CNoptional := true;
         WHDETfound := false;
         definitepar := omegadef ;  
         personpar := 3;
         numberspar := [];   
         possnumberspar := [singular, plural];  !(*JO*)
         casespar := [nominative, accusative, dative];
         genderspar := [omegagender];
         sexespar := [];
         actsubcspar := [othernoun];
         temporalpar := false;
         possgenipar := false;
         animatepar := omegaAnimate;
         humanpar := omegaHuman;
         posscomaspar := [];
         actcomaspar := [];
         thetanppar := omegathetanp;
         nounpatternefspar := [];
         posspredpar := false;
         possnietnppar := false;
         detnpmoodpar := declxpmood;
         syntquantpar := Omegaquant;
         specQpar  := omegaspec; 
         classpar := omegaTimeAdvClass;
         deixispar := omegadeixis;
         aspectpar := omegaAspect;
         retropar := false;
      END;

1     :<*
        LOCALCONDITION: (%POSSADJ.eORenForm <> enForm) AND
                        (%POSSADJ.geni = false)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := detrel;
                            detnpmoodpar := %POSSADJ.mood;
                            IF %POSSADJ.mood = wh THEN definitepar := indef
                                ELSE definitepar := def;
                            possnumberspar := [singular, plural];
                            posspredpar := true;
                            posscomaspar := [count,mass];
                            DETPfound := true;
                            possadjfound := true;
                          END
        *>

2     :<*
        LOCALCONDITION: (%DETP.eORenForm <> enForm) AND
                        noeenNUMunderdetp(b)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := detrel;
                            qpunderdetpfound:=qpunderdetp(b);
                            cnoptional:=noartunderdetp(b);
                            defarticlefound := defARTunderdetp(b);
                            possnietnppar := %DETP.possnietnp;
                            definitepar := %DETP.definite;
                            posspredpar := %DETP.posspred;
                            syntquantpar := %DETP.syntquant;
                            posscomaspar := %DETP.posscomas;
                            possnumberspar := %DETP.possnumbers;
                            detnpmoodpar   := %DETP.mood;           !(*JO*)
                            IF %DETP.mood = wh
                            THEN WHDETfound := true;
                            DETPfound := true;
                          END
        *>

3     :<*
        LOCALCONDITION: (genitive IN %NP.cases)  AND
                         (%NP.coord <> corrcoord)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := detrel;
                            possnietnppar := %NP.possnietnp;
                            definitepar := def;
                            posspredpar := true;
                            syntquantpar := omegaquant;
                            detnpmoodpar   := %NP.mood;        
                            posscomaspar := [count,mass];
                            DETPfound := true
                          END
        *>

4     :<*
        LOCALCONDITION: TRUE
        GLOBAL: #CONDITION: ((%CN.definite <> def) OR
                             (definitepar IN [def, adef]) OR
                             (WHDETfound = true ))             AND
                            ((%CN.definite <> indef) OR
                            (definitepar IN [indef]))        AND
                            ((posscomaspar = []) OR
                             (posscomaspar * %CN.posscomas <> []))
                                                            
                #ACTION:  BEGIN
                            SYNREL := head;
                            modifiedADJPinCNfound := modifiedADJPinCN(b);
                            IF (definitepar = omegadef)
                               THEN definitepar := indef;
                            IF NOT DETPfound 
                               THEN BEGIN
                                    posspredpar := true;
                                    possnietnppar := true;
                                    END;
                            numberspar := %CN.numbers;
                            casespar := %CN.cases;
                            genderspar := %CN.genders;
                            sexespar := %CN.sexes;
                            actsubcspar := %CN.actsubcs;
                            temporalpar := %CN.temporal;
                            possgenipar := %CN.possgeni;
                            animatepar := %CN.animate;
                            humanpar := %CN.human;
                            thetanppar := %CN.thetanp;
                            nounpatternefspar := %CN.nounpatternefs;
                            classpar := %CN.class;
                            deixispar  :=  %CN.deixis;
                            aspectpar  := %CN.aspect;
                            retropar   := %CN.retro;
                            IF plural IN numberspar 
                               THEN actcomaspar := [count] 
                               ELSE IF ((DETPfound = true) AND
                                        (posscomaspar = [count]))
                                    THEN actcomaspar := [count] 
                               ELSE IF ((NOT DETPfound) AND
                                       (mass in posscomaspar))
                                    THEN actcomaspar := [mass]
                               ELSE actcomaspar := %CN.posscomas;         
                            thetanppar := %CN.thetanp;
                            CNfound := true;
                            nonNUMmodrelfound := nonnummodundercn(b);
                            NUMmodrelfound := nummodundercn(b);
                            postmodrelfound := postmodundercn(b); 
                            CNheadfound := headundercn(b);
                            pnundercnfound := pnundercn(b);
                            specpnfound := postmodPNundercn(b);
                          END
        *>

5     :<*
        LOCALCONDITION: TRUE
        GLOBAL: #CONDITION: qpunderdetpfound OR
                            modifiedADJPinCNfound
                #ACTION:  BEGIN
                            SYNREL := extraposrel;
                          END
        *>

6     :<*
        LOCALCONDITION: (%PREPP.headkey = KEY_vanprepkey) AND
                        (%PREPP.coord <> corrcoord) 

        GLOBAL: #CONDITION: qpunderdetpfound OR
                            modifiedADJPinCNfound
                #ACTION:  BEGIN
                            SYNREL := extraposrel;
                          END
        *>




HFINAL: #CONDITION: (pnundercnok)            AND
                    (DETPfound OR CNfound)   AND 
                    (CNfound OR CNoptional)  AND
                    ((NOT possadjfound) OR
                     CNfound
                    )                               !(*JO  13-SEP-1988 14:00:22*) 
                                             AND
                    (possadjfound <= Cnheadfound)   !(*JO  29-MAY-1990 21:33:00  *)
        #ACTION: BEGIN
                 IF ((CNfound= true ) AND
                     (CNheadfound = true) AND
                     (singular IN possnumberspar) AND
                     (singular IN numberspar)
                    ) !(*FJ 26-09-1988*)
                 THEN
                   BEGIN
                   MAKET_NP;
                   $NP.number := singular;
                   IF detnpmoodpar <> declxpmood THEN 
                        $NP.mood := detnpmoodpar;
                   IF ((NOT DETPfound ) AND
                       (specPNfound) AND
                       (actsubcspar * [professionnoun, institutename]
                                    <> []) AND
                       (count IN actcomaspar))
                     THEN definitepar := def ;
                   $NP.definite := definitepar;
                   $NP.person := 3; 
                   $NP.cases := casespar;
                   $NP.genders := genderspar;
                   $NP.sexes := sexespar;
                   $NP.actsubcs := actsubcspar;
                   $NP.temporal := temporalpar;
                   $NP.possgeni := possgenipar;
                   $NP.animate := animatepar;
                   $NP.human := humanpar;
                   $NP.actcomas := actcomaspar;
                   $NP.thetanp := thetanppar;
                   $NP.nounpatternefs := nounpatternefspar;
                   $NP.posspred := posspredpar;
                   $NP.possnietnp := possnietnppar;
                   $NP.generic := omegageneric;
                   $NP.possRform := false;
                   $NP.syntquant := syntquantpar;
                   $NP.NPhead := otherNP;
                   $NP.specQ  := yesspec;  !(*JO; dit is fout, maar voor testen
                              even zo gedaan*)
                   $NP.superdeixis := omegadeixis;
                   $NP.class := classpar;
                   $NP.deixis := deixispar;
                   $NP.aspect := aspectpar;
                   $NP.retro := retropar;

                   END;
                 IF ((CNfound = true) AND 
                     (CNheadfound = true) AND
                     (plural IN possnumberspar) AND
                     (plural IN numberspar)
                    )
                 THEN
                   BEGIN
                   MAKET_NP;
                   $NP.number := plural;
                   IF detnpmoodpar <> declxpmood THEN 
                      $NP.mood := detnpmoodpar;
                   $NP.definite := definitepar;
                   $NP.person := 3; 
                   $NP.cases := casespar;
                   $NP.genders := genderspar;
                   $NP.sexes := sexespar;
                   $NP.actsubcs := actsubcspar;
                   $NP.temporal := temporalpar;
                   $NP.possgeni := possgenipar;
                   $NP.animate := animatepar;
                   $NP.human := humanpar;
                   $NP.actcomas := actcomaspar; 
                   $NP.thetanp := thetanppar;
                   $NP.nounpatternefs := nounpatternefspar;
                   $NP.posspred := posspredpar;
                   $NP.possnietnp := possnietnppar;
                   $NP.generic := omegageneric;
                   $NP.possRform := false;
                   $NP.syntquant := syntquantpar;
                   $NP.NPhead := otherNP;
                   $NP.specQ  := yesspec;!(*JO, fout maar voor het testen*)
                   $NP.superdeixis := omegadeixis;
                   $NP.class := classpar;
                   $NP.deixis := deixispar;
                   $NP.aspect := aspectpar;
                   $NP.retro := retropar;
                   END;
                 IF ((CNfound = false) AND           !(*JO  2meest6-OCT-1988 17:29:40*)
                     (singular IN possnumberspar) AND
                     (mass IN posscomaspar)
                    )
                 THEN
                   BEGIN
                   MAKET_NP;
                   $NP.number := singular;
                   IF detnpmoodpar <> declxpmood THEN 
                      $NP.mood := detnpmoodpar;
                   $NP.definite := definitepar;
                   $NP.person := 3; 
                   $NP.cases := casespar;
                   $NP.genders := genderspar;
                   $NP.sexes := sexespar;
                   $NP.actsubcs := actsubcspar;
                   $NP.temporal := temporalpar;
                   $NP.possgeni := possgenipar;
                   $NP.animate := animatepar;
                   $NP.human := humanpar;
                   $NP.actcomas := [mass]; 
                   $NP.thetanp := thetanppar;
                   $NP.nounpatternefs := nounpatternefspar;
                   $NP.posspred := posspredpar;
                   $NP.possnietnp := possnietnppar;
                   $NP.generic := omegageneric;
                   $NP.possRform := false;
                   $NP.syntquant := syntquantpar;
                   $NP.NPhead := enokNP;
                   $NP.specQ  := yesspec;!(*JO, fout maar voor het testen*)
                   $NP.superdeixis := omegadeixis;
                   $NP.class := classpar;
                   $NP.deixis := deixispar;
                   $NP.aspect := aspectpar;
                   $NP.retro := retropar;
                   END;
                 IF ((CNfound = true) AND           !(*FJ 03-OCT-1989: 
                                                     twee oude EN; die twee EN*)
                     (CNheadfound = false) AND
                     (plural IN possnumberspar) AND
                     (count IN posscomaspar) AND
                     !(* next subcondition should exlude: 
                       'de twee EN', 'de EN trappen op'*) 
                      (NOT(
                           (defarticlefound) AND 
                                 (NOT ((nonnummodrelfound) OR
                                       ( (nummodrelfound) AND
                                         (postmodrelfound)
                                       )
                                      )
                                 )
                          )
                      )
                    )
                 THEN
                   BEGIN
                   MAKET_NP;
                   $NP.number := plural;
                   IF detnpmoodpar <> declxpmood THEN 
                      $NP.mood := detnpmoodpar;
                   $NP.definite := definitepar;
                   $NP.person := 3; 
                   $NP.cases := casespar;
                   $NP.genders := genderspar;
                   $NP.sexes := sexespar;
                   $NP.actsubcs := actsubcspar;
                   $NP.temporal := temporalpar;
                   $NP.possgeni := possgenipar;
                   $NP.animate := animatepar;
                   $NP.human := humanpar;
                   $NP.actcomas := [count]; 
                   $NP.thetanp := thetanppar;
                   $NP.nounpatternefs := nounpatternefspar;
                   $NP.posspred := posspredpar;
                   $NP.possnietnp := possnietnppar;
                   $NP.generic := omegageneric;
                   $NP.possRform := false;
                   $NP.syntquant := syntquantpar;
                   $NP.NPhead := enokNP;
                   $NP.specQ  := yesspec;!(*JO, fout maar voor het testen*)
                   $NP.superdeixis := omegadeixis;
                   $NP.class := classpar;
                   $NP.deixis := deixispar;
                   $NP.aspect := aspectpar;
                   $NP.retro := retropar;
                   END;
                 IF ((CNfound = true) AND           !(*FJ 03-OCT-1989: 
                                                     een oude EN, die gele EN*)
                     (CNheadfound = false) AND
                     (singular IN possnumberspar) AND
                     (count IN posscomaspar) AND
                     !(* next subcondition should exlude: 
                       'de twee EN', 'de EN trappen op'*) 
                      (NOT(
                           (defarticlefound) AND 
                                 (NOT ((nonnummodrelfound) OR
                                       ( (nummodrelfound) AND
                                         (postmodrelfound)
                                       )
                                      )
                                 )
                          )
                      )
                    )
                 THEN
                   BEGIN
                   MAKET_NP;
                   $NP.number := singular;
                   IF detnpmoodpar <> declxpmood THEN 
                      $NP.mood := detnpmoodpar;
                   $NP.definite := definitepar;
                   $NP.person := 3; 
                   $NP.cases := casespar;
                   $NP.genders := genderspar;
                   $NP.sexes := sexespar;
                   $NP.actsubcs := actsubcspar;
                   $NP.temporal := temporalpar;
                   $NP.possgeni := possgenipar;
                   $NP.animate := animatepar;
                   $NP.human := humanpar;
                   $NP.actcomas := [count]; 
                   $NP.thetanp := thetanppar;
                   $NP.nounpatternefs := nounpatternefspar;
                   $NP.posspred := posspredpar;
                   $NP.possnietnp := possnietnppar;
                   $NP.generic := omegageneric;
                   $NP.possRform := false;
                   $NP.syntquant := syntquantpar;
                   $NP.NPhead := enokNP;
                   $NP.specQ  := yesspec;!(*JO, fout maar voor het testen*)
                   $NP.superdeixis := omegadeixis;
                   $NP.class := classpar;
                   $NP.deixis := deixispar;
                   $NP.aspect := aspectpar;
                   $NP.retro := retropar;
                   END;
                 IF ((CNfound = false) AND 
                     (singular IN possnumberspar) AND
                     (count IN posscomaspar)
                    ) 
                 THEN
                   BEGIN
                   MAKET_NP;
                   $NP.number := singular;
                   IF detnpmoodpar <> declxpmood THEN 
                      $NP.mood := detnpmoodpar;
                   $NP.definite := definitepar;
                   $NP.person := 3; 
                   $NP.cases := casespar;
                   $NP.genders := genderspar;
                   $NP.sexes := sexespar;
                   $NP.actsubcs := actsubcspar;
                   $NP.temporal := temporalpar;
                   $NP.possgeni := possgenipar;
                   $NP.animate := animatepar;
                   $NP.human := humanpar;
                   $NP.actcomas := [count]; 
                   $NP.thetanp := thetanppar;
                   $NP.nounpatternefs := nounpatternefspar;
                   $NP.posspred := posspredpar;
                   $NP.possnietnp := possnietnppar;
                   $NP.generic := omegageneric;
                   $NP.possRform := false;
                   $NP.syntquant := syntquantpar;
                   $NP.NPhead := enNP;
                   $NP.specQ  := yesspec;!(*JO, fout maar voor het testen*)
                   $NP.superdeixis := omegadeixis;
                   $NP.class := classpar;
                   $NP.deixis := deixispar;
                   $NP.aspect := aspectpar;
                   $NP.retro := retropar;
                   END;



                 IF ((NOT CNfound) AND 
                     (plural IN possnumberspar))
                 THEN
                   BEGIN
                   MAKET_NP;
                   $NP.number := plural;
                   IF detnpmoodpar <> declxpmood THEN 
                      $NP.mood := detnpmoodpar;
                   $NP.definite := definitepar;
                   $NP.person := 3; 
                   $NP.cases := casespar;
                   $NP.genders := genderspar;
                   $NP.sexes := sexespar;
                   $NP.actsubcs := actsubcspar;
                   $NP.temporal := temporalpar;
                   $NP.possgeni := possgenipar;
                   $NP.animate := animatepar;
                   $NP.human := humanpar;
                   $NP.actcomas := [count]; 
                   $NP.thetanp := thetanppar;
                   $NP.nounpatternefs := nounpatternefspar;
                   $NP.posspred := posspredpar;
                   $NP.possnietnp := possnietnppar;
                   $NP.generic := omegageneric;
                   $NP.possRform := false;
                   $NP.syntquant := syntquantpar;
                   $NP.NPhead := enNP;
                   $NP.specQ  := yesspec;!(*JO, fout maar voor het testen*)
                   $NP.superdeixis := omegadeixis;
                   $NP.class := classpar;
                   $NP.deixis := deixispar;
                   $NP.aspect := aspectpar;
                   $NP.retro := retropar;
                   END;
                 END
*>
END;
&                           

%NP1arule     

REGULAREXPRESSION:

NP = DETP/2 . [CN/4]

CONDITIONSANDACTIONS:
  VAR  CNheadfound :: BOOLEAN;
       definitepar :: deftype;
       personpar :: persontype;
       numberspar :: numberSETtype;
       possnumberspar :: numberSETtype;
       casespar :: caseSETtype;
       genderspar :: genderSETtype;
       sexespar :: sexSETtype;
       actsubcspar :: nounsubcSETtype;
       temporalpar :: temporaltype;
       possgenipar :: possgenitype;
       animatepar :: animatetype;
       humanpar :: humantype;
       posscomaspar :: posscomaSETtype;
       actcomaspar :: posscomaSETtype;
       thetanppar :: thetanptype;
       nounpatternefspar :: synpatternSETtype;
       posspredpar :: posspredtype;
       possnietnppar :: possnietnptype;
       detnpmoodpar :: xpmoodtype;
       syntquantpar :: syntquanttype;
       specQpar     :: specQtype;
       classpar :: timeadvclasstype;
       deixispar  :: deixistype;
       aspectpar  :: aspecttype;
       retropar   :: retrotype;
                                                         

!(*this rule NP1arule is meant for NPs consisting of 
 numeral "een" as DETP, possibly followed by a PP: een met een strikje *)

?
HELP
FUNCTION eenNUMunderdetp(t1:LSSTREE_pstree):BOOLEAN;  
                            !(* This condition is supposed to be 
                              met if the head of the DETP
                              is the numeral `een'; FJ, 19-11-89*)

     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;
     WHILE result AND (sonlist<>NIL) DO
       BEGIN
       IF sonlist^.node^.cat=NUM THEN 
        IF sonlist^.relation=head THEN
         BEGIN
         IF sonlist^.node^.ls^.numfield^.key=KEY_een1NUMkey THEN result:=TRUE;
         END;
       sonlist:=sonlist^.brother
       END;
     eenNUMunderdetp:=result;
     END; !(*eenNUMunderdetp*)

FUNCTION headundercn(t1:LSSTREE_pstree):BOOLEAN; !(*FJ; 03-10-89*)
                                 !(*this function is also used to assign
                                  the value ennp for .NPhead in the proper 
                                  cases*)
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;
     WHILE NOT(result) AND (sonlist<>NIL) DO
       BEGIN
       IF ((sonlist^.node^.cat=NOUN) AND (sonlist^.relation=head)) THEN
       result:=TRUE;
       sonlist:=sonlist^.brother
       END;
     headundercn:=result;
END; !(*headundercn*)
?


<*
 HINIT:BEGIN
         CNheadfound := false;
         definitepar := omegadef ;  
         personpar := 3;
         numberspar := [];   
         possnumberspar := [singular, plural];  !(*JO*)
         casespar := [nominative, accusative, dative];
         genderspar := [omegagender];
         sexespar := [];
         actsubcspar := [othernoun];
         temporalpar := false;
         possgenipar := false;
         animatepar := omegaAnimate;
         humanpar := omegaHuman;
         posscomaspar := [];
         actcomaspar := [];
         thetanppar := omegathetanp;
         nounpatternefspar := [];
         posspredpar := false;
         possnietnppar := false;
         detnpmoodpar := declxpmood;
         syntquantpar := Omegaquant;
         specQpar  := omegaspec; 
         classpar := omegaTimeAdvClass;
         deixispar := omegadeixis;
         aspectpar := omegaAspect;
         retropar := false;
      END;


2     :<*
        LOCALCONDITION: eenNUMunderdetp(b)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := detrel;
                            possnietnppar := %DETP.possnietnp;
                            definitepar := %DETP.definite;
                            posspredpar := %DETP.posspred;
                            syntquantpar := %DETP.syntquant;
                            posscomaspar := %DETP.posscomas;
                            possnumberspar := %DETP.possnumbers;
                            detnpmoodpar   := %DETP.mood;           !(*JO*)
                            
                          END
        *>

4     :<*
        LOCALCONDITION: headundercn(b) = false
        GLOBAL: #CONDITION: (%CN.definite <> def)
                #ACTION:  BEGIN
                            SYNREL := head;
                            numberspar := %CN.numbers;
                            casespar := %CN.cases;
                            genderspar := %CN.genders;
                            sexespar := %CN.sexes;
                            actsubcspar := %CN.actsubcs;
                            temporalpar := %CN.temporal;
                            possgenipar := %CN.possgeni;
                            animatepar := %CN.animate;
                            humanpar := %CN.human;
                            thetanppar := %CN.thetanp;
                            nounpatternefspar := %CN.nounpatternefs;
                            classpar := %CN.class;
                            deixispar  :=  %CN.deixis;
                            aspectpar  := %CN.aspect;
                            retropar   := %CN.retro;
                            thetanppar := %CN.thetanp;
                            CNheadfound := headundercn(b);
                          END
        *>
HFINAL: #CONDITION: CNheadfound = false
        #ACTION: BEGIN
                   MAKET_NP;
                   $NP.number := singular;
                   $NP.mood := detnpmoodpar;
                   $NP.definite := definitepar;
                   $NP.person := 3; 
                   $NP.cases := casespar;
                   $NP.genders := genderspar;
                   $NP.sexes := sexespar;
                   $NP.actsubcs := actsubcspar;
                   $NP.temporal := temporalpar;
                   $NP.possgeni := possgenipar;
                   $NP.animate := animatepar;
                   $NP.human := humanpar;
                   $NP.actcomas := [count];
                   $NP.thetanp := thetanppar;
                   $NP.nounpatternefs := nounpatternefspar;
                   $NP.posspred := posspredpar;
                   $NP.possnietnp := possnietnppar;
                   $NP.generic := omegageneric;
                   $NP.possRform := false;
                   $NP.syntquant := syntquantpar;
                   $NP.NPhead := enNP;
                   $NP.specQ  := yesspec;  !(*JO; dit is fout, maar voor testen
                              even zo gedaan*)
                   $NP.superdeixis := omegadeixis;
                   $NP.class := classpar;
                   $NP.deixis := deixispar;
                   $NP.aspect := aspectpar;
                   $NP.retro := retropar;
                   END;

*>
END;
&

%NP2rule

REGULAREXPRESSION:

NP = ( ( DEMPRO/1 | PERSPRO/2 | INDEFPRO/3 | WHPRO/4 | PROPERNOUN/5 )
      .{ PREPP/6 | PREPP/7 }
      .[SENTENCE/8]
    )
                                                         
CONDITIONSANDACTIONS:
  VAR  PROfound ::: BOOLEAN;
       definitepar :: deftype;
       personpar :: persontype;
       numberpar :: numbertype;
       casespar :: caseSETtype;
       genderspar :: genderSETtype;
       sexespar :: sexSETtype;
       actsubcspar :: nounsubcSETtype;
       temporalpar :: temporaltype;
       possgenipar :: possgenitype;
       animatepar :: animatetype;
       humanpar :: humantype;
       actcomaspar :: posscomaSETtype;
       posspredpar :: posspredtype;
       possnietnppar :: possnietnptype;
       detnpmoodpar :: xpmoodtype;
       genericpar :: generictype;
       possRformpar :: possRformtype;
       syntquantpar :: syntquanttype;
       NPheadpar :: NPheadtype;
       specQpar  :: specQtype;
       classpar :: timeadvclasstype;
       deixispar  :: deixistype;
       aspectpar  :: aspecttype;
       retropar   :: retrotype;
       indefproheadfound ::: BOOLEAN; !(*JO  24-MAR-1989 10:51:45 *)
       propernounheadfound::: BOOLEAN; !(*JO  24-MAR-1989 10:52:11 *)

<*
 HINIT:BEGIN
         PROfound := false;
         definitepar := omegadef;
         personpar := 3;
         numberpar := singular;
         casespar := [nominative, accusative, dative];
         genderspar := [omegagender];
         sexespar := [];
         actsubcspar := [othernoun];
         temporalpar := false;
         possgenipar := false;
         animatepar := omegaAnimate;
         humanpar := omegaHuman;
         actcomaspar := [count];
         posspredpar := false;
         possnietnppar := false;
         detnpmoodpar := declxpmood;
         genericpar := omegageneric;
         possRformpar := false;
         syntquantpar := Omegaquant;
         NPheadpar := otherNP;
         specQpar  := omegaspec; 
         classpar := omegaTimeAdvClass;
         deixispar := omegadeixis;
         aspectpar := omegaAspect;
         retropar := false;
         indefproheadfound := false; !(*JO  24-MAR-1989 10:51:45 *)
         propernounheadfound := false; !(*JO  24-MAR-1989 10:52:11 *)

      END;


1     :<*
        LOCALCONDITION: TRUE
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            definitepar := def;
                            possRformpar := true;

                            IF %DEMPRO.key = KEY_datDEMPROkey 
                            THEN BEGIN
                                 NPheadpar := datNP;
                                 actcomaspar := [];
                                 animatepar := noanimate;
                                 humanpar   := nohuman;
                                 END
                              ELSE IF %DEMPRO.key = KEY_ditDEMPROkey 
                              THEN BEGIN
                                   NPheadpar := ditNP;
                                   actcomaspar := [];
                                   animatepar := noanimate;
                                   humanpar   := nohuman;
                                   END
                                ELSE IF %DEMPRO.key = KEY_dieDEMPROkey 
                                THEN NPheadpar := dieNP;
                                !(* ELSE default *)

                            specqpar := yesspec ; !(*JO*)
                       
                          END
        *>

2     :<*
        LOCALCONDITION: TRUE
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            PROfound := true;
                            definitepar := def;
                            personpar := %PERSPRO.person;
                            numberpar := %PERSPRO.number;
                            casespar := %PERSPRO.persprocases;
                            genderspar := [%PERSPRO.gender];
                            animatepar := %PERSPRO.animate;
                            specqpar   := yesspec;  !(*JO*)
                            posspredpar := true; !(*JO*)
                            IF (%PERSPRO.NPhead = persproNP) AND
                               (%PERSPRO.reduced = true)
                            THEN NPheadpar := reducedpersproNP        !(*JO*)
                            ELSE NPheadpar := %PERSPRO.NPhead;
                            possRformpar := %PERSPRO.possRform; !(*JO*)

                            !(* assuming posspred = false (default) *)
                          END
        *>

3     :<*
        LOCALCONDITION: TRUE
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            indefproheadfound := true;
                            PROfound := true;
                            definitepar := %INDEFPRO.definite;
                            numberpar := %INDEFPRO.number;
                            possgenipar := %INDEFPRO.possgeni;
                            animatepar := %INDEFPRO.animate;
                            possnietnppar := %INDEFPRO.possnietnp;
                            possRformpar := %INDEFPRO.possRform;
                            syntquantpar := %INDEFPRO.syntquant;
                            NPheadpar := %INDEFPRO.NPhead;         !(*JO*)
                            specQpar := yesspec; !(* FJ; 16-01-89*)
                            !(* IF NPheadpar = menNP THEN specQpar := yesspec
                                                 ELSE specqpar := nospec; JO
                              tussen haken door FJ 16-01-89 *)
                            posspredpar := true; !(*JO*)
                            IF   NPheadpar=menNP 
                            THEN casespar:=[nominative];(*JO*)
                            IF    %INDEFPRO.geni 
                            THEN casespar := [genitive]; !(*JO*)
                            IF    %INDEFPRO.animate = yesanimate       !(*JO*)
                            THEN  humanpar := yeshuman;
                            IF    %INDEFPRO.animate = noanimate         !(*JO*)
                            THEN  humanpar := nohuman;

                            !(* assuming posspred = false (default) *)
                          END

        *>

4     :<*
        LOCALCONDITION: TRUE
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            PROfound := true;
                            definitepar := indef;
                            numberpar := %WHPRO.number;
                            sexespar := %WHPRO.sexes; 
                            animatepar := %WHPRO.animate;
                            possRformpar := %WHPRO.possRform;
                            detnpmoodpar := wh;
                            specqpar := yesspec;  !(*JO*)
                            posspredpar := true; !(*JO*)
                            syntquantpar := omegaquant ; !(*JO*)

                            IF %WHPRO.animate = noanimate
                             THEN BEGIN
                                    NPheadpar := watwhproNP;
                                    humanpar := nohuman;
                                  END
                             ELSE humanpar := yeshuman;

    
                          END
        *>

5     :<*
        LOCALCONDITION: %PROPERNOUN.subc <> monthnoun
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            PROfound := true;
                            propernounheadfound := true;
                            numberpar := %PROPERNOUN.number;
                            genderspar := %PROPERNOUN.genders;
                            sexespar := %PROPERNOUN.sexes;
                            actsubcspar := [%PROPERNOUN.subc];
                            temporalpar := %PROPERNOUN.temporal;
                            possgenipar := %PROPERNOUN.possgeni;
                            humanpar := %PROPERNOUN.human;
                            animatepar := %PROPERNOUN.animate;
                            definitepar := def;
                            posspredpar := true;
                            specqpar := yesspec; !(*JO*)
                            classpar := %PROPERNOUN.class;
                            deixispar  :=  %PROPERNOUN.deixis;
                            aspectpar  := %PROPERNOUN.aspect;
                            retropar   := %PROPERNOUN.retro;
                            IF %PROPERNOUN.geni THEN casespar := [genitive]; 
                                                           !(*JO*)
                          END
        *>

6     :<*
        LOCALCONDITION: (NOT %PREPP.stranded)    !(*JO*) !(*unless there are 
                        further are restrictions on prepsubcs *) 
                         AND ( %PREPP.headkey <> KEY_vanprepkey) AND 
                         (%PREPP.coord <> corrcoord) AND
                        (%PREPP.actsubcefs * [loc, dir, temp, comitative] <> [])
        GLOBAL: #CONDITION: PROfound
                #ACTION:  BEGIN
                            SYNREL := postmodrel
                          END
        *>

7     :<*
        LOCALCONDITION: (NOT %PREPP.stranded)    !(*JO*) !(*unless there are 
                        further are restrictions on prepsubcs *) 
                         AND (%PREPP.headkey = KEY_vanprepkey) AND
                         (%PREPP.coord <> corrcoord)
        GLOBAL: #CONDITION: PROfound
                #ACTION:  BEGIN
                            SYNREL := posrel
                          END
        *>

8: !(*added by JO  24-MAR-1989 10:58:40 *) 
       <*
         LOCALCONDITION: (%SENTENCE.mood = relative)  AND
                         (%SENTENCE.coord <> corrcoord)
         GLOBAL: #CONDITION: indefproheadfound OR
                             propernounheadfound
                 #ACTION:   BEGIN
                              SYNREL := postmodrel;
                            END
       *>

HFINAL: #CONDITION: TRUE
        #ACTION: BEGIN
                 MAKET_NP;
                 $NP.definite := definitepar;
                 $NP.number := numberpar;
                 $NP.person := personpar;
                 $NP.cases := casespar;
                 $NP.sexes := sexespar;       !(* 1,2,3 have default: [] *)
                 $NP.actsubcs := actsubcspar;
                 $NP.temporal := temporalpar;
                 $NP.possgeni := possgenipar; !(* 2,4 have default: false *)
                 $NP.animate := animatepar;   !(* 1 has default: omega *)
                 $NP.human := humanpar;       !(* 1,2,3,4 have default: omega *)
                 $NP.actcomas := actcomaspar;
                 $NP.posspred := posspredpar;
                 $NP.possnietnp := possnietnppar;
                 $NP.mood := detnpmoodpar;
                 $NP.generic := genericpar;
                 $NP.possRform := possRformpar;
                 $NP.syntquant := syntquantpar;
                 $NP.NPhead := NPheadpar;
                 $NP.specQ := specQpar;
                 $NP.class := classpar;
                 $NP.deixis := deixispar;
                 $NP.aspect := aspectpar;
                 $NP.retro := retropar;
                 $NP.genders := genderspar;   !(*JO*)
                 END
*>
END;
&                           


%NP3rule

REGULAREXPRESSION:

NP = ADVP/1 . NP/2
                                                         
CONDITIONSANDACTIONS:
  VAR  preADVfound ::: BOOLEAN;
       definitepar :: deftype;
       personpar :: persontype;
       numberpar :: numbertype;
       casespar :: caseSETtype;
       genderspar :: genderSETtype;
       sexespar :: sexSETtype;
       actsubcspar :: nounsubcSETtype;
       temporalpar :: temporaltype;
       possgenipar :: possgenitype;
       animatepar :: animatetype;
       humanpar :: humantype;
       actcomaspar :: posscomaSETtype;
       thetanppar :: thetanptype;
       nounpatternefspar :: synpatternSETtype;
       posspredpar :: posspredtype;
       possnietnppar :: possnietnptype;
       detnpmoodpar :: xpmoodtype;
       genericpar :: generictype;
       possRformpar :: possRformtype;
       syntquantpar :: syntquanttype;
       NPheadpar :: NPheadtype;
       specQpar  :: specQtype;
       classpar :: timeadvclasstype;
       deixispar  :: deixistype;
       aspectpar  :: aspecttype;
       retropar   :: retrotype;



<*
 HINIT:BEGIN
         preADVfound := false;
         definitepar := omegadef;
         personpar := 3;
         numberpar := singular;
         casespar := [nominative];
         genderspar := [omegagender];
         sexespar := [];
         actsubcspar := [othernoun];
         temporalpar := false;
         possgenipar := false;
         animatepar := omegaAnimate;
         humanpar := omegaHuman;
         actcomaspar := [count];
         thetanppar := omegathetanp;
         nounpatternefspar := [];
         posspredpar := false;
         possnietnppar := false;
         detnpmoodpar := declxpmood;
         genericpar := omegageneric;
         possRformpar := false;
         syntquantpar := Omegaquant;
         NPheadpar := otherNP;
         specQpar  := omegaspec;
         classpar := omegaTimeAdvClass;
         deixispar := omegadeixis;
         aspectpar := omegaAspect;
         retropar := false;
      END;


1     :<*
        LOCALCONDITION: PreXPAdv IN %ADVP.actsubcefs
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := modrel;
                            preADVfound := true
                          END
        *>

2     :<*
        LOCALCONDITION: (%NP.mood = declxpmood) AND
                         (%NP.coord <> corrcoord)
        GLOBAL: #CONDITION: preADVfound = true
                #ACTION:  BEGIN
                            SYNREL := head;
                            definitepar := %NP.definite;
                            personpar := %NP.person;
                            numberpar := %NP.number;
                            casespar := %NP.cases;
                            genderspar := %NP.genders;
                            sexespar := %NP.sexes;
                            actsubcspar := %NP.actsubcs;
                            temporalpar := %NP.temporal;
                            possgenipar := %NP.possgeni;
                            animatepar := %NP.animate;
                            humanpar := %NP.human;
                            actcomaspar := %NP.actcomas;
                            thetanppar := %NP.thetanp;
                            nounpatternefspar := %NP.nounpatternefs; 
                            posspredpar := %NP.posspred;
                            possnietnppar := %NP.possnietnp;
                            detnpmoodpar := %NP.mood;
                            genericpar := %NP.generic;
                            possRformpar := %NP.possRform;
                            syntquantpar := %NP.syntquant;
                            NPheadpar := %NP.NPhead;
                            specqpar  := %NP.specq;
                            classpar := %NP.class;
                            deixispar  :=  %NP.deixis;
                            aspectpar  := %NP.aspect;
                            retropar   := %NP.retro;
                          END
       *>

HFINAL: #CONDITION: TRUE
        #ACTION: BEGIN
                 MAKET_NP;
                 $NP.definite := definitepar;
                 $NP.person := personpar;
                 $NP.number := numberpar;
                 $NP.cases := casespar;
                 $NP.genders := genderspar;
                 $NP.sexes := sexespar;
                 $NP.actsubcs := actsubcspar;
                 $NP.temporal := temporalpar;
                 $NP.possgeni := possgenipar;
                 $NP.animate := animatepar;
                 $NP.human := humanpar;
                 $NP.actcomas := actcomaspar;
                 $NP.thetanp := thetanppar;
                 $NP.nounpatternefs := nounpatternefspar;
                 $NP.posspred := posspredpar;
                 $NP.possnietnp := possnietnppar;
                 $NP.mood := detnpmoodpar; 
                 $NP.generic := genericpar;
                 $NP.possRform := possRformpar;
                 $NP.syntquant := syntquantpar;
                 $NP.NPhead := NPheadpar;
                 $NP.specQ  := specQpar;
                 $NP.class := classpar;
                 $NP.deixis := deixispar;
                 $NP.aspect := aspectpar;
                 $NP.retro := retropar;
                 END
*>
END;
&                           


%NP4rule

REGULAREXPRESSION:

NP = RECIPRO/1
                                                         
CONDITIONSANDACTIONS:
  VAR  definitepar :: deftype;


<*
 HINIT:BEGIN
         definitepar := omegadef
       END;

1     :<*
        LOCALCONDITION: %RECIPRO.geni = false
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head
                          END
        *>

HFINAL: #CONDITION: TRUE
        #ACTION: BEGIN
                 MAKET_NP;
                 $NP.definite := def;            !(* ?? *)
                 $NP.number := plural;
                 $NP.cases := [dative,accusative];
                 $NP.actcomas := [count];
                 $NP.NPhead := elkaarNP;
                 $NP.generic := omegageneric;
                 $NP.specQ   := yesspec;         !(*?? JO*)
                 $NP.posspred := true;

                 !(* the other attributes have default value *)
                 END
*>
END;
&                           


%NP5rule

REGULAREXPRESSION:

NP = REFLPRO/1
                                                         
CONDITIONSANDACTIONS:
  VAR  numberpar :: numbertype;
       personpar :: persontype;


<*
 HINIT:BEGIN
         numberpar := singular;
         personpar := 3
       END;

1     :<*
        LOCALCONDITION: %REFLPRO.zelf = true
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            numberpar := %REFLPRO.number;
                            personpar := %REFLPRO.person
                          END
        *>

HFINAL: #CONDITION: TRUE
        #ACTION: BEGIN
                 MAKET_NP;
                 $NP.definite := def;
                 $NP.person := personpar;
                 $NP.number := numberpar;
                 $NP.cases := [dative,accusative];
                 $NP.thetanp := omegathetanp;
                 $NP.generic := omegageneric;
                 $NP.NPhead := zichzelfNP;
                 $NP.specQ   := yesspec;         !(*?? JO*)
                 IF personpar <> 3
                   THEN $NP.animate := yesanimate;
                 !(* the other attributes have default value *)
                 END
*>
END;
&

%NP6rule

REGULAREXPRESSION:

NP = (NP/1 . PUNC/2 . NP/3 . [PUNC/4])
                                                         

CONDITIONSANDACTIONS:
  VAR  
       definitepar :: deftype;
       personpar :: persontype;
       numberpar ::: numbertype;
       casespar ::: caseSETtype;
       genderspar :: genderSETtype;
       sexespar :: sexSETtype;
       actsubcspar :: nounsubcSETtype;
       temporalpar :: temporaltype;
       possgenipar :: possgenitype;
       animatepar :: animatetype;
       humanpar :: humantype;
       actcomaspar :: posscomaSETtype;
       thetanppar :: thetanptype;
       nounpatternefspar :: synpatternSETtype;
       genericpar :: generictype;
       possRformpar :: possRformtype;
       NPheadpar :: NPheadtype;
       posspredpar :: posspredtype;
       possnietnppar :: possnietnptype;
       detnpmoodpar :: xpmoodtype;
       syntquantpar :: syntquanttype;
       specQpar     :: specQtype;
       classpar :: timeadvclasstype;
       deixispar  :: deixistype;
       aspectpar  :: aspecttype;
       retropar   :: retrotype;


<*
 HINIT:BEGIN
         definitepar := omegadef ;  
         personpar := 3;
         numberpar := omeganumber;   
         casespar := [nominative, accusative, dative];
         genderspar := [omegagender];
         sexespar := [];
         actsubcspar := [othernoun];
         temporalpar := false;
         possgenipar := false;
         animatepar := omegaAnimate;
         humanpar := omegaHuman;
         actcomaspar := [];
         thetanppar := omegathetanp;
         nounpatternefspar := [];
         genericpar := omegageneric;
         possRformpar := false;
         NPheadpar := otherNP;
         posspredpar := false;
         possnietnppar := false;
         detnpmoodpar := declxpmood;
         syntquantpar := Omegaquant;
         specQpar  := omegaspec; 
         classpar := omegaTimeAdvClass;
         deixispar := omegadeixis;
         aspectpar := omegaAspect;
         retropar := false;
      END;


1     :<*
        LOCALCONDITION: (%NP.NPhead IN  [persproNP, othernp, allesnp]) AND
                        ( %NP.mood = declxpmood)  AND
                         (%NP.coord <> corrcoord)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            definitepar := %NP.definite; 
                            personpar := %NP.person;
                            numberpar := %NP.number;
                            casespar := %NP.cases;
                            genderspar := %NP.genders;
                            sexespar := %NP.sexes;
                            actsubcspar := %NP.actsubcs;
                            temporalpar := %NP.temporal;
                            possgenipar := %NP.possgeni;
                            animatepar := %NP.animate;
                            humanpar := %NP.human;
                            actcomaspar := %NP.actcomas;
                            thetanppar := %NP.thetanp;
                            nounpatternefspar := %NP.nounpatternefs;
                            genericpar := %NP.generic;
                            possRformpar := %NP.possRform;
                            NPheadpar := %NP.NPhead;
                            posspredpar := %NP.posspred;
                            possnietnppar := %NP.possnietnp;
                            detnpmoodpar := %NP.mood;
                            syntquantpar := %NP.syntquant;
                            specQpar  := %NP.specQ;
                            classpar := %NP.class;
                            deixispar  :=  %NP.deixis;
                            aspectpar  := %NP.aspect;
                            retropar   := %NP.retro;
                          END
        *>

2     :<*
        LOCALCONDITION: %PUNC.key = KEY_kommaPUNCkey 
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := puncrel;
                          END
        *>

3     :<*
        LOCALCONDITION: (%NP.NPhead IN [persproNP, othernp, allesnp]) AND
                        (%NP.mood = declxpmood)  AND
                         (%NP.coord <> corrcoord)
        GLOBAL: #CONDITION: (%NP.number = numberpar) AND
                            (%NP.cases = casespar) 
                #ACTION:  BEGIN
                            SYNREL := apposrel;
                          END
        *>

4     :<*
        LOCALCONDITION: %PUNC.key = KEY_kommaPUNCkey 
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := puncrel;
                          END
        *>

HFINAL: #CONDITION: TRUE
        #ACTION: BEGIN
                   MAKET_NP;
                 $NP.definite := definitepar;
                 $NP.person := personpar;
                 $NP.number := numberpar;
                 $NP.cases := casespar;
                 $NP.genders := genderspar;
                 $NP.sexes := sexespar;
                 $NP.actsubcs := actsubcspar;
                 $NP.temporal := temporalpar;
                 $NP.possgeni := possgenipar;
                 $NP.animate := animatepar;
                 $NP.human := humanpar;
                 $NP.actcomas := actcomaspar;
                 $NP.thetanp := thetanppar;
                 $NP.nounpatternefs := nounpatternefspar;
                 $NP.posspred := posspredpar;
                 $NP.possnietnp := possnietnppar;
                 $NP.mood := detnpmoodpar; 
                 $NP.generic := genericpar;
                 $NP.syntquant := syntquantpar;
                 $NP.NPhead := NPheadpar;
                 $NP.specQ  := specQpar;
                 $NP.class := classpar;
                 $NP.deixis := deixispar;
                 $NP.aspect := aspectpar;
                 $NP.retro := retropar;
                 END
*>
END;
&                           

%NP7rule

REGULAREXPRESSION:

NP = DETP/2 . [CN/4]
                                                         

CONDITIONSANDACTIONS:
  VAR  CNfound :: BOOLEAN;
       definitepar :: deftype;
       personpar :: persontype;
       numberspar :: numberSETtype;
       possnumberspar :: numberSETtype;
       casespar :: caseSETtype;
       genderspar :: genderSETtype;
       sexespar :: sexSETtype;
       actsubcspar :: nounsubcSETtype;
       temporalpar :: temporaltype;
       possgenipar :: possgenitype;
       animatepar :: animatetype;
       humanpar :: humantype;
       posscomaspar :: posscomaSETtype;
       actcomaspar :: posscomaSETtype;
       thetanppar :: thetanptype;
       nounpatternefspar :: synpatternSETtype;
       posspredpar :: posspredtype;
       possnietnppar :: possnietnptype;
       detnpmoodpar :: xpmoodtype;
       syntquantpar :: syntquanttype;
       specQpar     :: specQtype;
       possadjfound :: BOOLEAN;
       qpunderdetpfound :: BOOLEAN;
       classpar :: timeadvclasstype;
       deixispar  :: deixistype;
       aspectpar  :: aspecttype;
       retropar   :: retrotype;
?
HELP 
FUNCTION headundercn(t1:LSSTREE_pstree):BOOLEAN; !(*FJ; 03-10-89*)
                                 !(*this function is used to assign
                                  the value ennp/enoknp 
                                  for .NPhead in the proper 
                                  cases*)
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;
     WHILE NOT(result) AND (sonlist<>NIL) DO
       BEGIN
       IF ((sonlist^.node^.cat=NOUN) AND (sonlist^.relation=head)) THEN
       result:=TRUE;
       sonlist:=sonlist^.brother
       END;
     headundercn:=result;
END; !(*headundercn*)

FUNCTION noNUMunderdetp(t1:LSSTREE_pstree):BOOLEAN;
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=TRUE;
     sonlist:=t1^.sons;
     IF sonlist^.brother=NIL THEN
       IF sonlist^.node^.cat IN [NUM] THEN result:=FALSE;
     WHILE result AND (sonlist<>NIL) DO
       BEGIN
       IF sonlist^.node^.cat=DETP THEN 
         IF sonlist^.relation=head THEN
         result:=noNUMunderdetp(sonlist^.node);
       sonlist:=sonlist^.brother
       END;
     noNUMunderdetp:=result;
     END; !(*noNUMunderdetp*)
?




<*
 HINIT:BEGIN
         CNfound := false;
         definitepar := omegadef ;  
         personpar := 3;
         numberspar := [];   
         possnumberspar := [plural];  
         casespar := [nominative, accusative, dative];
         genderspar := [omegagender];
         sexespar := [];
         actsubcspar := [othernoun];
         temporalpar := false;
         possgenipar := false;
         animatepar := yesAnimate;
         humanpar := yesHuman;
         posscomaspar := [count];
         actcomaspar := [];
         thetanppar := omegathetanp;
         nounpatternefspar := [];
         posspredpar := false;
         possnietnppar := false;
         detnpmoodpar := declxpmood;
         syntquantpar := Omegaquant;
         specQpar  := omegaspec; 
         classpar := omegaTimeAdvClass;
         deixispar := omegadeixis;
         aspectpar := omegaAspect;
         retropar := false;
      END;


2     :<*
        LOCALCONDITION: (%DETP.eORenForm = enForm) AND
                        (%DETP.possnumbers * [plural] <> []) AND
                        (%DETP.posscomas * [count] <> []) AND
                        (noNUMunderdetp(b))    
                        !(*vele/veel en weinig zijn ook BDET; FJ*)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := detrel;
                            definitepar := %DETP.definite;
                            possnietnppar := %DETP.possnietnp;
                            syntquantpar := %DETP.syntquant;
                            detnpmoodpar   := %DETP.mood;           !(*JO*)
                          END
        *>

4     :<*
        LOCALCONDITION: NOT headundercn(b)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            numberspar := %CN.numbers;
                            casespar := %CN.cases;
                            genderspar := %CN.genders;
                            sexespar := %CN.sexes;
                            actsubcspar := %CN.actsubcs;
                            temporalpar := %CN.temporal;
                            possgenipar := %CN.possgeni;
                            animatepar := %CN.animate;
                            humanpar := %CN.human;
                            thetanppar := %CN.thetanp;
                            nounpatternefspar := %CN.nounpatternefs;
                            classpar := %CN.class;
                            deixispar  :=  %CN.deixis;
                            aspectpar  := %CN.aspect;
                            retropar   := %CN.retro;
                            thetanppar := %CN.thetanp;
                            CNfound := true;
                          END
        *>

HFINAL: #CONDITION: true
        #ACTION: BEGIN
                   MAKET_NP;
                   $NP.number := plural;
                   $NP.mood := detnpmoodpar;
                   $NP.definite := definitepar;
                   $NP.person := 3; 
                   $NP.cases := casespar;
                   $NP.genders := genderspar;
                   $NP.sexes := sexespar;
                   $NP.actsubcs := actsubcspar;
                   $NP.temporal := temporalpar;
                   $NP.possgeni := possgenipar;
                   $NP.animate := animatepar;
                   $NP.human := humanpar;
                   $NP.actcomas := [count]; 
                   $NP.thetanp := thetanppar;
                   $NP.nounpatternefs := nounpatternefspar;
                   $NP.posspred := posspredpar;
                   $NP.possnietnp := possnietnppar;
                   $NP.generic := omegageneric;
                   $NP.possRform := false;
                   $NP.syntquant := syntquantpar;
                   $NP.NPhead := enokNP;
                   $NP.specQ  := yesspec;!(*JO, fout maar voor het testen*)
                   $NP.superdeixis := omegadeixis;
                   $NP.class := classpar;
                   $NP.deixis := deixispar;
                   $NP.aspect := aspectpar;
                   $NP.retro := retropar;
                   END;
*>
END;
&                           


%DETPrule

REGULAREXPRESSION:

DETP = [ART/12] . (NUM/1 | DET/2 | DEMADJ/3 | QP/4 | ART/5 | CARD/11 |
       (DETP/6 . PREP/7 . (DETP/8 | NP/9 | POSSADJ/10)))
                                                         
CONDITIONSANDACTIONS:
  VAR  
       mfMEESTEexpected ::: BOOLEAN;
       neutMEESTEexpected ::: BOOLEAN;
       MEESTEfound :: BOOLEAN;
       possnietnppar :: possnietnptype;
       definitepar :: deftype;
       posspredpar :: posspredtype;
       possnumberspar :: numberSETtype;
       posscomaspar :: posscomaSETtype;
       detnpmoodpar :: xpmoodtype;
       syntquantpar :: syntquanttype;
       eorenformpar :: eorenformtype;
       possgenderspar :: genderSETtype;

?
HELP

FUNCTION nomeestqunderqp(t1:LSSTREE_pstree):BOOLEAN;  
                            !(* This condition is supposed to be 
                              met if the head of the DETP
                              is not `meest' (not meeste!); FJ, 19-11-90*)
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=TRUE;
     sonlist:=t1^.sons;
     WHILE result AND (sonlist<>NIL) DO
       BEGIN
       IF sonlist^.node^.cat=Q THEN 
        IF sonlist^.relation=head THEN
         BEGIN
         IF sonlist^.node^.ls^.qfield^.key=KEY_meestQkey THEN result:=FALSE;
         END;
       sonlist:=sonlist^.brother
       END;
     nomeestQunderQp:=result;
     END; !(*nomeestQunderqp*)

FUNCTION defartunderqp(t1:LSSTREE_pstree):BOOLEAN;  
                            !(* This condition is supposed to be 
                              met if the artrel of the QP
                              is a definite article; FJ, 19-12-88. *)
                              (* functie is vervallen; FJ 29-11-90; *)
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;
     WHILE NOT (result) AND (sonlist<>NIL) DO
       BEGIN
       IF sonlist^.node^.cat=ART THEN 
        IF sonlist^.relation=artrel THEN
         BEGIN
         IF sonlist^.node^.ls^.artfield^.definite= def THEN result:= TRUE;
         END;
       sonlist:=sonlist^.brother
       END;
     defARTunderqp:=result;
     END; !(*defartunderqp*)  (* functie is vervallen *)
    
?

<*
 HINIT:BEGIN
         mfMEESTEexpected := false;
         neutMEESTEexpected := false;
         MEESTEfound := false;
         possnietnppar := false;
         definitepar := omegadef;
         posspredpar := true;           !(* for DEMADJ *)
         possnumberspar := [singular];  !(* for DEMADJ *)
         posscomaspar := [count];
         detnpmoodpar := declxpmood;
         syntquantpar := Omegaquant;
         eorenformpar := noform;
         possgenderspar := [omegagender]
       END;

1     :<*
        LOCALCONDITION: true
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            definitepar := indef;
                            possnumberspar := [%NUM.number];
                            possnietnppar := true;
                          END
        *>

2     :<*
        LOCALCONDITION: %DET.eORenForm <> enForm
        GLOBAL: #CONDITION: TRUE
                #ACTION: BEGIN
                         IF ((%DET.eorenForm = Noform) AND 
                             (%DET.eformation <> Noformation)) !(* elk*)
                             THEN possgenderspar := [neutgender] 
                         ELSE IF ((%DET.eorenForm = eform) AND 
                                  (%DET.eformation <> Noformation)) !(* elke*)
                             THEN possgenderspar := [mascgender, femgender] 
                         ELSE possgenderspar := [omegagender];
                            SYNREL := head;
                            possnietnppar := %DET.possnietnp;
                            definitepar := %DET.definite; 
                            posspredpar := %DET.posspred; 
                            possnumberspar := %DET.possnumbers;  
                            posscomaspar := %DET.posscomas; 
                            detnpmoodpar := %DET.mood; !(*???? rene
                            syntquantpar := %DET.syntquant*)
                            eorenformpar := %DET.eorenform;
                          END
        *>

3     :<*
        LOCALCONDITION: TRUE
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            definitepar := def;
                            posscomaspar := [count,mass];
                            IF ((%DEMADJ.key = KEY_dezeDEMADJkey) OR
                                (%DEMADJ.key = KEY_dieDEMADJkey)) THEN
                            BEGIN
                            possnumberspar := [singular,plural];
                            eorenformpar := eForm;
                            possgenderspar := [mascgender, femgender];
                            END
                            ELSE possgenderspar := [neutgender];
                                 !(* rest default:  [singular], Noform *)
                          END
        *>



12    :<*
        LOCALCONDITION: %ART.definite = def
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := artrel;
                            IF %ART.key = KEY_deARTkey
                            THEN mfMEESTEexpected := true
                            ELSE neutMEESTEexpected := true;
                          END
        *>

4     :<*
        LOCALCONDITION: nomeestqunderqp(b)  
        GLOBAL: #CONDITION: (meest2qunderqp(b) <= (mfMEESTEexpected OR 
                                               neutMEESTEexpected))
                #ACTION:  BEGIN
                            SYNREL := head;
                            IF meest2qunderqp(b) THEN
                            BEGIN
                            MEESTEfound := true;
                            eorenformpar := eForm;
                              IF mfMEESTEexpected 
                              THEN 
                              possgenderspar := [mascgender, femgender]
                              ELSE 
                              possgenderspar := [neutgender];
                            END;
                            definitepar := %QP.definite;
                            posspredpar := %QP.posspred;
                            possnumberspar := %QP.possnumbers;
                            posscomaspar := %QP.posscomas;
                            detnpmoodpar := %QP.mood;
                            possnietnppar := true;
                          END
        *>

5     :<*
        LOCALCONDITION: TRUE
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            definitepar := %ART.definite;
                            posspredpar := true;
                            possnumberspar := %ART.possnumbers;
                            posscomaspar := %ART.posscomas;
                            IF %ART.definite = indef
                               THEN possnietnppar := true;

                          !(* assuming: mood is declxpmood (default)*)
                          END
        *>


6     :<*
        LOCALCONDITION: (%DETP.eORenForm <> enForm) 
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := modrel;
                            definitepar := adef;
                            possnietnppar :=  %DETP.possnietnp;
                            posspredpar   :=  %DETP.posspred;
                            detnpmoodpar :=  %DETP.mood;
                            posscomaspar :=  %DETP.posscomas;

                          END
        *>

7     :<*
        LOCALCONDITION: %PREP.key = KEY_vanprepkey
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := partrel
                          END
        *>

8     :<*
        LOCALCONDITION: (%DETP.eORenForm <> enForm) AND
                        (%DETP.definite = def)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            possnumberspar := %DETP.possnumbers;
                          END
        *>
9     :<*
        LOCALCONDITION: (%NP.definite = def)  AND
                        (genitive IN %NP.cases)  AND
                         (%NP.coord <> corrcoord)
                        !(*conditions should be sharpened; probably 
                         reference to the head of the NP is required*)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            possnumberspar := [%NP.number];
                          END
        *>

10     :<*
        LOCALCONDITION: (%POSSADJ.eORenForm <> enForm) AND
                        (%POSSADJ.geni = false)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            possnumberspar := [singular, plural];
                          END
        *>

11: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
                              possnumberspar := %CARD.possnumbers;
                              definitepar := indef;
                            END
       *>

HFINAL: #CONDITION: true
        #ACTION: BEGIN
                 MAKET_DETP;
                 IF (NOT ((mfMEESTEexpected OR neutMEESTEexpected) 
                              AND (NOT MEESTEfound)))
                 THEN 
                 $DETP.possnietnp := possnietnppar;
                 $DETP.definite := definitepar;
                 $DETP.posspred := posspredpar;
                 $DETP.possnumbers := possnumberspar;
                 $DETP.posscomas := posscomaspar;
                 $DETP.mood := detnpmoodpar; 
                 $DETP.syntquant := syntquantpar;
                 $DETP.eorenform := eorenformpar;
                 $DETP.possgenders := possgenderspar;
                 END
*>
END;
&                           



%DETP2rule

REGULAREXPRESSION:

DETP = DET/2 
                                                         
CONDITIONSANDACTIONS:
  VAR  possnietnppar :: possnietnptype;
       definitepar :: deftype;
       posspredpar :: posspredtype;
       possnumberspar :: numberSETtype;
       posscomaspar :: posscomaSETtype;
       detnpmoodpar :: xpmoodtype;
       syntquantpar :: syntquanttype;
       eorenformpar :: eorenformtype;
       possgenderspar :: genderSETtype;

<*
 HINIT:BEGIN
         possnietnppar := false;
         definitepar := omegadef;
         posspredpar := false;           
         possnumberspar := [plural];  
         posscomaspar := [count];
         detnpmoodpar := declxpmood;
         syntquantpar := Omegaquant;
         eorenformpar := enform;
         possgenderspar := [omegagender]
       END;


2     :<*
        LOCALCONDITION: (%DET.eORenForm = enForm) AND
                        (count IN %DET.posscomas) AND
                        (plural IN %DET.possnumbers)
        GLOBAL: #CONDITION: TRUE
                #ACTION: BEGIN
                            SYNREL := head;
                            possnietnppar := %DET.possnietnp;
                            definitepar := %DET.definite; 
                            detnpmoodpar := %DET.mood; 
                            posscomaspar := %DET.posscomas;
                            possnumberspar := %DET.possnumbers;
                            posspredpar := %DET.posspred; 
                           !(*???? rene
                            syntquantpar := %DET.syntquant*)
                          END
        *>

HFINAL: #CONDITION:  true
        #ACTION: BEGIN
                 MAKET_DETP;
                 $DETP.possnietnp := possnietnppar;
                 $DETP.definite := definitepar;
                 $DETP.posspred := posspredpar;
                 $DETP.possnumbers := possnumberspar;
                 $DETP.posscomas := posscomaspar;
                 $DETP.mood := detnpmoodpar; 
                 $DETP.syntquant := syntquantpar;
                 $DETP.eorenform := eorenformpar;
                 $DETP.possgenders := possgenderspar;
                 END
*>
END;
&                           


%CN1rule

REGULAREXPRESSION:

CN = { ADJP/2 | DETP/3 | SENTENCE/4 } . NOUN/5 . [QP/12] . 
       [PREPP/14 | SENTENCE/15] .
       [NP/6]. 
       [PROPERNOUN/13] . {PREPP/8 | ADVP/9} . 
       { SENTENCE/11}
                                                         
CONDITIONSANDACTIONS:

        !(* CNs containing a head/NOUN *)

  VAR  COMPLexpected ::: BOOLEAN;
       classpar :: timeadvclasstype;   
       deixispar :: deixistype;
       aspectpar :: aspecttype;
       retropar :: retrotype;         
       definitepar :: deftype;
       numberspar ::: numberSETtype;
       casespar :: caseSETtype;
       genderspar :: genderSETtype;
       sexespar :: sexSETtype;
       actsubcspar :: nounsubcSETtype;
       temporalpar :: temporaltype;
       possgenipar :: possgenitype;
       animatepar ::: animatetype;
       humanpar :: humantype;
       posscomaspar ::: posscomaSETtype;
       thetanppar ::: thetanptype;
       nounpatternefspar ::: synpatternSETtype;
       prepkeypar ::: keytype;
       tempadjpfound :: BOOLEAN;
       adjpfound :: BOOLEAN;
       sORpostmodfound :: BOOLEAN;

?
HELP 
FUNCTION nodetpundernp(t1:LSSTREE_pstree):BOOLEAN;
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=TRUE;
     sonlist:=t1^.sons;
     WHILE result AND (sonlist<>NIL) DO
       BEGIN
       IF sonlist^.node^.cat=DETP THEN result:=FALSE;
       sonlist:=sonlist^.brother
       END;
     nodetpundernp:=result;
     END;
?

<*
 HINIT:BEGIN
         COMPLexpected := false;
         classpar := omegaTimeAdvClass;   
         deixispar := omegadeixis;         
         aspectpar := omegaAspect;        
         retropar := false;            
         definitepar := omegadef;       
         numberspar := [singular]; 
         casespar := [nominative, accusative, dative];
         genderspar := [omegagender];
         sexespar := [];
         actsubcspar := [othernoun];
         temporalpar := false;
         possgenipar := false;
         animatepar := omegaAnimate;
         humanpar := omegaHuman;
         posscomaspar := [count];
         thetanppar := omegathetanp;
         nounpatternefspar := [];
         prepkeypar := 0;
         tempadjpfound := false;
         adjpfound := false;
         sORpostmodfound := false;

       END;


2     :<*
        LOCALCONDITION: (attributive in %ADJP.actuseefs) !(* restrictions on adjsubc? *)
                        AND
                         (%ADJP.coord <> corrcoord)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := modrel;
                            adjpfound := true;
                            IF (NOT tempadjpfound) AND 
                               (%ADJP.temporal = true ) THEN BEGIN
                              temporalpar := %ADJP.temporal;
                              deixispar := %ADJP.deixis;
                              aspectpar := %ADJP.aspect;
                              retropar := %ADJP.retro;
                              classpar := %ADJP.class;
                            END;
                            IF (NOT tempadjpfound) THEN
                            tempadjpfound := %ADJP.temporal;
                          END
        *>

3     :<*
        LOCALCONDITION: (%DETP.definite = indef) AND
                        (%DETP.eORenForm <> enForm) AND
                        (%DETP.mood = declxpmood)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := modrel;
                            definitepar := def;
                            posscomaspar := %DETP.posscomas
                          END
        *>

4     :<*
        LOCALCONDITION: (%SENTENCE.mood = Anterelative) AND
                        (%SENTENCE.senttype = subordinateclause) AND
                        (%SENTENCE.modus IN [prespart,pastpart,omegamodus]) AND
                        (%SENTENCE.FINITENESS = infinite) AND
                         (%SENTENCE.coord <> corrcoord)
  
                            !(* restrictions on infsort/voicetype/PROsubject? *)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := modrel;
                            sORpostmodfound := true;
                          END
        *>

5     :<*
        LOCALCONDITION: TRUE
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                            IF (NOT tempadjpfound) OR
                               (NOT %NOUN.temporal 
                                (* als ( %NOUN.temporal AND tempadjfound ),
                                   dan gelden de waardes van het tempadj *)
                                (* als ( %NOUN.temporal AND NOT tempadjfound ),
                                   dan gelden de NOUN-waardes *)
                               ) THEN BEGIN
                              classpar := %NOUN.class;
                              deixispar := %NOUN.deixis;
                              aspectpar := %NOUN.aspect;
                              retropar := %NOUN.retro;    
                              temporalpar := %NOUN.temporal;
                            END;
                            numberspar := [%NOUN.number];
                            genderspar := %NOUN.genders;
                            sexespar := %NOUN.sexes;
                            actsubcspar := %NOUN.subcs;
                            possgenipar := %NOUN.possgeni;
                            animatepar := %NOUN.animate;
                            humanpar := %NOUN.human;
                            posscomaspar := %NOUN.posscomas;
                            thetanppar := %NOUN.thetanp;
                            nounpatternefspar := %NOUN.nounpatterns;
                            prepkeypar := %NOUN.prepkey;

                            IF %NOUN.geni THEN casespar := [genitive];
                            IF %NOUN.thetanp <> omegathetanp
                               THEN COMPLexpected := TRUE;
                          END
        *>
12     :<*
        LOCALCONDITION: %QP.hop =true
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := hoprel
                          END
        *>

14    :<*
        LOCALCONDITION: (%PREPP.mood = declxpmood)   AND
                        (NOT %PREPP.stranded) !(*JO*) AND
                         (%PREPP.coord <> corrcoord)
        GLOBAL: #CONDITION: (COMPLexpected) AND
                            (%PREPP.headkey = prepkeypar) AND
                            (nounpatternefspar * [synPREPNP, synPREPNP_THATSENT,
                                                  synPREPNP_QSENT] <> [])

                #ACTION:  BEGIN
                            possgenipar := false;
                            SYNREL := prepobjrel; 
                            sORpostmodfound := true;
                          END
        *>

15     :<*
        LOCALCONDITION: TRUE
                        
        GLOBAL: #CONDITION: (COMPLexpected) AND
                      ((%SENTENCE.conjkey = KEY_datconjkey) AND
                        (%SENTENCE.mood = declarative) AND
                        (synTHATSENT IN nounpatternefspar)) OR
                        ((%SENTENCE.conjkey = KEY_ofconjkey) AND
                        (%SENTENCE.mood = yesnointerrogative) AND
                        (synQSENT IN nounpatternefspar)) OR
                        ((%SENTENCE.mood = whinterrogative) AND
                        (synQSENT IN nounpatternefspar)) AND
                         (%SENTENCE.coord <> corrcoord)

                #ACTION:  BEGIN
                            possgenipar := false;
                            SYNREL := complrel;
                          END
        *>

6     :<*
        LOCALCONDITION: (%NP.definite = indef)   AND
                        ((mass IN %NP.actcomas) OR 
                         (%NP.number = plural)) AND
                        nodetpundernp(b) AND
                         (%NP.coord <> corrcoord)

        GLOBAL: #CONDITION: (count IN posscomaspar) AND
                            (thetanppar = omegathetanp) AND
                            (animatepar = noanimate)
                #ACTION:  BEGIN
                            possgenipar := false;
                            SYNREL := postmodrel;
                            sORpostmodfound := true;

                          END
        *>
13     :<*
        LOCALCONDITION: (%PROPERNOUN.number = singular)   AND
                        (%PROPERNOUN.geni = false)
        GLOBAL: #CONDITION: numberspar = [singular]
                #ACTION:  BEGIN
                            SYNREL := postmodrel;
                            sORpostmodfound := true;
                          END
        *>

8     :<*
        LOCALCONDITION: (%PREPP.mood = declxpmood)   AND
                        (NOT %PREPP.stranded) !(*JO*) AND
                        (( %PREPP.headkey = KEY_vanprepkey) OR
                        (%PREPP.actsubcefs * [loc, dir, temp, 
                                              comitative, voor] <> [])) AND
                         (%PREPP.coord <> corrcoord)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            possgenipar := false;
                            SYNREL := postmodrel;
                            sORpostmodfound := true;

                          END
        *>

9     :<*
        LOCALCONDITION: (%ADVP.mood = declxpmood)   AND
                        (%ADVP.actsubcefs * 
                                 [Locadv, DirAdv, TempAdv,
                                  causadv] <> []) AND
                         (%ADVP.coord <> corrcoord)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            possgenipar := false;
                            SYNREL := postmodrel;
                            sORpostmodfound := true;

                          END
        *>

11     :<*
        LOCALCONDITION: (%SENTENCE.mood = Relative) AND
                         (%SENTENCE.coord <> corrcoord)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            possgenipar := false;
                            SYNREL := postmodrel;
                            sORpostmodfound := true;

                          END
        *>

HFINAL: #CONDITION: TRUE
        #ACTION: BEGIN
                 IF adjpfound THEN
                 actsubcspar := actsubcspar - [plurunitnoun];
                   !(* to block '*drie leuk uur'*)
                 IF sORpostmodfound THEN
                 actsubcspar := actsubcspar - [unitnoun, plurunitnoun];
                   !(* to block '*drie jaar/jaren in Beiroet geleden'*)
                 IF actsubcspar * [unitnoun] = []
                 THEN
                 BEGIN
                 MAKET_CN;
                 $CN.class := classpar;
                 $CN.deixis := deixispar;
                 $CN.aspect := aspectpar;
                 $CN.retro := retropar;    !(* these 4 attributes added 
                                             22-11-88; MJS *)
                 $CN.definite := definitepar;
                 $CN.numbers := numberspar;
                 $CN.genders := genderspar; 
                 $CN.sexes := sexespar;
                 $CN.actsubcs := actsubcspar;
                 $CN.temporal := temporalpar;
                 $CN.possgeni := possgenipar;
                 $CN.animate := animatepar;
                 $CN.human := humanpar;
                 $CN.posscomas := posscomaspar;
                 $CN.thetanp := thetanppar;
                 $CN.nounpatternefs := nounpatternefspar;
                 $CN.cases := casespar;
                 END;


                 IF ((actsubcspar * [unitnoun] <> []) AND 
                     (numberspar = [singular]) !(*example: uur; FJ*)
                    )
                 THEN 
                 BEGIN
                 MAKET_CN;
                 $CN.class := classpar;
                 $CN.deixis := deixispar;
                 $CN.aspect := aspectpar;
                 $CN.retro := retropar;    !(* these 4 attributes added 
                                             22-11-88; MJS *)
                 $CN.definite := definitepar;
                 $CN.numbers := [singular];
                 $CN.genders := genderspar; 
                 $CN.sexes := sexespar;
                 $CN.actsubcs := actsubcspar;
                 $CN.temporal := temporalpar;
                 $CN.possgeni := possgenipar;
                 $CN.animate := animatepar;
                 $CN.human := humanpar;
                 $CN.posscomas := posscomaspar;
                 $CN.thetanp := thetanppar;
                 $CN.nounpatternefs := nounpatternefspar;
                 $CN.cases := casespar;
                 END;
                

                 IF actsubcspar * [unitnoun] <> [] !(*zowel uren als uur;
                                                    uur komt dus 2 x door 
                                                    S-parser; FJ*)
                 THEN 
                 BEGIN
                 MAKET_CN;
                 $CN.class := classpar;
                 $CN.deixis := deixispar;
                 $CN.aspect := aspectpar;
                 $CN.retro := retropar;    !(* these 4 attributes added 
                                             22-11-88; MJS *)
                 $CN.definite := definitepar;
                 $CN.numbers := [plural];
                 $CN.genders := genderspar; 
                 $CN.sexes := sexespar;
                 $CN.actsubcs := actsubcspar;
                 $CN.temporal := temporalpar;
                 $CN.possgeni := possgenipar;
                 $CN.animate := animatepar;
                 $CN.human := humanpar;
                 $CN.posscomas := posscomaspar;
                 $CN.thetanp := thetanppar;
                 $CN.nounpatternefs := nounpatternefspar;
                 $CN.cases := casespar;
                 END;
               END                

*>
END;
&


%CN2rule

REGULAREXPRESSION:

CN = { DETP/1 | ADJP/2 | SENTENCE/3 } . { PREPP/4  } . { SENTENCE/6 }

CONDITIONSANDACTIONS:

        !(* CNs not containing a head/NOUN.
           The following ambiguity occurs:
           - DETP: always count/plural (assuming 'n' is treated separately) 
           - ADJP:  - count/plural     (surfcn2.sur (also for NUM))
                    - count/singular   (surfcn3.sur)
                    - mass/singular    (surfcn4.sur)                   
          
           In order to avoid this ambiguity at this point it has been decided
           to make the attribute 'number' of CN a set: 'numbers'    
           NB. Note that one combination, mass/plural, will be blocked later *)

  VAR  
          definitepar  :: deftype;
          premodfound  :: BOOLEAN;  
          postmodfound :: BOOLEAN;  
          posscomaspar :: posscomaSETtype;

<*
 HINIT:BEGIN
         definitepar  := omegadef;  
         premodfound  := false;     
         postmodfound := false;     
         posscomaspar := [count];
       END;

1     :<*
        LOCALCONDITION: (%DETP.definite = indef) AND
                        (%DETP.eORenForm <> enForm) AND
                        (%DETP.mood = declxpmood)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := modrel;
                            definitepar := def;
                            posscomaspar := %DETP.posscomas;
                            premodfound := true;     
                          END
        *>

2     :<*
        LOCALCONDITION: (attributive in %ADJP.actuseefs) AND
                        (%ADJP.eorenform in [eform, enform])
        !(* restrictions on adjsubc? *)                        AND
                         (%ADJP.coord <> corrcoord)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := modrel;
                            premodfound := true;   

                          END
        *>
      

3     :<*
        LOCALCONDITION: (%SENTENCE.mood = Anterelative) AND
                        (%SENTENCE.senttype = subordinateclause) AND
                        ((%SENTENCE.modus = prespart) OR
                         (%SENTENCE.modus = pastpart)) AND
                         (%SENTENCE.FINITENESS <> infinite) AND
                         (%SENTENCE.coord <> corrcoord)
  
                            !(* restrictions on infsort/voicetype/PROsubject? *)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := modrel;
                            premodfound := true;
                          END
        *>

4     :<*
        LOCALCONDITION: (%PREPP.mood = declxpmood)    AND
                        (NOT %PREPP.stranded) AND
                         (%PREPP.coord <> corrcoord) AND
                        ((%PREPP.headkey = KEY_vanprepkey) AND
                         (%PREPP.actsubcefs * [loc, dir, temp, comitative] <> [])
                        )  
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := postmodrel;
                            postmodfound := true;
                          END
        *>

6     :<*
        LOCALCONDITION:  (%SENTENCE.mood = Relative) AND
                         (%SENTENCE.coord <> corrcoord)
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := postmodrel;
                            postmodfound := true;
                          END
        *>

HFINAL: #CONDITION: premodfound OR
                    postmodfound
        #ACTION: BEGIN
                 IF NOT premodfound
                    THEN definitepar := omegadef; !(*of indef ?? FJ 14-11-89*)
                 MAKET_CN;
                 $CN.numbers := [singular,plural];
                 $CN.posscomas := [count,mass];
                 $CN.definite := definitepar;
                 $CN.cases :=  [nominative, accusative, dative]

                 !(* cases is default ?  NO, JO*)
                 END
*>
END;
&




%PREPP
REGULAREXPRESSION:

PREPP = [MOD] . [RADVP/3 . [GLUE/4]] .[PREP/1] . [PPCOMPLS] 
        . [PREP/8 | PART/9 |PREPP/13]

MOD = ADVP/10 | NP/11

PPCOMPLS = NP/2 | PREPP/5 | ADJP/6 | ADVP/7 | REFLPRO/12

CONDITIONSANDACTIONS:

VAR
    reqvar         :: polarityEFFSETtype;
    envvar         :: polarityEFFSETtype;
    moodvar        :: xpmoodtype;
    actsubcefsvar  :: prepsubceffsettype;
    synppefsvar    :: synpatterneffsettype;
    headkeyvar     :: keytype;
    classvar       :: timeadvclasstype;
    deixisvar      :: deixistype;
    aspectvar      :: aspecttype;
    retrovar       :: retrotype;
    thetappvar     :: thetapptype;    
    radvkeyvar     :: keytype;
    radvpfound     ::: BOOLEAN;
    NPfound        :: BOOLEAN;
    ADVPfound        :: BOOLEAN;
    ADJPfound        :: BOOLEAN;
    PPfound        :: BOOLEAN;
    complfound     ::: BOOLEAN;
    postformvar    :: postformtype;
    gluefound      :: BOOLEAN;
    headfound      ::: BOOLEAN;
    postpkeyvar    ::: indextype;
    postpfound     :: BOOLEAN;
    specqvar       :: specqtype;
    strandedvar    :: BOOLEAN;
    tempcompl      :: BOOLEAN;
    secondprepvar  ::: keytype;
    secondprepfound:: BOOLEAN;



<* 
HINIT: BEGIN
	 reqvar         := [pospol, negpol, omegapol];
         envvar         := [pospol, negpol, omegapol];
	 moodvar        := declxpmood;
	 actsubcefsvar  := [];
	 synppefsvar    := [];
	 headkeyvar     := 0;
	 classvar       := omegaTimeAdvClass;
	 deixisvar      := omegadeixis;
	 aspectvar      := omegaAspect;
	 retrovar       := false;
         thetappvar     := omegathetapp;    
         radvkeyvar     := 0;
         radvpfound     := false;
         NPfound        := false;
         PPfound        := false;
         ADVPfound      := false;
         ADJPfound      := false;
         complfound     := false;
         postformvar    := both;
         gluefound      := false;
         headfound      := false;
         postpkeyvar    := 0;
         postpfound     := false;
         specqvar       := nospec;
         strandedvar    := false;
         tempcompl      := false;
         secondprepvar  := 0;
         secondprepfound:= false;
       END;
  

1: 
       <*
         LOCALCONDITION: (%PREP.preptype IN [normalprep, splitprep])
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
                              headfound := true;
                              actsubcefsvar := %PREP.subcs;
                              synppefsvar   := %PREP.synpps;
                              headkeyvar    := %PREP.key;
                              classvar      := %PREP.class;
                              deixisvar     := %PREP.deixis;
                              aspectvar     := %PREP.aspect;
                              retrovar      := %PREP.retro;
                              thetappvar    := %PREP.thetapp;
                              postformvar   := %PREP.postform;
                              postpkeyvar   := %PREP.postpkey;
                              secondprepvar := %PREP.secondprep;
                            END
       *>

2: 
       <*
         LOCALCONDITION: (%NP.cases * [accusative] <> [])  AND
                         (%NP.NPhead <> hetNP)             AND
                         (%NP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT radvpfound)   AND
                             (NOT complfound)
                 #ACTION:   BEGIN
                              SYNREL     := objrel;
                              moodvar    := %NP.mood;
                              NPfound    := true;
                              complfound := true;
                              specqvar   := %NP.specq;
                              tempcompl  := %NP.temporal;
                            END
       *>



3: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL     := errel;
                              radvpfound := true;
                              radvkeyvar := %RADVP.radvkey;
                              moodvar    := %RADVP.mood;
                              specqvar   := yesspec;
                            END
       *>

4: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := gluerel;
                              gluefound := true;
                            END
       *>




5: 
       <*
         LOCALCONDITION: (%PREPP.actsubcefs * [loc, temp] <> []) AND
                         (%PREPP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT complfound)  AND
                             (NOT radvpfound)
                 #ACTION:   BEGIN
                              SYNREL := objrel;
                              complfound := true;
                              ppfound := true;
                              specqvar := yesspec;
                              tempcompl := (temp IN %PREPP.actsubcefs)
                            END
       *>

6: 
       <*
         LOCALCONDITION: (%ADJP.eORenform = Noform) AND
                         (predicative IN %ADJP.actuseefs) AND
                         (%ADJP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT complfound)  AND
                             (NOT radvpfound)
                 #ACTION:   BEGIN
                              SYNREL := predrel;
                              complfound := true;
                              adjpfound  := true;
                              specqvar := yesspec;
                            END
       *>

7: 
       <*
         LOCALCONDITION: (%ADVP.actsubcefs * [locadv, tempadv] <> []) AND
                         (%ADVP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT complfound)  AND
                             (NOT radvpfound)
                 #ACTION:   BEGIN
                              SYNREL := objrel;
                              complfound := true;
                              advpfound  := true;
                              specqvar := yesspec;
                              tempcompl := (tempadv IN %ADVP.actsubcefs)
                            END
       *>


8: 
       <*
         LOCALCONDITION: (%PREP.preptype = postprep)
         GLOBAL: #CONDITION: (NOT headfound)
                 #ACTION:   BEGIN
                              SYNREL := head;
                              headfound := true;
                              actsubcefsvar := %PREP.subcs;
                              synppefsvar   := %PREP.synpps;
                              headkeyvar    := %PREP.key;
                              classvar      := %PREP.class;
                              deixisvar     := %PREP.deixis;
                              aspectvar     := %PREP.aspect;
                              retrovar      := %PREP.retro;
                              thetappvar    := %PREP.thetapp;
                              postformvar   := %PREP.postform;
                              postpkeyvar   := %PREP.postpkey;
                            END
       *>

9: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (%PART.key = postpkeyvar) 
                 #ACTION:   BEGIN
                              SYNREL := partrel;
                              postpfound := true;
                            END
       *>


10: 
       <*
         LOCALCONDITION: ( preppadv IN %ADVP.actsubcefs) AND
                         (%ADVP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := modrel;
                            END
       *>


11: 
       <*
         LOCALCONDITION: (%NP.NPhead = otherNP) AND 
                         (%NP.coord <> corrcoord) AND
                         ((unitnoun IN %NP.actsubcs) OR 
                          (plurunitnoun IN %NP.actsubcs)
                          )  !(* probably too strong *)  
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := modrel;
                            END
       *>


12: 
       <*
         LOCALCONDITION: %REFLPRO.zelf = false
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := objrel;
                              complfound := true;
                              npfound    := true;
                              specqvar   := yesspec;
                            END
       *>

13: 
       <*
         LOCALCONDITION: (%PREPP.headkey <> 0)  AND
                         (%PREPP.coord <> corrcoord) 
         GLOBAL: #CONDITION: (%PREPP.headkey = secondprepvar) 
                 #ACTION:   BEGIN
                              SYNREL := modrel;
                              secondprepfound := true;
                            END
       *>



HFINAL: #CONDITION: headfound                                           AND
                    ((postformvar = post) <= (NOT complfound))          AND
                    ((postformvar = pre ) <= (NOT radvpfound))          AND
                    ((secondprepvar <> 0) <= secondprepfound)           AND 
                    ((postpkeyvar = 0 ) OR
                     postpfound             )                           AND
                     

                    ( (NOT ( radvpfound                         AND
                             ((radvkeyvar = KEY_erRadvkey)   OR
                              (radvkeyvar = KEY_daarradvkey) OR
                              (radvkeyvar = KEY_hierradvkey)
                             )
                           )                                    
                      )                                             OR
                      gluefound
                    )                                               AND
                    ((actsubcefsvar <> [temp]) OR 
                     (tempcompl OR radvpfound)
                    )                                       
        #ACTION: BEGIN
                    IF    npfound 
                    THEN  synppefsvar := synppefsvar * [synNP];
                    IF    adjpfound
                    THEN  synppefsvar := synppefsvar * 
                             [synOPENADJPPROP, synCLOSEDADJPPROP];
                    IF    advpfound 
                    THEN  synppefsvar := synppefsvar * [synLOCPREPP];
                    IF    ppfound
                    THEN  synppefsvar := synppefsvar * [synLOCPREPP];
                    IF    radvpfound 
                    THEN  synppefsvar := synppefsvar * [synNP,synLOCPREPP];
                    IF (NOT complfound) AND (NOT radvpfound) AND 
                       (postformvar = pre)
                    THEN synppefsvar := synppefsvar * [synnovpargs];
                    IF (NOT complfound) AND (NOT radvpfound) AND 
                       (postformvar = post)
                    THEN synppefsvar := synppefsvar * [synNP, synLOCPREPP];
       
                    IF ( (NOT complfound)              AND
                         (NOT radvpfound)              AND
                         (synppefsvar * [synNP] <> []) AND
                         (postformvar <> pre)
                       )
                    THEN strandedvar := true;

                    IF   (synppefsvar <> []) AND (strandedvar)
                    THEN BEGIN
			  MAKET_PREPP;
			  $PREPP.req         := reqvar;
			  $PREPP.env         := envvar;
			  $PREPP.actsubcefs  := actsubcefsvar;
			  $PREPP.mood        := moodvar;
			  $PREPP.synppefs    := synppefsvar;
			  $PREPP.headkey     := headkeyvar;
			  $PREPP.class       := classvar;
			  $PREPP.deixis      := deixisvar;
			  $PREPP.aspect      := aspectvar;
			  $PREPP.retro       := retrovar;
			  $PREPP.superdeixis := omegadeixis;
			  $PREPP.thetapp     := thetappvar;
			  $PREPP.radvkey     := radvkeyvar;
			  $PREPP.stranded    := strandedvar;
                          $PREPP.specq       := specqvar;
                    END !(**); 

                    IF (
                        ( (complfound) OR
                          (radvpfound) OR
                          (synppefsvar * [synnovpargs] <> [])
                        )                                      AND
                        (postformvar <> post)
                       )
                    THEN strandedvar := false;


                    IF   (synppefsvar <> []) AND (NOT strandedvar)
                    THEN BEGIN
			  MAKET_PREPP;
			  $PREPP.req         := reqvar;
			  $PREPP.env         := envvar;
			  $PREPP.actsubcefs  := actsubcefsvar;
			  $PREPP.mood        := moodvar;
			  $PREPP.synppefs    := synppefsvar;
			  $PREPP.headkey     := headkeyvar;
			  $PREPP.class       := classvar;
			  $PREPP.deixis      := deixisvar;
			  $PREPP.aspect      := aspectvar;
			  $PREPP.retro       := retrovar;
			  $PREPP.superdeixis := omegadeixis;
			  $PREPP.thetapp     := thetappvar;
			  $PREPP.radvkey     := radvkeyvar;
			  $PREPP.stranded    := strandedvar;
                          $PREPP.specq       := specqvar;
                    END !(**); 
                 END
*>
END  !(*PREPP*);
& 



%RADVP
REGULAREXPRESSION:
 
RADVP = RADV/1

CONDITIONSANDACTIONS:

VAR
     radvkeyvar     :: keytype;
     moodvar        :: xpmoodtype;
     reqvar         :: polarityEFFSETtype;
     envvar         :: polarityEFFSETtype;
 

<* 
HINIT: BEGIN
          reqvar     := [ pospol, negpol, omegapol];
          envvar     := [ pospol, negpol, omegapol];
          radvkeyvar := 0;
          moodvar    := declxpmood;
       END;
 

1: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL     := head;
                              radvkeyvar := %RADV.key;
                              moodvar    := %RADV.mood;
                            END
       *>


HFINAL: #CONDITION: true
        #ACTION: BEGIN
                   MAKET_RADVP;
                   $RADVP.radvkey := radvkeyvar;
                   $RADVP.mood    := moodvar;
                   $RADVP.req      := reqvar;
                   $RADVP.env      := envvar;
                   IF   radvkeyvar = KEY_erRADVkey
                   THEN $RADVP.kindefs := [ Xk, Lk, Qk, Pk, XLk, XQk, 
                                            XPk, LQk, QPk, XLQk, XPQk
                                          ]
                   ELSE $RADVP.kindefs := [ Lk, Pk, XLk, XPk];
                 END
 
*>
END;
& 


%ADVP
REGULAREXPRESSION:

ADVP = [ NP/4 | NP/44 | QP/5 | ADVP/6] . ADV/1 . 
                    [THANP/7 | ADJP/8] . [ NP/2 | ADVP/3 ]
 
CONDITIONSANDACTIONS:

VAR
      reqvar                   :: polarityEFFSETtype;
      envvar                   :: polarityEFFSETtype;
      classvar                 :: timeadvclasstype;
      deixisvar                :: deixistype;
      aspectvar                :: aspecttype;
      retrovar                 :: retrotype;
      superdeixisvar           :: deixistype;
      actsubcefsvar            :: advsubceffsettype;
      Qstatusvar               :: qstatustype;
      moodvar                  :: xpmoodtype;
      superlativesvar          :: superlativesettype;
      thetaadvvar              :: thetaadvtype;
      advpatternefsvar         :: synpatterneffsettype;
      temporalvar              :: temporaltype;
      possnietnpvar            :: possnietnptype;
      thanasvar                :: thanascompltype;
      headfound                :: BOOLEAN;
      precomplfound            ::: BOOLEAN;
      postcomplfound           ::: BOOLEAN;        
      THANPpossible            ::: BOOLEAN; 
                             !(* bedoeld om optreden van THANP te beregelen *)   
      ALSCOMPLADVfound         ::: BOOLEAN;
                             !(* om bij te houden of 'zo' als degreeadv 
                                gevonden is; example: zo spoedig mogelijk
                             *)
      DEGREEADVexpected           ::: BOOLEAN;
      DEGREEADVfound           ::: BOOLEAN;
      DEGREEMODfound           ::: BOOLEAN;
? 
HELP 
FUNCTION mogelijkkey(b:LSSTREE_pstree):BOOLEAN;
VAR stree:LSSTREE_pstree;
BEGIN
IF (b^.sons^.relation =head) THEN BEGIN
  stree:=b^.sons^.node;
  IF (stree^.sons^.relation=head) THEN BEGIN 
    stree:=stree^.sons^.node;
    IF (stree^.sons^.relation=head) THEN BEGIN
      stree:=stree^.sons^.node;
      IF stree^.ls^.BADJfield^.key=KEY_s_mogelijkbadj THEN
      mogelijkkey:=TRUE ELSE mogelijkkey:=FALSE
      END;
    END;
  END;
END;
?

<* 
HINIT: BEGIN
	 reqvar                   := [pospol, negpol, omegapol];
	 envvar                   := [pospol, negpol, omegapol];
	 classvar                 := omegatimeadvclass;
	 deixisvar                := omegadeixis;
	 aspectvar                := omegaaspect;
	 retrovar                 := false;
	 superdeixisvar           := omegadeixis;
	 actsubcefsvar            := [];
	 Qstatusvar               := false;
	 moodvar                  := declxpmood;
	 superlativesvar          := [];
	 thetaadvvar              := omegathetaadv;
	 advpatternefsvar         := [];
	 temporalvar              := false;
	 possnietnpvar            := false;
	 thanasvar                := omegacompl;
         headfound                := false;
         precomplfound            := false;
         postcomplfound           := false;
         THANPpossible            := false;
         ALSCOMPLADVfound         := false;
         DEGREEADVfound           := false;
         DEGREEADVexpected        := false;
         DEGREEMODfound           := false;
       END;

 

1: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
                              IF degreeadv IN %ADV.subcs
                                 THEN DEGREEADVfound := true;
                              IF %ADV.form = comparative 
                                 THEN DEGREEMODfound := true;
                              IF %ADV.form = comparative
                                 THEN THANPpossible := true;
                              headfound := true;
			      classvar         := %ADV.class;
			      deixisvar        := %ADV.deixis;
			      aspectvar        := %ADV.aspect;
			      retrovar         := %ADV.retro;
			      actsubcefsvar    := %ADV.subcs;
			      Qstatusvar       := %ADV.Qstatus;
			      moodvar          := %ADV.mood;
			      superlativesvar  := %ADV.superlatives;
			      thetaadvvar      := %ADV.thetaadv;
			      advpatternefsvar := %ADV.advpatterns;
			      temporalvar      := %ADV.temporal;
			      possnietnpvar    := %ADV.possnietnp;
			      thanasvar        := %ADV.thanas;
                            END
       *>

2: 
       <*
         LOCALCONDITION:    (%NP.temporal = true)       !(* al DRIE UUR*) 
                         AND
                            (%NP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT precomplfound) AND
                             (NOT postcomplfound)
                 #ACTION:  BEGIN
                              SYNREL := modrel;
                              postcomplfound := true;
                           END
       *>

3: 
       <*
         LOCALCONDITION: (%ADVP.temporal = true) AND
                         (synMEASUREPHRASE IN %ADVP.advpatternefs) AND
                         (%ADVP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT precomplfound) AND
                             (NOT postcomplfound)
                 #ACTION:  BEGIN
                              SYNREL := modrel;
                              postcomplfound := true;
                           END
       *>


4: 
       <*
         LOCALCONDITION:   (%NP.temporal = true)      !(* DRIE UUR lang *)
                         AND
                           (%NP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT precomplfound) AND
                             (NOT postcomplfound)
                 #ACTION:  BEGIN
                              SYNREL := modrel;
                              precomplfound := true;
                           END
       *>


44: 
       <*
         LOCALCONDITION: (unitnoun IN %NP.actsubcs) OR
                         ((%NP.definite = indef) AND
                          (mass IN %NP.actcomas ) 
                         ) (* amountnp *) AND 
                         (%NP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT DEGREEMODfound) 
                 #ACTION:   BEGIN
                              SYNREL := premodrel;
                              degreeadvexpected := true;
                              DEGREEmodfound := true;
                            END
       *>



5: 
       <*
         LOCALCONDITION: %QP.hop = false
         GLOBAL: #CONDITION: NOT DEGREEMODfound
                 #ACTION:  BEGIN
                              SYNREL := degreemodrel;
                              moodvar := %QP.mood;
                              IF %QP.thanas <> omegacompl
                              THEN THANPpossible := true;
                              DEGREEmodfound := true;
                           END
       *>

6: 
       <*
         LOCALCONDITION: (degreeadv IN %ADVP.actsubcefs)  AND
                         (%ADVP.coord <> corrcoord)
         GLOBAL: #CONDITION: NOT DEGREEMODfound
                 #ACTION:  BEGIN
                              SYNREL := degreemodrel;
                              If %ADVP.thanas = alscompl
                              THEN ALSCOMPLADVfound := true;
                              If %ADVP.thanas = alscompl
                              THEN THANPpossible := true;
                              moodvar := %ADVP.mood;
                              DEGREEmodfound := true;
                           END
       *>

7: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: THANPpossible
                 #ACTION:   BEGIN
                              SYNREL := postmodrel; 
                            END
       *>


8: 
       <*
         LOCALCONDITION: mogelijkkey(b)
         GLOBAL: #CONDITION: alscompladvfound AND
                             (NOT precomplfound) AND
                             (NOT postcomplfound)
                 #ACTION:   BEGIN
                              SYNREL := zocomplrel;
                            END
       *>


9:    <*
         LOCALCONDITION: %QP.hop = true
         GLOBAL: #CONDITION: (NOT DEGREEMODfound) AND
                             (NOT precomplfound) AND
                             (NOT postcomplfound)
                 #ACTION:   BEGIN
                              SYNREL := hoprel;
                              DEGREEMODfound := true;
                            END
       *>


HFINAL: #CONDITION: headfound AND
                    (actsubcefsvar * [tempadv] <> []) OR
                    ((NOT precomplfound) AND
                     (NOT postcomplfound)
                    )
        #ACTION: BEGIN
                     !(*check of aanwezige complementen compatibel zijn met ADV*)
                     IF precomplfound
                     THEN advpatternefsvar := 
                                         advpatternefsvar * [synMEASUREPHRASE];

                     IF postcomplfound
                     THEN advpatternefsvar := advpatternefsvar * [synNP];

                     !(*check of verwachte complementen inderdaad aanwezig zijn*)
                     IF ((advpatternefsvar <= [synMEASUREPHRASE]) AND 
                         (NOT precomplfound)
                        )
                     THEN advpatternefsvar := [];

                     IF ((advpatternefsvar <= [synNP]) AND
                         (NOT postcomplfound)
                        )
                     THEN advpatternefsvar := [];
                        
                  
                     IF ((advpatternefsvar <> []) AND
                         (degreeadvexpected <= degreeadvfound)
                        )
                     THEN BEGIN
                     MAKET_ADVP;
		     $ADVP.req           := reqvar;
		     $ADVP.env           := envvar;
		     $ADVP.class         := classvar;
		     $ADVP.deixis        := deixisvar;
		     $ADVP.aspect        := aspectvar;
		     $ADVP.retro         := retrovar;
		     $ADVP.superdeixis   := superdeixisvar;
		     $ADVP.actsubcefs    := actsubcefsvar;
		     $ADVP.Qstatus       := Qstatusvar;
		     $ADVP.mood          := moodvar;
		     $ADVP.thetaadv      := thetaadvvar;
		     $ADVP.advpatternefs := advpatternefsvar;
		     $ADVP.temporal      := temporalvar;
		     $ADVP.Radvb         := false;
		     $ADVP.possnietnp    := possnietnpvar;
		     $ADVP.thanas        := thanasvar;
                     $ADVP.thanascompl   := false;
                     END
                 END
 
*>
END;
& 
%%

%DUTCH
&

%DatumNP
REGULAREXPRESSION:

NP = ([[NP/8] . DETP/1] . PROPERNOUN/2 . [NP/3])  |
     ([CARD/4 . PUNC/5]. CARD/6 . [PUNC/5 . NP/7] )

CONDITIONSANDACTIONS:

VAR  
    reqvar              :: polarityEFFSETtype;
    envvar              :: polarityEFFSETtype;
    superdeixisvar      :: deixistype;
    classvar            :: timeadvclasstype;
    deixisvar           :: deixistype;
    aspectvar           :: aspecttype;
    retrovar            :: retrotype;
    definitevar         :: deftype;
    personvar           :: persontype;
    numbervar           :: numbertype;
    casesvar            :: caseSETtype;
    gendersvar          :: genderSETtype;
    sexesvar            :: sexSETtype;
    actsubcsvar         :: nounsubcEFFSETtype;
    temporalvar         :: temporaltype;
    possgenivar         :: possgenitype;
    animatevar          :: animatetype;
    humanvar            :: humantype;
    actcomasvar         :: posscomaSETtype;
    thetanpvar          :: thetanptype;
    nounpatternefsvar   :: synpatternEFFSETtype;
    posspredvar         :: posspredtype;
    possnietnpvar       :: possnietnptype;
    moodvar             :: xpmoodtype;
    genericvar          :: generictype;
    possRformvar        :: possRformtype;
    syntquantvar        :: syntquanttype;
    NPheadvar           :: NPheadtype;
    specQvar            :: specQtype;
    coordvar            :: coordtype;
    yearnumberfound     :: BOOLEAN;
    daynumberfound      :: BOOLEAN;
    numberheadfound     :: BOOLEAN;
?
HELP

FUNCTION CardunderDetP(t1:LSSTREE_pstree):BOOLEAN;  
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
BEGIN
  result:=FALSE;
  sonlist:=t1^.sons;
  WHILE NOT (result) AND (sonlist<>NIL) DO
    BEGIN
      result :=  sonlist^.node^.cat=CARD;
      sonlist:=sonlist^.brother
    END;
  CARDunderDETP:=result;
END; !(*CARDunderDETP*)
?


<* 

HINIT: BEGIN
    reqvar              := [pospol, omegapol, negpol];
    envvar              := [pospol, omegapol, negpol];
    superdeixisvar      := omegadeixis;
    classvar            := omegatimeadvclass;
    deixisvar           := omegadeixis;
    aspectvar           := omegaaspect;
    retrovar            := false;
    definitevar         := omegadef;
    personvar           := 3;
    numbervar           := omeganumber;
    casesvar            := [];
    gendersvar          := [omegagender];
    sexesvar            := [];
    actsubcsvar         := [othernoun];
    temporalvar         := false;
    possgenivar         := false;
    animatevar          := omegaanimate;
    humanvar            := omegahuman;
    actcomasvar         := [];
    thetanpvar          := omegathetanp;
    nounpatternefsvar   := [];
    posspredvar         := false;
    possnietnpvar       := false;
    moodvar             := declxpmood;
    genericvar          := omegageneric;
    possRformvar        := false;
    syntquantvar        := omegaquant;
    NPheadvar           := otherNP;
    specQvar            := omegaspec;
    coordvar            := nocoord;
    yearnumberfound     := false;
    daynumberfound      := false;
    numberheadfound     := false;

       END;
 

1: 
       <*
         LOCALCONDITION: CARDunderDETP(b)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := detrel;
                            END
       *>

2: 
       <*
         LOCALCONDITION: (%PROPERNOUN.subc = monthnoun)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL     := head;
                              classvar   := %PROPERNOUN.class;
                              deixisvar  := %PROPERNOUN.deixis;
                              aspectvar  := %PROPERNOUN.aspect;
                              retrovar   := %PROPERNOUN.retro;
                              gendersvar := %PROPERNOUN.genders;
                              actsubcsvar := [%PROPERNOUN.subc];
                              temporalvar := %PROPERNOUN.temporal;
                              possgenivar := %PROPERNOUN.possgeni;
                              animatevar  := %PROPERNOUN.animate;
                              humanvar    := %PROPERNOUN.human;
                              actcomasvar := [count];
                              posspredvar := true;
                            END
       *>

3: 
       <*
         LOCALCONDITION: (%NP.NPhead = cardNP)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := postmodrel;
                            END
       *>

4: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := modrel;
                              daynumberfound := true;
                            END
       *>

5: 
       <*
         LOCALCONDITION:(%PUNC.key = KEY_forwslashPUNCkey)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := puncrel;
 
                            END
       *>

6: 
       <*
         LOCALCONDITION:true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
                              numberheadfound := true;
                              temporalvar := true;
                              classvar    := reference;
                              aspectvar   := perfective
                            END
       *>

7: 
       <*
         LOCALCONDITION: (%NP.NPhead = cardNP)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := postmodrel;
                              yearnumberfound := true;
                            END
       *>

8: 
       <*
         LOCALCONDITION: daynoun IN %NP.actsubcs
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := modrel;
                            END
       *>
HFINAL: #CONDITION: (numberheadfound <= (daynumberfound OR yearnumberfound))
        #ACTION: BEGIN
                    MAKET_NP;
                    $NP.req            := reqvar;
                    $NP.env            := envvar;
                    $NP.superdeixis    := superdeixisvar;
                    $NP.class          := classvar;
                    $NP.deixis         := deixisvar;
                    $NP.aspect         := aspectvar;
                    $NP.retro          := retrovar;
                    $NP.definite       := def;
                    $NP.person         := 3;
                    $NP.number         := singular;
                    $NP.cases          := [nominative, accusative, dative];
                    $NP.genders        := gendersvar;
                    $NP.sexes          := sexesvar;
                    $NP.actsubcs       := actsubcsvar;
                    $NP.temporal       := temporalvar;
                    $NP.possgeni       := possgenivar;
                    $NP.animate        := animatevar;
                    $NP.human          := humanvar;
                    $NP.actcomas       := actcomasvar;
                    $NP.thetanp        := thetanpvar;
                    $NP.nounpatternefs := nounpatternefsvar;
                    $NP.posspred       := posspredvar;
                    $NP.possnietnp     := possnietnpvar;
                    $NP.mood           := moodvar;
                    $NP.generic        := genericvar;
                    $NP.possRform      := possRformvar;
                    $NP.syntquant      := syntquantvar;
                    $NP.NPhead         := otherNP;
                    $NP.specQ          := yesspec;
                    $NP.coord          := nocoord;
                  END
*>
END;
& 







%NPcardrule

REGULAREXPRESSION:

NP = CARD/1
                                                         

CONDITIONSANDACTIONS:
  VAR  
       retropar   :: retrotype;  !(*can it be left out, syntactically??*)




<*
 HINIT:BEGIN
         retropar := false;
      END;

1     :<*
        LOCALCONDITION: TRUE
        GLOBAL: #CONDITION: TRUE
                #ACTION:  BEGIN
                            SYNREL := head;
                          END
        *>


HFINAL: #CONDITION: TRUE
        #ACTION: BEGIN
                   MAKET_NP;
                   $NP.definite := def;
                   $NP.cases    := [nominative, accusative, dative];
                   $NP.temporal := true;
                   $NP.animate  := noanimate;
                   $NP.human    := nohuman;
                   $NP.posspred := true;
                   $NP.generic  := omegageneric;
                   $NP.NPhead   := cardNP;
                   $NP.specQ    := yesspec;
                   $NP.class    := reference;
                   $NP.aspect   := perfective;
                   END;
*>
END;
&                           




%ADJP1srule

REGULAREXPRESSION:
 
ADJP = ADVP/1 . ADJP/2

CONDITIONSANDACTIONS:


VAR  preADVfound ::: BOOLEAN;
     reqvar :: polarityEFFSETtype;
     envvar :: polarityEFFSETtype;
     classvar :: timeadvclasstype;
     deixisvar :: deixistype;
     aspectvar :: aspecttype;
     retrovar :: retrotype;
     actuseefsvar :: adjuseEFFSETtype;
     eformationvar :: eformationtype;
     enominalisedvar :: enominalisedtype;
     formvar :: adjadvformtype;
     eORenFormvar :: eorenformtype;
     temporalvar :: temporaltype;
     actsubcefsvar :: adjsubceffsettype;
     thetaadjvar :: thetaadjtype;
     adjpatternefsvar :: synpatterneffsettype;
     reflexivityvar :: reflexivetype;
     moodvar :: xpmoodtype;
 

<*
 
HINIT: BEGIN
         preADVfound := false;
         reqvar := [omegapol, pospol, negpol];
         envvar := [omegapol, pospol, negpol];
         classvar := omegaTimeAdvClass;
         deixisvar := omegadeixis;
         aspectvar := omegaAspect;
         retrovar := false;
         actuseefsvar := [];
         eformationvar := RegEformation;
         enominalisedvar := regeNominalised;
         formvar := positive;
         eORenFormvar := eform;
         temporalvar := false;
         actsubcefsvar := [otheradj];
         thetaadjvar := omegathetaadjp;
         adjpatternefsvar := [];
         reflexivityvar := notreflexive;
         moodvar := declxpmood;

       END;

1: 
       <*
         LOCALCONDITION: (preXPAdv in %ADVP.actsubcefs)  AND
                         (%ADVP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := modrel;
                              preADVfound := true
                   
                            END
       *>

2: 
       <*
         LOCALCONDITION: (%ADJP.coord <> corrcoord)
         GLOBAL: #CONDITION: preADVfound = true

                 #ACTION:   BEGIN
                              SYNREL := head;
			      reqvar := %ADJP.req;
			      envvar := %ADJP.env;
			      classvar := %ADJP.class;
			      deixisvar := %ADJP.deixis;
			      aspectvar := %ADJP.aspect;
			      retrovar := %ADJP.retro;
			      actuseefsvar := %ADJP.actuseefs;
			      eformationvar := %ADJP.eformation;
			      enominalisedvar := %ADJP.enominalised;
			      formvar := %ADJP.form;
			      eORenFormvar := %ADJP.eORenform;
			      actsubcefsvar := %ADJP.actsubcefs;
			      thetaadjvar := %ADJP.thetaadj;
			      adjpatternefsvar := %ADJP.adjpatternefs;
			      temporalvar := %ADJP.temporal;
			      reflexivityvar := %ADJP.reflexivity;
                            END
       *>

HFINAL: #CONDITION: TRUE
        #ACTION: BEGIN
                    MAKET_ADJP;
         	    $ADJP.req := reqvar;
		    $ADJP.class := classvar;
		    $ADJP.deixis := deixisvar;
		    $ADJP.aspect := aspectvar;
		    $ADJP.retro := retrovar;
		    $ADJP.actuseefs := actuseefsvar;
		    $ADJP.eformation := eformationvar;
		    $ADJP.eNominalised := enominalisedvar;
		    $ADJP.form := formvar;
		    $ADJP.eORenform := eORenFormvar;
		    $ADJP.actsubcefs := actsubcefsvar;
		    $ADJP.thetaadj := thetaadjvar;
		    $ADJP.adjpatternefs := adjpatternefsvar;
		    $ADJP.mood := moodvar;                     
                    $ADJP.temporal := temporalvar;         
                 END
*>
END;
& 


%ADJP2srule

REGULAREXPRESSION:


ADJP = 
     ({ADJSTADV | ADJLOCADV | REFLPRO/1 | NP/2 | PREPP/3 | PREPP/4 | PREPP/22
      | PREPP/5}) 
      . [NP/6] . [QP/7 | QP/77 | ADVP/8 | ADVP/88 | NP/9 | NP/25] 
      . ([PREPP/10 | PREPP/11]) . [ART/12 ] . ADJ/13 . [QP/14 | ADJP/21]
      . ({ PREPP/15 | PREPP/23| PREPP/24 | PREPP/27 | SENTENCE/17 | THANP/18 
           | SENTENCE/19 | SENTENCE/26})
      . [SENTENCE/20]


ADJSTADV = NEG/31 | POS/32 
        | ADVP/33 | PREPP/34 | ADVP/35 | PREPP/36
        | NP/37 | ADJQADV 

ADJLOCADV = ADVP/38 | PREPP/ 39 | RADVP/40

ADJQADV = ADVP/41


CONDITIONSANDACTIONS:

!(* MET locargrel is nog geen rekening gehouden *) 

VAR 
     teller : integer;
     AANPREPPfound ::: BOOLEAN;
     COMPARATIVEexpected ::: BOOLEAN; !(* om optreden van bijv. 'iets' in
                                          'iets mooier' afhankelijk te maken
                                        van '-er'. *)
     COMPARATIVEfound :: BOOLEAN;    !(* idem *)   
     COMPARATIVEcomplexpected ::: BOOLEAN; !(* Bedoeld om 
                                        - het optreden van ADVP `zo'
                                          (datcompl) zonder complement
                                          uit te sluiten *)
     COMPARATIVEcomplfound :: BOOLEAN;    !(* idem *)   
     vancomplpossible ::: BOOLEAN;      !(* bedoeld om optreden van compl to 
                                            meest(e) te beregelen *)
     THANPpossible ::: BOOLEAN;             !(* bedoeld om optreden van THANP
                                               te beregelen *)   
     SUPERLATIVEexpected :: BOOLEAN; 
                                     !(* Bedoeld om optreden van `het' zonder 
                                        `meest' te koppelen aan aanwezigheid 
                                        van superlative ADJ. NB: In dit geval
                                        is er geen sprake van een QP. *)
     SUPERLATIVEfound :: BOOLEAN;    !(* idem *)   
     DEGREECOMPLfound ::: BOOLEAN;  !(* funtioneert nog niet echt *)
     DEGREEMODexpected ::: BOOLEAN; !(* Deze parameter wordt gebruikt om
                                      te zorgen dat voor PREPPs maar 
                                      preadjectival positie is. *)
     DEGREEMODfound ::: BOOLEAN;    !(* Deze parameter is multi-functioneeel: 
                                      hij wordt niet alleen gebruikt om te 
                                      voorkomen dat er twee of meer degree-
                                      modifiers optreden. in combinatie met
                                      DEGREEmodexpected wordt ook de distri-
                                      butie van PP's ermee beregeld. *)
     DONPfound ::: BOOLEAN;
     erPREPPfound :: BOOLEAN;       !(* om not-stranded, not er-(pa)PREPobjs 
                                       uit te sluiten als alleen prepsent-
                                       patterns kunnen
                                    *)
     strandedPREPPfound :: BOOLEAN;  !(* idem *) 
     HEADexpected ::: BOOLEAN;    !(* HEADexpected: eerstvolgende string is head  
                                    van ADJP, dus ADJ. Bedoeld om de condities
                                    op gestrande preposities te vangen. *)
     ALSCOMPLADVfound ::: BOOLEAN; !(* om bij te houden of 'zo' als degreeadv 
                                     gevonden is; example: zo spoedig mogelijk
                                  *)
     IONPfound ::: BOOLEAN;
     NEGORPOSfound ::: BOOLEAN;
     omcomplexpected ::: BOOLEAN;
     PAOBJfound  ::: BOOLEAN;     !(* Om bij te houden of er een prepobj in 
                                    PostAdjectival position is gevonden *)
     erposPAOBJfound  ::: BOOLEAN;  !(* Om bij te houden of er een PAprepobj in 
                                    erposrel is gevonden *)
     PASENTCOMPLfound  :: BOOLEAN; !(* Om bij te houden of er een sententieel
                                    complement  in 
                                    PostAdjectival position is gevonden *)
     PREPOBJexpected ::: BOOLEAN;
     PREPOBJfound  ::: BOOLEAN;
     
     HOPexpected :: BOOLEAN;
     HOPfound  ::: BOOLEAN;
     PROOBJSENTfound ::: BOOLEAN;
     REFLRELfound ::: BOOLEAN;
     STADVfound ::: BOOLEAN;
     COMPLfound :: BOOLEAN;
     VOORobjmodfound ::: BOOLEAN;
     reqvar :: polarityEFFSETtype;
     envvar :: polarityEFFSETtype;
     classvar :: timeadvclasstype;
     deixisvar :: deixistype;
     aspectvar :: aspecttype;
     retrovar :: retrotype;
     actuseefsvar :: adjuseEFFSETtype;
     eformationvar :: eformationtype;
     enominalisedvar :: enominalisedtype;
     formvar :: adjadvformtype;
     eORenFormvar :: eorenformtype;
     temporalvar :: temporaltype;
     actsubcefsvar ::: adjsubceffsettype;
     thetaadjvar :: thetaadjtype;
     adjpatternefsvar :: synpatterneffsettype;
     prepkeyvar ::: keytype;
     reflexivityvar :: reflexivetype;
     moodvar :: xpmoodtype;
?
HELP

PROCEDURE reduceadjpatterns(VAR adjps::synpatternEFFSETtype);
BEGIN 
   IF DONPfound
   THEN adjps := adjps * AUX_objadjps;
   IF IONPfound
   THEN adjps := adjps * AUX_indobjadjps;
   IF AANPREPPfound
   THEN adjps := adjps * AUX_aanobjadjps;
   IF (PREPOBJfound OR PAOBJfound)
   THEN adjps := adjps * (AUX_prepobjadjps + AUX_aanobjadjps + AUX_PAadjps);
   IF erposPAOBJfound
   THEN adjps := adjps *  AUX_PAadjps;
   IF PASENTCOMPLfound
   THEN adjps := adjps * AUX_sentcomplvps;
END !(*reduceadjpatterns*);
 
PROCEDURE reduceadjsubcs(VAR actsubcs::adjsubcEFFSETtype);
BEGIN
    IF ((PROOBJSENTfound) AND (NOT DEGREEMODfound))
    THEN actsubcs := actsubcs * [subjectiveadj]
END !(*reduceadjsubcs*);


FUNCTION artunderqp(t1:LSSTREE_pstree):BOOLEAN;  
                            !(* This condition is supposed to be 
                              met if there is an artrel (definite
                              article 'het' in the QP.
                              It is relevant to determine the value 
                              of actuseefs of the ADJP *)
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;
     WHILE NOT (result) AND (sonlist<>NIL) DO
       BEGIN
       IF sonlist^.node^.cat=ART THEN 
        IF sonlist^.relation=artrel THEN
         BEGIN
         IF sonlist^.node^.ls^.artfield^.key = KEY_hetARTkey THEN result:= TRUE;
         END;
       sonlist:=sonlist^.brother
       END;
     artunderqp:=result;
     END; !(*artunderqp*)


FUNCTION mogelijkkey(b:LSSTREE_pstree):BOOLEAN;
VAR stree:LSSTREE_pstree;
BEGIN
IF (b^.sons^.relation =head) THEN BEGIN
  stree:=b^.sons^.node;
  IF (stree^.sons^.relation=head) THEN BEGIN 
    stree:=stree^.sons^.node;
    IF (stree^.sons^.relation=head) THEN BEGIN
      stree:=stree^.sons^.node;
      IF stree^.ls^.BADJfield^.key=KEY_s_mogelijkbadj THEN
      mogelijkkey:=TRUE ELSE mogelijkkey:=FALSE
      END;
    END;
  END;
END;
?


<*
 
HINIT: BEGIN
         teller := 0;
         AANPREPPfound := false;
         ALSCOMPLADVfound := false; 
         erPREPPfound := false;   
         strandedPREPPfound := false;   
         COMPARATIVEexpected := false;
         COMPARATIVEfound := false;
         COMPARATIVEcomplexpected := false;
         COMPARATIVEcomplfound := false;
         THANPpossible := false;
         vancomplpossible := false;
         SUPERLATIVEexpected := false;
         SUPERLATIVEfound := false;
         DEGREECOMPLfound := false;
         DEGREEMODexpected := false;  
         DEGREEMODfound := false;  
         DONPfound := false;
         HEADexpected := false;  
         HOPexpected := false;  
         HOPfound := false;  
         IONPfound := false;
         omcomplexpected := false;
         NEGORPOSfound := false;
         erposPAOBJfound := false;
         PAOBJfound := false;
         VOORobjmodfound := false;
         PASENTCOMPLfound := false;
         COMPLfound := false;
         PREPOBJexpected := true;
         PREPOBJfound := false;
         PREPOBJexpected := true;
         REFLRELfound := false;
         STADVfound := false;
         reqvar := [omegapol, pospol, negpol];
         envvar := [omegapol, pospol, negpol];
         classvar := omegaTimeAdvClass;
         deixisvar := omegadeixis;
         aspectvar := omegaAspect;
         retrovar := false;
         actuseefsvar := [];
         eformationvar := RegEformation;
         enominalisedvar := regeNominalised;
         formvar := positive;
         eORenFormvar := eform;
         temporalvar := false;
         actsubcefsvar := [otheradj];
         thetaadjvar := omegathetaadjp;
         adjpatternefsvar := [];
         prepkeyvar := 0; 
         reflexivityvar := notreflexive;
         moodvar := declxpmood;

       END;

1:    !(* this part is a partial copy of node 25 in SENTENCEsrule (J.O.) *)
       <*
         LOCALCONDITION: (NOT %REFLPRO.zelf)
         GLOBAL: #CONDITION: (NOT STADVfound) AND
                             (NOT REFLRELfound)   
                 #ACTION:   BEGIN
                              SYNREL := reflrel;
                              REFLRELfound := true;
                           END
       *>

2: 
       <*
         LOCALCONDITION: (dative in %NP.cases) AND
                         (%NP.NPhead <> reducedpersproNP) AND
                         (%NP.NPhead <> hetNP) AND
                         (%NP.coord <> corrcoord)
         GLOBAL: #CONDITION: NOT IONPfound 

                 #ACTION:   BEGIN
                              SYNREL := indobjrel;
                              IONPfound := true;
                              COMPLfound := true;
                            END
       *>

3: 
       <*
         LOCALCONDITION: (NOT %PREPP.stranded) AND
                         (%PREPP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT HEADexpected)
                 #ACTION:   BEGIN
                              SYNREL := erposrel;
                              erposPAOBJfound := true;
                              COMPLfound := true;
                              IF %PREPP.radvkey <> 0
                              THEN erPREPPfound := true;
                            END
       *>

22: 
       <*
         LOCALCONDITION: (%PREPP.headkey = KEY_voorioprepkey) AND
                         (NOT %PREPP.stranded) AND
                         (%PREPP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT HEADexpected)
                 #ACTION:   BEGIN
                              SYNREL := erposrel;
                              VOORobjmodfound := true;
                            END
       *>

4: 
       <*
         LOCALCONDITION: (%PREPP.headkey = KEY_aanioprepkey) AND
                         (NOT %PREPP.stranded) AND
                         (%PREPP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT AANPREPPfound) AND ( NOT HEADexpected)
                 #ACTION:   BEGIN
                              SYNREL := erposrel;
                              AANPREPPfound := true;
                              COMPLfound := true;
                              DEGREEMODexpected := true;
                            END
       *>
5: 
       <*
         LOCALCONDITION: (%PREPP.coord <> corrcoord) AND
                         (NOT %PREPP.stranded) 
         GLOBAL: #CONDITION: (NOT PREPOBJfound) AND ( NOT HEADexpected)
                 #ACTION:   BEGIN
                              SYNREL := erposrel;
                              PREPOBJfound := true;
                              COMPLfound := true;
                              DEGREEMODexpected := true;
                              IF %PREPP.radvkey <> 0
                              THEN erPREPPfound := true;
                            END
       *>
6: !(* eventueel conditie toevoegen die vereist het hoofd van de ADJP een 
      measure-adj is *)
       <*
         LOCALCONDITION: (accusative in %NP.cases) AND
                         (%NP.NPhead <> reducedpersproNP) AND
                         (%NP.NPhead <> hetNP)  AND
                         (%NP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT DONPfound) AND (NOT HEADexpected)
                 #ACTION:   BEGIN
                              SYNREL := objrel;
                              DONPfound := true;
                              COMPLfound := true;
                            END
       *>

7:  

       <*
         LOCALCONDITION: %QP.hop = false AND
                         NOT artunderqp(b) (* excludes 'het meest' *)

         GLOBAL: #CONDITION: (NOT DEGREEMODfound) AND (NOT HEADexpected)
                 #ACTION:   BEGIN
                              SYNREL := degreemodrel;
                              DEGREEMODfound := true;
                              moodvar := %QP.mood;
                              If %QP.thanas = omcompl
                                  THEN omcomplexpected := true;
                              IF %QP.thanas = omegacompl
                              THEN COMPARATIVEexpected := true; 
                                 (* to exclude: veel/wat mooie als ADJP *)
                              IF %QP.thanas IN  [alscompl, dancompl]
                              THEN BEGIN 
                                   THANPpossible := true;
                                   HEADexpected := true
                                   END;
                              IF %QP.thanas IN  [ vancompl] 
                              THEN BEGIN 
                                   vancomplpossible := true;
                                   HEADexpected := true
                                   END;
                              IF %QP.thanas IN  [ vancompl] 
                              THEN BEGIN 
                                   actuseefsvar :=
                                               [attributive, nominalised]
                                                  (* meest zonder 'het' *)
                                   END;

                            END
       *>

77:  

       <*
         LOCALCONDITION: %QP.hop = false AND
                         artunderqp(b) (* het meest *)

         GLOBAL: #CONDITION: (NOT DEGREEMODfound) AND (NOT HEADexpected)
                 #ACTION:   BEGIN
                              SYNREL := degreemodrel;
                              DEGREEMODfound := true;
                              moodvar := %QP.mood;
                              IF %QP.thanas IN  [ vancompl] (* meest *)
                              THEN BEGIN 
                                   vancomplpossible := true;
                                   HEADexpected := true
                                   END;
                              IF %QP.thanas IN  [ vancompl] (* meest *)
                              THEN BEGIN 
                                   actuseefsvar := [predicative]
                                   END;
                            END
       *>

8: 
       <*
         LOCALCONDITION: (%ADVP.actsubcefs * [degreeadv] <> []) AND
                         (%ADVP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT DEGREEMODfound) AND (NOT HEADexpected)
                 #ACTION:   BEGIN
                              SYNREL := degreemodrel;
                              DEGREEMODfound := true;
                           
                              If %ADVP.thanas = alscompl
                              THEN ALSCOMPLADVfound := true;
                              If %ADVP.thanas = alscompl
                              THEN THANPpossible := true;
                              If %ADVP.thanas = datcompl
                              THEN COMPARATIVEcomplexpected := true;
                              If %ADVP.thanas = omcompl
                              THEN omcomplexpected := true;
                              moodvar := %ADVP.mood;

                           END
       *>

88: 
       <*                                         !(* bijna wit genoeg  *)
         LOCALCONDITION: (%ADVP.actsubcefs * [Numadv] <> []) AND
                         (%ADVP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT DEGREEMODfound) AND (NOT HEADexpected)
                 #ACTION:   BEGIN
                            SYNREL := premodrel;
                            HOPexpected := true;
                            moodvar := %ADVP.mood;
                           END
       *>
9: 
       <*
         LOCALCONDITION: (unitnoun IN %NP.actsubcs)  OR
                         ((%NP.definite = indef) AND
                          (mass IN %NP.actcomas ) 
                         ) (* amountnp *)  AND
                         (%NP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT DEGREEMODfound) AND (NOT HEADexpected)
                 #ACTION:   BEGIN
                              SYNREL := degreemodrel;
                              DEGREEMODfound := true
                            END
       *>

25:                                   !(* iets ronder *)
       <*
         LOCALCONDITION: (unitnoun IN %NP.actsubcs) OR
                         ((%NP.definite = indef) AND
                          (mass IN %NP.actcomas ) 
                         ) (* amountnp *) AND 
                         (%NP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT DEGREEMODfound) AND (NOT HEADexpected)
                 #ACTION:   BEGIN
                              SYNREL := premodrel;
                              comparativeexpected := true;
                            END
       *>


10: 
       <*
         LOCALCONDITION: (%PREPP.headkey = KEY_aanioprepkey) AND
                         (%PREPP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT AANPREPPfound) AND
                             (NOT HEADexpected) 
                 #ACTION:   BEGIN
                              SYNREL := aanobjrel;
                              AANPREPPfound := true;
                              COMPLfound := true;
                              IF %PREPP.stranded
                              THEN HEADexpected := true;
                            END
       *>

11: 
       <*
         LOCALCONDITION: (%PREPP.coord <> corrcoord)
         GLOBAL: #CONDITION: (NOT PREPOBJfound) AND
                             (NOT HEADexpected) 
                 #ACTION:   BEGIN
                              SYNREL := prepobjrel;
                              PREPOBJfound := true;
                              COMPLfound := true;
                              IF %PREPP.stranded
                              THEN HEADexpected := true;
                              IF %PREPP.stranded
                              THEN strandedPREPPfound := true;
                              IF %PREPP.radvkey <> 0
                              THEN erPREPPfound := true;
                            END
       *>

12:
       <*
         LOCALCONDITION: %ART.key = KEY_hetARTkey
         GLOBAL: #CONDITION: (NOT DEGREEMODfound) 
                 #ACTION:   BEGIN
                              SYNREL := artrel;
                              SUPERLATIVEexpected := true;
                              actuseefsvar := [predicative];
                            END
       *>

13: 
       <*
         LOCALCONDITION: (%ADJ.form <> sPositive)
                           !(* To exclude ADJP-status for `veel moois'.
                            If `moois' sec is to be  considered an ADJP, 
                            the condition should be modified *) 
                        
                         
         GLOBAL: #CONDITION: (erposPAOBJfound <= 
                              (%ADJ.adjpatterns  * AUX_PAadjps <> [])) AND
                             (PREPOBJfound <= 
                              (%ADJ.adjpatterns  * AUX_prepobjadjps <> [])) AND
                             (AANPREPPfound <= 
                              (%ADJ.adjpatterns  * AUX_aanobjadjps <> [])) AND
                             (VOORobjmodfound <= 
                              (%ADJ.subcs * [voorsubjectiveadj] <> [])) AND
                             (DEGREEMODexpected <= DEGREEmodfound )        AND
                             ((%ADJ.form =comparative) 
                                                <= (NOT DEGREEMODfound))  AND
                             ((%ADJ.form =superlative) <= (NOT DEGREEMODfound))
                 #ACTION:   BEGIN
                              teller := teller + 1;
                              SYNREL := head;
                              IF %ADJ.prepkey = 0
                              THEN PREPOBJexpected := false;
                              IF %ADJ.form = comparative
                              THEN  BEGIN
                                      THANPpossible := true;
                                      DEGREEMODfound := true
                                    END;
                              IF %ADJ.form = comparative
                              THEN  BEGIN
                                      comparativefound:= true
                                    END;
                              IF %ADJ.form = superlative
                                 THEN SUPERLATIVEfound := true;
                              IF %ADJ.form = superlative
                                 THEN BEGIN
                                        vancomplpossible := true;
                                        DEGREEMODfound := true
                                      END;
			      reqvar := %ADJ.req;
			      envvar := %ADJ.env;
			      classvar := %ADJ.class;
			      deixisvar := %ADJ.deixis;
			      aspectvar := %ADJ.aspect;
			      retrovar := %ADJ.retro;
                              IF actuseefsvar = [] 
                                 THEN actuseefsvar := %ADJ.uses
                                 ELSE actuseefsvar := 
                                            actuseefsvar * %ADJ.uses;
			      eformationvar := %ADJ.eformation;
			      enominalisedvar := %ADJ.enominalised;
			      formvar := %ADJ.form;
			      eORenFormvar := %ADJ.eORenform;
			      actsubcefsvar := %ADJ.subcs;
			      thetaadjvar := %ADJ.thetaadj;
			      adjpatternefsvar := %ADJ.adjpatterns;
                              prepkeyvar := %ADJ.prepkey;
			      temporalvar := %ADJ.temporal;
			      reflexivityvar := %ADJ.reflexivity;
                              
                            END
       *>

14:    <*
         LOCALCONDITION: %QP.hop = true
         GLOBAL: #CONDITION: NOT DEGREEMODfound
                 #ACTION:   BEGIN
                              SYNREL := hoprel;
                              DEGREEMODfound := true;
                              HOPfound := true;
                            END
       *>
         
21:    <*
         LOCALCONDITION: (%ADJP.coord <> corrcoord) AND mogelijkkey(b)
         GLOBAL: #CONDITION: alscompladvfound 
                 #ACTION:   BEGIN
                              SYNREL := zocomplrel;
                              DEGREECOMPLfound := true;
                            END
       *>
         

15: 
       <*
         LOCALCONDITION: (%PREPP.coord <> corrcoord) 
                         
         GLOBAL: #CONDITION: (NOT PREPOBJfound) AND
                             (NOT AANPREPPfound) AND
                             (NOT erposPAOBJfound) AND
                             (NOT PAOBJfound) AND
                             (PREPobjexpected) AND
                             ((%PREPP.headkey= prepkeyvar) OR
                              (%PREPP.headkey= KEY_aanioprepkey)
                             )
                 #ACTION:   BEGIN
                              SYNREL := paprepobjrel;
                              PAOBJfound := true;
                              COMPLfound := true;
                              IF %PREPP.stranded
                              THEN strandedPREPPfound := true;
                              IF %PREPP.radvkey <> 0
                              THEN erPREPPfound := true;

                             END
       *>
23: 
       <*
         LOCALCONDITION: (%PREPP.headkey = KEY_voorioprepkey) AND
                         (%PREPP.coord <> corrcoord)
         GLOBAL: #CONDITION: actsubcefsvar * [voorsubjectiveadj] <> []
                 #ACTION:   BEGIN
                              SYNREL := voorobjrel;
                             END
       *>

24: 
       <*
         LOCALCONDITION: (%PREPP.coord <> corrcoord) AND
                         (%PREPP.actsubcefs * [loc, caus, temp] <> [])
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := postadjrel;
                             END
       *>

27:
       <*
         LOCALCONDITION: (%PREPP.coord <> corrcoord) AND
                         (%PREPP.headkey = KEY_vanprepkey)
         GLOBAL: #CONDITION: vancomplpossible = true
                 #ACTION:   BEGIN
                              SYNREL := vancomplrel;
                             END
       *>
 


17:   !(* (zeer) leuk om te zien ; NB. complementen van degreemodifiers 
          beginnen als postadjrel *)
       <*
         LOCALCONDITION: (%SENTENCE.conjkey  = KEY_omconjkey) AND
                         (%SENTENCE.coord <> corrcoord) AND
                         (%SENTENCE.mood = proobjmod)
         GLOBAL: #CONDITION:(subjectiveadj IN  actsubcefsvar) AND  
                            (NOT PROOBJSENTfound) AND
                            (NOT hopfound) (* in: mooi genoeg om te kopen
                                                  is de om te-zin geen 
                                                  omtemodrel, maar postadjrel *)
                 #ACTION:   BEGIN
                              SYNREL := omtemodrel; 
                              PROOBJSENTfound := true;
                            END
       *>

18: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (THANPpossible) AND
                             (NOT DEGREECOMPLfound)
                 #ACTION:   BEGIN
                              SYNREL := postadjrel; 
                              DEGREECOMPLfound := true
                            END
       *>


19:  !(* This subrule is relevant for testing purposes only. In sentential
       contexts complement sentences occur always outside of the ADJP.*)
       <*
         LOCALCONDITION: (%SENTENCE.senttype = subordinateclause) AND
                         (%SENTENCE.adverbial = false)            AND
                                          !(* JO,30-AUG-1988 13:51:46 *)
                         NOT (%SENTENCE.mood IN [anterelative, relative]) 
                                          !(* 14-JUL-1989 FJ *)      AND
                         (%SENTENCE.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := postadjrel; 
                              PASENTCOMPLfound := true;
                              COMPLfound := true;
                            END
       *>


20:    !(* for example in: zo mooi dat het vervelend is om te vertrekken zal het 
          weer hier wel niet worden *)
       <*
         LOCALCONDITION: (%SENTENCE.conjkey = KEY_datconjkey)  AND
                         (%SENTENCE.coord <> corrcoord)
         GLOBAL: #CONDITION: (DEGREEMODfound) AND
                             (NOT DEGREECOMPLfound) AND
                             (COMPARATIVEcomplexpected)
                 #ACTION:   BEGIN
                              SYNREL := resultrel;
                              DEGREECOMPLfound := true;
                              COMPARATIVEcomplfound := true;
                            END
       *>

26: 
       <*
         LOCALCONDITION: (%SENTENCE.conjkey  = KEY_omconjkey) AND
                         (%SENTENCE.coord <> corrcoord) AND
                         (%SENTENCE.mood IN [declarative, proobjmod])
         GLOBAL: #CONDITION: NOT DEGREECOMPLfound  AND
                             (HOPfound OR omcomplexpected)
                 #ACTION:   BEGIN
                              SYNREL := postadjrel; 
                              DEGREECOMPLfound := true
                            END
       *>



!(* the next part is a partial copy of nodes 29-35 and 38-41 
   in SENTENCEsrule (J.O.) *)

31: !(* 29 *)
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (NOT negorposfound)
                 #ACTION:   BEGIN
                              SYNREL := negrel;
                              negorposfound := true;
                            END
       *>

32: !(* 30 *)
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (NOT negorposfound)
                 #ACTION:   BEGIN
                              SYNREL := posrel;
                              negorposfound := true;
                            END
       *>

33: !(* 31 *)
       <*
         LOCALCONDITION: (%ADVP.actsubcefs *[sentadv, causadv] <> [])  AND
                         (%ADVP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := sentadvrel;
                              stadvfound := true
                            END
       *>


34: !(* 32 *)
       <*
         LOCALCONDITION: (%PREPP.actsubcefs * [according, caus] <> []) AND
                         (NOT %PREPP.stranded) AND
                         (%PREPP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := sentadvrel;
                              stadvfound := true
                            END
       *>


35: !(* 33 *)
       <*
         LOCALCONDITION: (tempadv IN %ADVP.actsubcefs)  AND
                         (%ADVP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := tempadvrel;
                              stadvfound := true
                            END
       *>

36: !(* 34 *)
       <*
         LOCALCONDITION: (temp IN %PREPP.actsubcefs) AND
                         (NOT %PREPP.stranded) AND
                         (%PREPP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := tempadvrel;
                              stadvfound := true
                            END
       *>

37: !(* 35 *)
       <*
         LOCALCONDITION: (%NP.temporal = true)  AND
                         (%NP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := tempadvrel;
                              stadvfound := true
                            END
       *>


38: !(* 38 *) 
       <*
         LOCALCONDITION: (locadv IN %ADVP.actsubcefs)  AND
                         (%ADVP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := locadvrel;
                            END
       *>

39: !(* 39 *) 
       <*
         LOCALCONDITION: (NOT %PREPP.stranded)        AND
                         (loc IN %PREPP.actsubcefs) AND
                         (%PREPP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := locadvrel;
                            END
       *>

40: !(* 40 *)
       <*
         LOCALCONDITION: (%RADVP.radvkey <> KEY_erRADVkey  ) AND
                         (%RADVP.radvkey <> KEY_daarRADVkey) AND 
                         (%RADVP.radvkey <> KEY_hierRADVkey)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := locadvrel;
                            END
       *>

41: !(* 41 *)
       <*
         LOCALCONDITION: (%ADVP.Qstatus = true )  AND
                         (%ADVP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := agvpadvrel;
                              stadvfound := true;
                            END
       *>





HFINAL: #CONDITION: ((NOT reflrelfound) OR (reflexivityvar = reflexive))
                                        !(*JO,  7-NOV-1988 14:26:22 *) AND
                    (
                     COMPLfound <= 
                        ((adjpatternefsvar * [synnoadjpargs] = [])
                                        !(* FJ, 29/11/88*) OR
                         (actsubcefsvar * [subjectiveadj] <> []) 
                                        !(* FJ, 27/07/89;
                                           met het oog op voorobjmods *) 
                        )
                    )   AND
                    ((PREPOBJexpected = false) <= 
                         NOT (PREPOBJfound OR PAobjfound OR erposPAobjfound)
                    ) !(* FJ, 29/06/89 *)  AND
                    (((adjpatternefsvar - AUX_prepsentadjps) = []) <=
                      (erPREPPfound OR strandedPREPPfound)    
                    ) 
                   
       #ACTION: BEGIN
                   reduceadjpatterns(adjpatternefsvar);
                   IF  ((PREPOBJfound OR PAOBJfound OR erposPAOBJfound) AND
                       (NOT (erPREPPfound OR strandedPREPPfound))
                      ) 
                   THEN 
                        adjpatternefsvar := 
                        (adjpatternefsvar - AUX_sentadjps);
                   reduceadjsubcs(actsubcefsvar);

                   IF ((adjpatternefsvar <> []) AND
                       (actsubcefsvar <> [])) AND
                       (NOT ((COMPARATIVEexpected) 
                              AND (NOT COMPARATIVEfound))) AND
                       (NOT ((COMPARATIVEcomplexpected) 
                              AND (NOT COMPARATIVEcomplfound))) AND
                       (NOT ((SUPERLATIVEexpected) 
                              AND (NOT SUPERLATIVEfound)))      AND
                       (NOT ((HOPexpected)
                             AND (NOT HOPfound)))
                  THEN 
                     BEGIN
                       MAKET_ADJP;
                       $ADJP.req := reqvar;
                       $ADJP.class := classvar;
                       $ADJP.deixis := deixisvar;
                       $ADJP.aspect := aspectvar;
                       $ADJP.retro := retrovar;
                       $ADJP.actuseefs := actuseefsvar;
                       $ADJP.eformation := eformationvar;
                       $ADJP.eNominalised := enominalisedvar;
                       $ADJP.form := formvar;
                       $ADJP.eORenform := eORenFormvar;
                       $ADJP.actsubcefs := actsubcefsvar;
                       $ADJP.thetaadj := thetaadjvar;
                       $ADJP.adjpatternefs := adjpatternefsvar;
                       $ADJP.mood := moodvar;                     
                       $ADJP.temporal := temporalvar;         
                       $ADJP.reflexivity := reflexivityvar;
                     END;
               END
*>
END;
& 



%THANASPsrule


REGULAREXPRESSION:

THANP =   THANAS/1 . (NP/2 | PREPP/3 | ADVP/4 | DETP/5 | ADJP/6) 


CONDITIONSANDACTIONS:

VAR
    reqvar :: polarityEFFSETtype;
    envvar :: polarityEFFSETtype;
    thanasvar  :: thanascompltype;




<* 
HINIT: BEGIN
         reqvar := [omegapol, pospol, negpol];
         envvar := [omegapol, pospol, negpol];
         thanasvar := omegacompl;
       END;

1: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
                              IF %THANAS.key = KEY_danthanaskey
                              THEN thanasvar := dancompl;
                              IF %THANAS.key = KEY_alsthanaskey
                              THEN thanasvar := alscompl;
                             END

      *>
2: 
       <*
         LOCALCONDITION: (%NP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := complrel
                            END
       *>
3: 
       <*
         LOCALCONDITION: (%PREPP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := complrel
                            END
       *>
4: 
       <*
         LOCALCONDITION: (%ADVP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := complrel
                            END
       *>

5: 
       <*
         LOCALCONDITION: %DETP.definite = indef
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := complrel
                            END
       *>

6: 
       <*
         LOCALCONDITION: (%ADJP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := complrel
                            END
       *>

HFINAL: #CONDITION: true
        #ACTION: BEGIN
                    MAKET_THANP;
                    $THANP.req := reqvar;
                    $THANP.env := envvar;
                    $THANP.thanas := thanasvar;
                  
                 END  
*>
END;
& 


%QPsrule

REGULAREXPRESSION:

QP = ([ADVP/1 | NP/2 ]) . [ART/3] . Q/4 . [ THANP/5 ]
 
CONDITIONSANDACTIONS:

VAR 
                     MEESTexpected :: BOOLEAN;
                     MEESTfound :: BOOLEAN;
                     COMPLfound ::: BOOLEAN;
                     reqvar :: polarityEFFSETtype;
                     envvar :: polarityEFFSETtype;
                     definitevar :: deftype;
                     posspredvar :: posspredtype;
                     possnumbersvar :: numberSETtype;
                     posscomasvar :: posscomaSETtype;
                     moodvar :: xpmoodtype;
                     thanasvar :: thanascompltype;
                     hopvar :: hoptype;
 


<* 
HINIT: BEGIN
         MEESTexpected := false;
         MEESTfound := false;
         COMPLfound := false;
         reqvar := [pospol, negpol, omegapol];
         envvar := [pospol, negpol, omegapol];
         definitevar := omegadef;
         posspredvar := false;
         possnumbersvar := [singular];
         posscomasvar := [count];
         moodvar := declxpmood;
         thanasvar := omegacompl;
         hopvar := false;
       END;

1:    
       <*
         LOCALCONDITION: degreeadv IN %ADVP.actsubcefs  (* te (veel) *)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := premodrel
                            END
       *>  

2: 
       <*
         LOCALCONDITION: ((%NP.actsubcs * [unitnoun, plurunitnoun] <> []) OR
                          (%NP.actcomas * [mass] <> []))  AND
                         (%NP.definite = indef)  (* amountnp *) AND
                         (%NP.coord <> corrcoord)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := premodrel

                            END
       *>  

3: 
       <*
         LOCALCONDITION: %ART.key = KEY_hetARTkey
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := artrel;
                              MEESTexpected := true
                            END
       *>  

4: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := head;
                              IF %Q.key = KEY_meestQkey
                              THEN MEESTfound := true;
                              reqvar := %Q.req;
                              envvar := %Q.env;
                              definitevar := %Q.definite;
                              posspredvar := %Q.posspred;
                              possnumbersvar := %Q.possnumbers;
                              posscomasvar := %Q.posscomas;
                              moodvar := %Q.mood;
                              thanasvar := %Q.thanas;
                              hopvar := %Q.hop;                              

                            END
       *>

5: 
       <*
         LOCALCONDITION: true 
         GLOBAL: #CONDITION: NOT COMPLfound 
                 #ACTION:   BEGIN
                              SYNREL := thanascomplrel;
                              COMPLfound := true;
                            END
       *>

HFINAL: #CONDITION: true
        #ACTION: BEGIN
                 MAKET_QP;
                 IF (NOT ((MEESTexpected) 
                              AND (NOT MEESTfound)))
                   THEN 
                     BEGIN
                      $QP.req := reqvar;
                      $QP.env := envvar;
                      $QP.definite := definitevar;
                      $QP.posspred := posspredvar;
                      $QP.possnumbers := possnumbersvar;
                      $QP.posscomas := posscomasvar;
                      $QP.mood := moodvar;
                      $QP.thanas := thanasvar;
                      $QP.hop := hopvar;
                     END;
                 END

           
*>
END;
& 


%PPcoord
REGULAREXPRESSION:
 
PREPP = [COORD/1] .{PREPP/2 .(COORD/3 | PUNC/4)} .PREPP/5 .COORD/6 .PREPP/7

CONDITIONSANDACTIONS:

VAR  
    actsubcefsvar  ::: prepsubceffsettype;
    aspectvar      ::: aspecttype;
    classvar       ::: timeadvclasstype;
    coordpar       :: coordtype;
    corr1found     ::: BOOLEAN;
    deixisvar      :: deixistype;
    envvar         :: polarityEFFSETtype;
    expkey         ::: keytype;
    headkeyvar     ::: keytype;
    itcommafound   ::: BOOLEAN;
    itcoordfound   ::: BOOLEAN;
    iterationfound ::: BOOLEAN;
    iterationok    ::: BOOLEAN;
    moodvar        ::: xpmoodtype;
    postformvar    :: postformtype;
    postpkeyvar    :: keytype;
    radvkeyvar     :: keytype;
    retrovar       ::: retrotype;
    reqvar         :: polarityEFFSETtype;
    synppefsvar    :: synpatterneffsettype;
    specqvar       ::: specqtype;
    strandedvar    :: BOOLEAN;
    thetappvar     :: thetapptype;    
?
HELP


!(* moved to lssurfquo:
PROCEDURE assqmax(s1::specqtype; VAR s2::specqtype);
BEGIN
  IF s1 = yesspec THEN s2 := s1;
END;*) !(*assqmax*)

?


<* 

HINIT: BEGIN
    actsubcefsvar  := [];
    aspectvar      := omegaaspect;
    classvar       := omegatimeadvclass;
    coordpar       := nocoord;
    corr1found     := false;
    deixisvar      := omegadeixis;
    envvar         := [omegapol, pospol, negpol];
    expkey         := 0;
    headkeyvar     := 0;
    itcommafound   := false;
    itcoordfound   := false;
    iterationfound := false;
    iterationok    := true;
    moodvar        := declxpmood;
    postformvar    := pre;
    postpkeyvar    := 0;
    radvkeyvar     := 0;
    retrovar       := false;
    reqvar         := [omegapol, pospol, negpol];
    synppefsvar    := [];
    specqvar       := omegaspec;
    strandedvar    := false;
    thetappvar     := omegathetapp;    
          
       END;
 

1: 
       <*
         LOCALCONDITION: (correlative1 IN %COORD.kinds) AND
                         (ppc IN %COORD.patterns)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              corr1found := true;
                              expkey     := %COORD.correlative2key;
                              iterationok := %COORD.iteration;
                              coordpar   := corrcoord;
                            END
       *>
 


2: 
       <*
         LOCALCONDITION: (%PREPP.coord = nocoord) AND
                         (NOT %PREPP.stranded)
         GLOBAL: #CONDITION: iterationok                                     AND
                             (iterationfound <=
                              ((%PREPP.actsubcefs * actsubcefsvar  <> []) AND
                               (%PREPP.aspect = aspectvar)                AND
                               (%PREPP.class = classvar)           AND
                               (%PREPP.mood = moodvar)                    AND
                               (%PREPP.retro = retrovar)                  
                              )
                             )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              IF iterationfound THEN BEGIN
                                actsubcefsvar  := 
                                       actsubcefsvar * %PREPP.actsubcefs;
                                assqmax(%PREPP.specq, specqvar);
                                IF headkeyvar <> %PREPP.headkey
                                THEN headkeyvar := 0
                              END
                              ELSE BEGIN
				 actsubcefsvar  := %PREPP.actsubcefs;
				 aspectvar      := %PREPP.aspect;
				 classvar       := %PREPP.class;
				 moodvar        := %PREPP.mood;
				 retrovar       := %PREPP.retro;
				 specqvar       := %PREPP.specq;
                                 headkeyvar     := %PREPP.headkey
                              END;
                              iterationfound := true;
                            END
       *>

3: 
       <*
         LOCALCONDITION: %COORD.iteration                            
         GLOBAL: #CONDITION: (((NOT corr1found) <=
                               ( (ppc IN %COORD.patterns) AND
                                 (simple IN %COORD.kinds)
                               ) 
                              )                                           AND
                              ( corr1found <=
                                 (( %COORD.key = expkey) AND
                                  ( correlative2 IN %COORD.kinds)
                                 )
                              )                                           AND
                              (NOT itcommafound)
                             )
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              IF (NOT corr1found) THEN expkey := %COORD.key;
                              itcoordfound := true;
                            END
       *>

4: 
       <*
         LOCALCONDITION: %PUNC.key = KEY_kommaPUNCkey
         GLOBAL: #CONDITION: (NOT itcoordfound)
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              itcommafound := true;
                            END
       *>


5: 
       <*
         LOCALCONDITION: (%PREPP.coord = nocoord) AND
                         (NOT %PREPP.stranded)
         GLOBAL: #CONDITION: (iterationfound <=
                              ((%PREPP.actsubcefs * actsubcefsvar  <> []) AND
                               (%PREPP.aspect = aspectvar)                AND
                               (%PREPP.class = classvar)           AND
                               (%PREPP.mood = moodvar)                    AND
                               (%PREPP.retro = retrovar)                  
                              )
                             )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              IF iterationfound THEN BEGIN
                                actsubcefsvar  := 
                                       actsubcefsvar * %PREPP.actsubcefs;
                                assqmax(%PREPP.specq, specqvar);
                                IF headkeyvar <> %PREPP.headkey
                                THEN headkeyvar := 0
                              END
                              ELSE BEGIN
				 actsubcefsvar  := %PREPP.actsubcefs;
				 aspectvar      := %PREPP.aspect;
				 classvar       := %PREPP.class;
				 moodvar        := %PREPP.mood;
				 retrovar       := %PREPP.retro;
				 specqvar       := %PREPP.specq;
                                 headkeyvar     := %PREPP.headkey
                              END;
                            END
       *>

6: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (((NOT corr1found) <=
                               ( (ppc IN %COORD.patterns) AND
                                 (simple IN %COORD.kinds)
                               ) 
                              )                                           AND
                              ( corr1found <=
                                 (( %COORD.key = expkey) AND
                                  ( correlative2 IN %COORD.kinds)
                                 )
                              )                                           AND
                              (itcoordfound <= 
                                ((%COORD.key=expkey) AND
                                 (ppc IN %COORD.patterns)
                                )
                              )
                             )       
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              iterationok := %COORD.iteration;
                              IF (simple IN %COORD.kinds) AND
                                 (coordpar = nocoord) THEN
                                coordpar := simplecoord;
                            END
       *>


7: 
       <*
         LOCALCONDITION: (%PREPP.coord = nocoord) AND
                         (NOT %PREPP.stranded)
         GLOBAL: #CONDITION:  ((%PREPP.actsubcefs * actsubcefsvar  <> []) AND
                               (%PREPP.aspect = aspectvar)                AND
                               (%PREPP.class = classvar)           AND
                               (%PREPP.mood = moodvar)                    AND
                               (%PREPP.retro = retrovar)                  
                              )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              IF headkeyvar <> %PREPP.headkey
                              THEN headkeyvar := 0;
                              actsubcefsvar  := 
                                       actsubcefsvar * %PREPP.actsubcefs;
                              assqmax(%PREPP.specq, specqvar);
                            END
       *>


HFINAL: #CONDITION: iterationfound <= iterationok
        #ACTION: BEGIN
                    MAKET_PREPP;
		    $PREPP.req         := reqvar;
		    $PREPP.env         := envvar;
		    $PREPP.actsubcefs  := actsubcefsvar;
		    $PREPP.mood        := moodvar;
		    $PREPP.synppefs    := [];
		    $PREPP.headkey     := headkeyvar;
		    $PREPP.class       := classvar;
		    $PREPP.deixis      := deixisvar;
		    $PREPP.aspect      := aspectvar;
		    $PREPP.retro       := retrovar;
		    $PREPP.superdeixis := omegadeixis;
		    $PREPP.thetapp     := omegathetapp;
		    $PREPP.radvkey     := 0;
		    $PREPP.stranded    := false;
		    $PREPP.specq       := specqvar;
                    $PREPP.coord       := coordpar;
                  END
*>
END;
& 





%AdvPcoord
REGULAREXPRESSION:
 
AdvP = [COORD/1] .{AdvP/2 .(COORD/3 | PUNC/4)} .AdvP/5 .COORD/6 .AdvP/7

CONDITIONSANDACTIONS:

VAR  
    actsubcefsvar  ::: advsubceffsettype;
    advpatternsefsvar    :: synpatterneffsettype;
    aspectvar      ::: aspecttype;
    classvar       ::: timeadvclasstype;
    coordpar       :: coordtype;
    corr1found     ::: BOOLEAN;
    deixisvar      :: deixistype;
    envvar         :: polarityEFFSETtype;
    expkey         ::: keytype;
    itcommafound   ::: BOOLEAN;
    itcoordfound   ::: BOOLEAN;
    iterationfound ::: BOOLEAN;
    iterationok    ::: BOOLEAN;
    moodvar        ::: xpmoodtype;
    possnietnpvar  :: possnietnptype;
    qstatusvar     ::: qstatustype;
    radvbvar       :: radvtype;
    retrovar       ::: retrotype;
    reqvar         :: polarityEFFSETtype;
    temporalvar    ::: BOOLEAN;
    thanasvar      :: thanascompltype;
    thanascomplvar :: compltype;
    thetaadvvar    :: thetaadvtype;    



<* 

HINIT: BEGIN
    actsubcefsvar  := [];
    advpatternsefsvar := [];
    aspectvar      := omegaaspect;
    classvar       := omegatimeadvclass;
    coordpar       := nocoord;
    corr1found     := false;
    deixisvar      := omegadeixis;
    envvar         := [omegapol, pospol, negpol];
    expkey         := 0;
    itcommafound   := false;
    itcoordfound   := false;
    iterationfound := false;
    iterationok    := true;
    moodvar        := declxpmood;
    possnietnpvar  := false;
    qstatusvar     := false;
    radvbvar       := false;
    retrovar       := false;
    reqvar         := [omegapol, pospol, negpol];
    temporalvar    := false;
    thanasvar      := omegacompl;
    thanascomplvar := false;
    thetaadvvar    := omegathetaadv;
       END;
 

1: 
       <*
         LOCALCONDITION: (correlative1 IN %COORD.kinds) AND
                         (ppc IN %COORD.patterns)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              corr1found := true;
                              expkey     := %COORD.correlative2key;
                              iterationok := %COORD.iteration;
                              coordpar   := corrcoord;
                            END
       *>
 


2: 
       <*
         LOCALCONDITION: (%AdvP.coord = nocoord) 
         GLOBAL: #CONDITION: iterationok                                     AND
                             (iterationfound <=
                              ((%AdvP.actsubcefs * actsubcefsvar  <> []) AND
                               (%AdvP.aspect = aspectvar)                AND
                               (%AdvP.class = classvar)                  AND
                               (%AdvP.mood = moodvar)                    AND
                               (%ADVP.retro = retrovar)                  AND
                               (%AdvP.temporal = temporalvar)            AND
                               (%ADVP.Qstatus = Qstatusvar)     
                              )
                             )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              IF iterationfound THEN BEGIN
                                actsubcefsvar  := 
                                       actsubcefsvar * %ADVP.actsubcefs
                              END
                              ELSE BEGIN
				 actsubcefsvar  := %ADVP.actsubcefs;
				 aspectvar      := %ADVP.aspect;
				 classvar       := %ADVP.class;
				 moodvar        := %ADVP.mood;
				 retrovar       := %ADVP.retro;
                                 temporalvar    := %ADVP.temporal;
                                 Qstatusvar     := %ADVP.Qstatus
                              END;
                              iterationfound := true;
                            END
       *>

3: 
       <*
         LOCALCONDITION: %COORD.iteration                            
         GLOBAL: #CONDITION: (((NOT corr1found) <=
                               ( (ppc IN %COORD.patterns) AND
                                 (simple IN %COORD.kinds)
                               ) 
                              )                                           AND
                              ( corr1found <=
                                 (( %COORD.key = expkey) AND
                                  ( correlative2 IN %COORD.kinds)
                                 )
                              )                                           AND
                              (NOT itcommafound)
                             )
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              IF (NOT corr1found) THEN expkey := %COORD.key;
                              itcoordfound := true;
                            END
       *>

4: 
       <*
         LOCALCONDITION: %PUNC.key = KEY_kommaPUNCkey
         GLOBAL: #CONDITION: (NOT itcoordfound)
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              itcommafound := true;
                            END
       *>


5: 
       <*
         LOCALCONDITION: (%ADVP.coord = nocoord) 
         GLOBAL: #CONDITION: (iterationfound <=
                              ((%ADVP.actsubcefs * actsubcefsvar  <> []) AND
                               (%ADVP.aspect = aspectvar)                AND
                               (%ADVP.class = classvar)                  AND
                               (%ADVP.mood = moodvar)                    AND
                               (%ADVP.retro = retrovar)                  AND
                               (%AdvP.temporal = temporalvar)            AND
                               (%ADVP.Qstatus = Qstatusvar)     
                              )
                             )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              IF iterationfound THEN BEGIN
                                actsubcefsvar  := 
                                       actsubcefsvar * %ADVP.actsubcefs
                              END
                              ELSE BEGIN
				 actsubcefsvar  := %ADVP.actsubcefs;
				 aspectvar      := %ADVP.aspect;
				 classvar       := %ADVP.class;
				 moodvar        := %ADVP.mood;
				 retrovar       := %ADVP.retro;
                                 temporalvar    := %ADVP.temporal;
                                 qstatusvar     := %ADVP.qstatus
                              END;
                            END
       *>

6: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (((NOT corr1found) <=
                               ( (ppc IN %COORD.patterns) AND
                                 (simple IN %COORD.kinds)
                               ) 
                              )                                           AND
                              ( corr1found <=
                                 (( %COORD.key = expkey) AND
                                  ( correlative2 IN %COORD.kinds)
                                 )
                              )                                           AND
                              (itcoordfound <= 
                                ((%COORD.key=expkey) AND
                                 (ppc IN %COORD.patterns)
                                )
                              )
                             )       
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              iterationok := %COORD.iteration;
                              IF (simple IN %COORD.kinds) AND
                                 (coordpar = nocoord) THEN
                                coordpar := simplecoord;
                            END
       *>


7: 
       <*
         LOCALCONDITION: (%ADVP.coord = nocoord) 
         GLOBAL: #CONDITION:  ((%ADVP.actsubcefs * actsubcefsvar  <> []) AND
                               (%ADVP.aspect = aspectvar)                AND
                               (%ADVP.class = classvar)                  AND
                               (%ADVP.mood = moodvar)                    AND
                               (%ADVP.retro = retrovar)                  AND
                               (%AdvP.temporal = temporalvar)            AND
                               (%ADVP.Qstatus = Qstatusvar)     
                              )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              actsubcefsvar  := 
                                       actsubcefsvar * %ADVP.actsubcefs;
                            END
       *>


HFINAL: #CONDITION: iterationfound <= iterationok
        #ACTION: BEGIN
                    MAKET_ADVP;
		    $ADVP.req         := reqvar;
		    $ADVP.env         := envvar;
		    $ADVP.actsubcefs  := actsubcefsvar;
		    $ADVP.mood        := moodvar;
		    $ADVP.advpatternefs := [];
		    $ADVP.class       := classvar;
		    $ADVP.deixis      := deixisvar;
		    $ADVP.aspect      := aspectvar;
		    $ADVP.retro       := retrovar;
		    $ADVP.superdeixis := omegadeixis;
		    $ADVP.thetaadv    := omegathetaadv;
                    $ADVP.Qstatus     := Qstatusvar;
                    $ADVP.temporal    := temporalvar;
                    $ADVP.possnietnp  := false;
                    $ADVP.radvb       := false;
                    $ADVP.thanas      := thanasvar;
                    $ADVP.thanascompl := thanascomplvar;
                    $ADVP.coord       := coordpar;
                  END
*>
END;
& 





%ADJPcoord
REGULAREXPRESSION:
 
ADJP = [COORD/1] .{ADJP/2 .(COORD/3 | PUNC/4)} .ADJP/5 .COORD/6 .ADJP/7

CONDITIONSANDACTIONS:

VAR  
    reqvar           :: polarityEFFSETtype;
    envvar           :: polarityEFFSETtype;
    classvar         :: timeadvclasstype;
    deixisvar        :: deixistype;
    aspectvar        :: aspecttype;
    retrovar         :: retrotype;
    actuseefsvar     ::: adjuseEFFSETtype;
    eformationvar    :: eFormationtype;
    enominalisedvar  :: enominalisedtype;
    formvar          ::: adjadvFormtype;
    eORenFormvar     :: eORenFormtype;
    temporalvar      :: temporaltype;
    actsubcefsvar    :: adjsubcEFFSETtype;
    thetaadjvar      :: thetaadjtype;
    adjpatternefsvar :: synpatternEFFSETtype;
    reflexivityvar   :: reflexivetype;
    moodvar          ::: xpmoodtype;
    coordpar         :: coordtype;
    corr1found       ::: BOOLEAN;
    expkey           ::: keytype;
    itcommafound     ::: BOOLEAN;
    itcoordfound     ::: BOOLEAN;
    iterationfound   ::: BOOLEAN;
    iterationok      ::: BOOLEAN;



<* 

HINIT: BEGIN
    reqvar           := [pospol, negpol, omegapol];
    envvar           := [pospol, negpol, omegapol];
    classvar         := omegatimeadvclass;
    deixisvar        := omegadeixis;
    aspectvar        := omegaaspect;
    retrovar         := false;
    actuseefsvar     := [];
    eformationvar    := RegEformation;
    enominalisedvar  := Regenominalised;
    formvar          := positive;
    eORenFormvar     := NoForm;
    temporalvar      := false;
    actsubcefsvar    := [otheradj];
    thetaadjvar      := omegathetaadjp;
    adjpatternefsvar := [];
    reflexivityvar   := notreflexive;
    moodvar          := declxpmood;
    coordpar         := nocoord;
    corr1found       := false;
    expkey           := 0;
    itcommafound     := false;
    itcoordfound     := false;
    iterationfound   := false;
    iterationok      := true;
       END;
 

1: 
       <*
         LOCALCONDITION: (correlative1 IN %COORD.kinds) AND
                         (apc IN %COORD.patterns)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              corr1found := true;
                              expkey     := %COORD.correlative2key;
                              iterationok := %COORD.iteration;
                              coordpar   := corrcoord;
                            END
       *>
 


2: 
       <*
         LOCALCONDITION: (%ADJP.coord = nocoord) 
         GLOBAL: #CONDITION: iterationok                                     AND
                             (iterationfound <=
                              ((%ADJP.actuseefs * actuseefsvar <> []) AND
                               (%ADJp.mood = moodvar)                 AND
                               (%ADJP.form = formvar)
                              )
                             )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              IF iterationfound THEN BEGIN
                                 actuseefsvar := actuseefsvar * %ADJP.actuseefs
                              END
                              ELSE BEGIN
                                   actuseefsvar := %ADJP.actuseefs;
                                   moodvar      := %ADJP.mood;
                                   formvar      := %ADJP.form
                              END;
                              iterationfound := true;
                            END
       *>

3: 
       <*
         LOCALCONDITION: %COORD.iteration                            
         GLOBAL: #CONDITION: (((NOT corr1found) <=
                               ( (apc IN %COORD.patterns) AND
                                 (simple IN %COORD.kinds)
                               ) 
                              )                                           AND
                              ( corr1found <=
                                 (( %COORD.key = expkey) AND
                                  ( correlative2 IN %COORD.kinds)
                                 )
                              )                                           AND
                              (NOT itcommafound)
                             )
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              IF (NOT corr1found) THEN expkey := %COORD.key;
                              itcoordfound := true;
                            END
       *>

4: 
       <*
         LOCALCONDITION: %PUNC.key = KEY_kommaPUNCkey
         GLOBAL: #CONDITION: (NOT itcoordfound)
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              itcommafound := true;
                            END
       *>


5: 
       <*
         LOCALCONDITION: (%ADJP.coord = nocoord) 
         GLOBAL: #CONDITION: (iterationfound <=
                              ((%ADJP.actuseefs * actuseefsvar <> []) AND
                               (%ADJp.mood = moodvar)                 AND
                               (%ADJP.form = formvar)
                              )
                             )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              IF iterationfound THEN BEGIN
                                 actuseefsvar := actuseefsvar * %ADJP.actuseefs
                              END
                              ELSE BEGIN
                                   actuseefsvar := %ADJP.actuseefs;
                                   moodvar      := %ADJP.mood;
                                   formvar      := %ADJP.form
                              END;
                            END
       *>

6: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (((NOT corr1found) <=
                               ( (apc IN %COORD.patterns) AND
                                 (simple IN %COORD.kinds)
                               ) 
                              )                                           AND
                              ( corr1found <=
                                 (( %COORD.key = expkey) AND
                                  ( correlative2 IN %COORD.kinds)
                                 )
                              )                                           AND
                              (itcoordfound <= 
                                ((%COORD.key=expkey) AND
                                 (apc IN %COORD.patterns)
                                )
                              )
                             )       
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              iterationok := %COORD.iteration;
                              IF (simple IN %COORD.kinds) AND
                                 (coordpar = nocoord) THEN
                                coordpar := simplecoord;
                            END
       *>


7: 
       <*
         LOCALCONDITION: (%ADJP.coord = nocoord) 
         GLOBAL: #CONDITION:  ((%ADJP.actuseefs * actuseefsvar <> []) AND
                               (%ADJp.mood = moodvar)                 AND
                               (%ADJP.form = formvar)
                              )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                            END
       *>


HFINAL: #CONDITION: iterationfound <= iterationok
        #ACTION: BEGIN
                    MAKET_ADJP;
                    $ADJP.req           := reqvar;
                    $ADJP.env           := envvar;           
                    $ADJP.class         := classvar;
                    $ADJP.deixis        := deixisvar;
                    $ADJP.aspect        := aspectvar;
                    $ADJP.retro         := retrovar;
                    $ADJP.actuseefs     := actuseefsvar;
                    $ADJP.eformation    := eformationvar;
                    $ADJP.enominalised  := enominalisedvar;
                    $ADJP.form          := formvar;
                    $ADJP.eORenform     := eORenFormvar;
                    $ADJP.temporal      := temporalvar;
                    $ADJP.actsubcefs    := actsubcefsvar;
                    $ADJP.thetaadj      := thetaadjvar;
                    $ADJP.adjpatternefs := adjpatternefsvar;
                    $ADJP.reflexivity   := reflexivityvar;
                    $ADJP.mood          := moodvar;
                    $ADJP.coord         := coordpar;
                  END
*>
END;
& 



!(*
X means: incorporated
Xtemporal attributes: if they are the same for all conjuncts, then
 copy them, otherwise set these to default values (temporal: false)
Xdefinite: def overrules indef, adef
Xperson: 1 overrules 2,4,5; 2,4,5 win over 3
Xnumber: computenumber
Xcases: intersection niet leeg
Xgenders: [omegagender]
Xsexes: []
Xactsubcs: intersection if not empty; plurunitnoun if unit/plurunit; empty
              otherwise
Xpossgeni: false overrules true
Xanimate: noanimate overrules animate
Xhuman: nohuman overrules yeshuman
Xactcomas: intersection if not empty otherwise []
Xthetanp: omegathetanp
Xnounpatternefs:[]
Xposspred: false overrules true
Xpossnietnp: false overrules true
Xmood: must be equal
Xgeneric: omegageneric
XpossRform: irrelevant
Xsyntquant: omegaquant overrules Aquant overrules Equant
XNPhead: otherNP
Xspecq: special function!!
*)


%NPcoord
REGULAREXPRESSION:
 
NP = [COORD/1] .{NP/2 .(COORD/3 | PUNC/4)} .NP/5 .COORD/6 .NP/7

CONDITIONSANDACTIONS:

VAR  
    reqvar              :: polarityEFFSETtype;
    envvar              :: polarityEFFSETtype;
    superdeixisvar      :: deixistype;
    classvar            :: timeadvclasstype;
    deixisvar           :: deixistype;
    aspectvar           :: aspecttype;
    retrovar            :: retrotype;
    definitevar         :: deftype;
    personvar           :: persontype;
    numbervar           ::: numbertype;
    casesvar            ::: caseSETtype;
    gendersvar          :: genderSETtype;
    sexesvar            :: sexSETtype;
    actsubcsvar         :: nounsubcEFFSETtype;
    temporalvar         :: temporaltype;
    possgenivar         :: possgenitype;
    animatevar          :: animatetype;
    humanvar            :: humantype;
    actcomasvar         :: posscomaSETtype;
    thetanpvar          :: thetanptype;
    nounpatternefsvar   :: synpatternEFFSETtype;
    posspredvar         :: posspredtype;
    possnietnpvar       :: possnietnptype;
    moodvar             ::: xpmoodtype;
    genericvar          :: generictype;
    possRformvar        :: possRformtype;
    syntquantvar        :: syntquanttype;
    NPheadvar           :: NPheadtype;
    specQvar            :: specQtype;
    coordpar            :: coordtype;
    corr1found          ::: BOOLEAN;
    expkey              ::: keytype;
    inducednumbersvar   ::: numberSETtype;
    itcommafound        ::: BOOLEAN;
    itcoordfound        ::: BOOLEAN;
    iterationfound      ::: BOOLEAN;
    iterationok         ::: BOOLEAN;
?
HELP

PROCEDURE assqmax(s1::specqtype; VAR s2::specqtype);
BEGIN
  IF s1 = yesspec THEN s2 := s1;
END !(*assqmax*);

PROCEDURE compactcomas(acs::posscomaSETtype; VAR acsv::posscomaSETtype);
BEGIN
  IF   (acs * acsv <> []) THEN acsv := acsv * acs
  ELSE acsv := [];
END !(*compactcomas*);

PROCEDURE companimate(h::animatetype; VAR hv::animatetype);
BEGIN
  IF   (h = noanimate) OR (hv = noanimate) THEN hv := noanimate
  ELSE hv := yesanimate;
END !(*companimate*);

PROCEDURE compdef(d::deftype; VAR dv::deftype);
BEGIN
  IF       (d = def)    OR (dv = def)  THEN dv := def
  ELSE IF  (d = adef)   OR (dv = adef) THEN dv := adef
  ELSE dv := indef;
END !(*compdef*);

PROCEDURE comphuman(h::humantype; VAR hv::humantype);
BEGIN
  IF   (h = nohuman) OR (hv = nohuman) THEN hv := nohuman
  ELSE hv := yeshuman;
END !(*comphuman*);

PROCEDURE comppers(p::persontype; VAR pv::persontype);
BEGIN
  IF       (p = 1) OR (pv = 1)               THEN pv :=1
  ELSE IF  (p IN [2,4,5]) OR (pv IN [2,4,5]) THEN pv :=2
  ELSE pv :=3;
END !(*comppers*);

PROCEDURE comppossgeni(pg::possgenitype; VAR pgv::possgenitype);
BEGIN
IF   (pg = false) OR (pgv = false) THEN pgv := false
ELSE pgv := true;
END !(*comppossgeni*);


PROCEDURE comppossnietnp(pn::possnietnptype; VAR pnv::possnietnptype);
BEGIN
IF   (pn = false) OR (pnv = false) THEN pnv := false
ELSE pnv := true;
END !(*comppossnietnp*);

PROCEDURE compposspred(p::posspredtype; VAR pv::posspredtype);
BEGIN
IF   (p = false) OR (pv = false) THEN pv := false
ELSE pv := true;
END !(*compposspred*);


PROCEDURE compsyntquant(s::syntquanttype; VAR sv::syntquanttype);
BEGIN
  IF      (s = omegaquant) OR (sv = omegaquant) THEN sv := omegaquant
  ELSE IF (s = Aquant) OR (sv = Aquant)         THEN sv := Aquant
  ELSE sv := Equant;
END !(*compsyntquant*);

PROCEDURE comptemp(
    VAR temporalvar :: temporaltype;
    VAR classvar    :: timeadvclasstype;
    VAR deixisvar   :: deixistype;
    VAR retrovar    :: retrotype;
    VAR aspectvar   :: aspecttype
);
BEGIN
  IF   (%NP.temporal = temporalvar) AND
       (%NP.class    = classvar)    AND
       (%NP.deixis   = deixisvar)   AND
       (%NP.retro    = retrovar)    AND
       (%NP.aspect   = aspectvar)
  THEN BEGIN 
    temporalvar := %NP.temporal;
    classvar    := %NP.class;
    deixisvar   := %NP.deixis;
    retrovar    := %NP.retro;
    aspectvar   := %NP.aspect;
  END
  ELSE BEGIN
    temporalvar := false;
    classvar    := omegatimeadvclass;
    deixisvar   := omegadeixis;
    retrovar    := false;
    aspectvar   := omegaAspect;
  END;
END!(*comptemp*);
?


<* 

HINIT: BEGIN
    reqvar              := [pospol, omegapol, negpol];
    envvar              := [pospol, omegapol, negpol];
    superdeixisvar      := omegadeixis;
    classvar            := omegatimeadvclass;
    deixisvar           := omegadeixis;
    aspectvar           := omegaaspect;
    retrovar            := false;
    definitevar         := omegadef;
    personvar           := 3;
    numbervar           := omeganumber;
    casesvar            := [];
    gendersvar          := [];
    sexesvar            := [];
    actsubcsvar         := [];
    temporalvar         := false;
    possgenivar         := false;
    animatevar          := omegaanimate;
    humanvar            := omegahuman;
    actcomasvar         := [];
    thetanpvar          := omegathetanp;
    nounpatternefsvar   := [];
    posspredvar         := false;
    possnietnpvar       := false;
    moodvar             := declxpmood;
    genericvar          := omegageneric;
    possRformvar        := false;
    syntquantvar        := omegaquant;
    NPheadvar           := otherNP;
    specQvar            := omegaspec;
    coordpar            := nocoord;
    corr1found          := false;
    expkey              := 0;
    inducednumbersvar   := [];
    itcommafound        := false;
    itcoordfound        := false;
    iterationfound      := false;
    iterationok         := true;
       END;
 

1: 
       <*
         LOCALCONDITION: (correlative1 IN %COORD.kinds) AND
                         (npc IN %COORD.patterns)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              corr1found := true;
                              expkey     := %COORD.correlative2key;
                              iterationok := %COORD.iteration;
                              coordpar   := corrcoord;
                            END
       *>
 


2: 
       <*
         LOCALCONDITION: (%NP.coord = nocoord) AND
                         NOT (%NP.NPhead IN [hetNP,jegenNP,zegenNP,
                                      reducedpersproNP])
         GLOBAL: #CONDITION: iterationok                                     AND
                             (iterationfound <=
                              ((%NP.cases * casesvar <> []) AND
                               (%NP.mood = moodvar) 
                              )
                             )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              IF iterationfound THEN BEGIN
                                 casesvar := casesvar * %NP.cases;
                              END
                              ELSE BEGIN
                                   moodvar := %NP.mood;
                                   casesvar := %NP.cases
                              END;
                              !(* boven item parameters, onder non-item 
                                  paramers, rene 11-4-90 *)
                              IF iterationfound THEN BEGIN
				 comppossgeni(%NP.possgeni, possgenivar );
				 comphuman(%NP.human, humanvar );
				 compposspred(%NP.posspred, posspredvar );
				 comppossnietnp(%NP.possnietnp, possnietnpvar );
				 compsyntquant(%NP.syntquant, syntquantvar );
				 assqmax(%NP.specq, specqvar );
				 companimate(%NP.animate, animatevar );
				 compactcomas(%NP.actcomas, actcomasvar );
                                 compdef(%NP.definite, definitevar );
                                 comppers(%NP.person, personvar );
				 compnumber( numbervar,
                                             inducednumbersvar,
                                             b
                                           );
                                 comptemp(
                                        temporalvar, classvar , deixisvar ,
                                        retrovar , aspectvar
                                         );
                              END
                              ELSE BEGIN
                                   possgenivar   := %NP.possgeni;
                                   humanvar      := %NP.human;
                                   posspredvar   := %NP.posspred;
                                   possnietnpvar := %NP.possnietnp;
                                   syntquantvar  := %NP.syntquant;
                                   specqvar      := %NP.specq;
                                   animatevar    := %NP.animate;
                                   actcomasvar   := %NP.actcomas;
                                   numbervar     := %NP.number;
                                   temporalvar   := %NP.temporal;
                                   deixisvar     := %NP.deixis;
                                   aspectvar     := %NP.aspect;
                                   classvar      := %NP.class;
                                   definitevar   := %NP.definite;
                                   personvar     := %NP.person;
                                   retrovar      := %NP.retro;
                              END;
                              iterationfound := true;
                            END
       *>

3: 
       <*
         LOCALCONDITION: %COORD.iteration                            
         GLOBAL: #CONDITION: (((NOT corr1found) <=
                               ( (npc IN %COORD.patterns) AND
                                 (simple IN %COORD.kinds)
                               ) 
                              )                                           AND
                              ( corr1found <=
                                 (( %COORD.key = expkey) AND
                                  ( correlative2 IN %COORD.kinds)
                                 )
                              )                                           AND
                              (NOT itcommafound)
                             )
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              IF (NOT corr1found) THEN expkey := %COORD.key;
                              itcoordfound := true;
                              inducednumbersvar:=%COORD.inducednumbers;
                            END
       *>

4: 
       <*
         LOCALCONDITION: %PUNC.key = KEY_kommaPUNCkey
         GLOBAL: #CONDITION: (NOT itcoordfound)
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              itcommafound := true;
                            END
       *>


5: 
       <*
         LOCALCONDITION: (%NP.coord = nocoord)  AND
                         NOT (%NP.NPhead IN [hetNP,jegenNP,zegenNP,
                                      reducedpersproNP])
         GLOBAL: #CONDITION: (iterationfound <=
                              ((%NP.cases * casesvar <> []) AND
                               (%NP.mood = moodvar)
                              )
                             )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              IF iterationfound THEN BEGIN
                                 casesvar := casesvar * %NP.cases;
                              END
                              ELSE BEGIN
                                   moodvar := %NP.mood;
                                   casesvar := %NP.cases
                              END;
                              !(* boven item parameters, onder non-item 
                                  paramers, rene 11-4-90 *)
                              IF iterationfound THEN BEGIN
				 comppossgeni(%NP.possgeni, possgenivar);
				 comphuman(%NP.human, humanvar);
				 compposspred(%NP.posspred, posspredvar);
				 comppossnietnp(%NP.possnietnp, possnietnpvar);
				 compsyntquant(%NP.syntquant, syntquantvar);
				 assqmax(%NP.specq, specqvar);
				 companimate(%NP.animate, animatevar);
				 compactcomas(%NP.actcomas, actcomasvar);
                                 compdef(%NP.definite, definitevar);
                                 comppers(%NP.person, personvar);
				 compnumber( numbervar,
                                             inducednumbersvar,
                                             b
                                           );
                                 comptemp(
                                        temporalvar, classvar , deixisvar ,
                                        retrovar , aspectvar
                                         );
                              END
                              ELSE BEGIN
                                   possgenivar   := %NP.possgeni;
                                   humanvar      := %NP.human;
                                   posspredvar   := %NP.posspred;
                                   possnietnpvar := %NP.possnietnp;
                                   syntquantvar  := %NP.syntquant;
                                   specqvar      := %NP.specq;
                                   animatevar    := %NP.animate;
                                   actcomasvar   := %NP.actcomas;
                                   numbervar     := %NP.number;
                                   temporalvar   := %NP.temporal;
                                   deixisvar     := %NP.deixis;
                                   aspectvar     := %NP.aspect;
                                   classvar      := %NP.class;
                                   definitevar   := %NP.definite;
                                   personvar     := %NP.person;
                                   retrovar      := %NP.retro;
                              END;
                            END
       *>

6: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (((NOT corr1found) <=
                               ( (npc IN %COORD.patterns) AND
                                 (simple IN %COORD.kinds)
                               ) 
                              )                                           AND
                              ( corr1found <=
                                 (( %COORD.key = expkey) AND
                                  ( correlative2 IN %COORD.kinds)
                                 )
                              )                                           AND
                              (itcoordfound <= 
                                ((%COORD.key=expkey) AND
                                 (npc IN %COORD.patterns)
                                )
                              )
                             )       
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              iterationok := %COORD.iteration;
                              IF (simple IN %COORD.kinds) AND
                                 (coordpar = nocoord) THEN
                                coordpar := simplecoord;
                              IF (NOT itcoordfound) 
                              THEN 
                                inducednumbersvar := %COORD.inducednumbers;
                            END
       *>


7: 
       <*
         LOCALCONDITION: (%NP.coord = nocoord)  AND
                         NOT (%NP.NPhead IN  [hetNP,jegenNP,zegenNP,
                                      reducedpersproNP])
         GLOBAL: #CONDITION:  ((%NP.cases * casesvar <> []) AND
                               (%NP.mood = moodvar)
                              )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              casesvar := casesvar * %NP.cases;
			      comppossgeni(%NP.possgeni, possgenivar);
			      comphuman(%NP.human, humanvar);
			      compposspred(%NP.posspred, posspredvar);
			      comppossnietnp(%NP.possnietnp, possnietnpvar);
			      compsyntquant(%NP.syntquant, syntquantvar);
			      assqmax(%NP.specq, specqvar);
			      companimate(%NP.animate, animatevar);
			      compactcomas(%NP.actcomas, actcomasvar);
			      compdef(%NP.definite, definitevar);
			      comppers(%NP.person, personvar);
		              compnumber( numbervar,
                                          inducednumbersvar,
                                          b
                                        );
                              comptemp(
                                       temporalvar, classvar , deixisvar ,
                                       retrovar , aspectvar
                                      );
                            END
       *>


HFINAL: #CONDITION: iterationfound <= iterationok
        #ACTION: BEGIN
                    MAKET_NP;
                    $NP.req            := reqvar;
                    $NP.env            := envvar;
                    $NP.superdeixis    := superdeixisvar;
                    $NP.class          := classvar;
                    $NP.deixis         := deixisvar;
                    $NP.aspect         := aspectvar;
                    $NP.retro          := retrovar;
                    $NP.definite       := definitevar;
                    $NP.person         := personvar;
                    $NP.number         := numbervar;
                    $NP.cases          := casesvar;
                    $NP.genders        := gendersvar;
                    $NP.sexes          := sexesvar;
                    $NP.actsubcs       := actsubcsvar;
                    $NP.temporal       := temporalvar;
                    $NP.possgeni       := possgenivar;
                    $NP.animate        := animatevar;
                    $NP.human          := humanvar;
                    $NP.actcomas       := actcomasvar;
                    $NP.thetanp        := thetanpvar;
                    $NP.nounpatternefs := nounpatternefsvar;
                    $NP.posspred       := posspredvar;
                    $NP.possnietnp     := possnietnpvar;
                    $NP.mood           := moodvar;
                    $NP.generic        := genericvar;
                    $NP.possRform      := possRformvar;
                    $NP.syntquant      := syntquantvar;
                    $NP.NPhead         := NPheadvar;
                    $NP.specQ          := specQvar;
                    $NP.coord          := coordpar;
                  END
*>
END;
& 



%Scoord
REGULAREXPRESSION:
 
SENTENCE = [COORD/1] .{SENTENCE/2 .(COORD/3 | PUNC/4)} .SENTENCE/5 
             .COORD/6 .SENTENCE/7

CONDITIONSANDACTIONS:

VAR  
                   reqvar::polarityEFFSETtype;
                   envvar::polarityEFFSETtype;
                   moodvar:::moodtype;
                   senttypevar:::senttypetype;
		   voicevar::voicetype;
                   PROsubjectvar:::PROsubjecttype;
		   synvpefsvar::synpatternEFFSETtype;
                   thetavpvar::thetavptype;
                   modusvar:::modustype;
                   aktionsartsvar::aktionsartEFFSETtype;
                   aspectvar::aspecttype;
                   deixisvar::deixistype;
                   retrovar::retrotype;
                   finitenessvar:::finitenesstype;
                   infsortvar:::inftype;
                   superdeixisvar:::deixistype;
                   VRcomplvar:::VRcompltype;
                   conjkeyvar::keytype;
                   adverbialvar:::adverbialtype;
                   temporalvar:::temporaltype;
                   conjclassvar:::timeadvclasstype;
                   conjdeixisvar:::deixistype;
                   conjaspectvar:::aspecttype;
                   conjretrovar:::retrotype;
                   coordpar    :: coordtype;
                   corr1found          ::: BOOLEAN;
                   expkey              ::: keytype;
                   itcommafound        ::: BOOLEAN;
                   itcoordfound        ::: BOOLEAN;
                   iterationfound      ::: BOOLEAN;
                   iterationok         ::: BOOLEAN;
                   cpvar         ::coordpatternsettype;
?
HELP

PROCEDURE reducepatterns(VAR cpvar::coordpatternsettype);
BEGIN
  IF senttypevar = mainclause THEN cpvar := cpvar * [Smdc,Smync,Smwhc, Simpc, 
                                                     Slaten ];
  IF senttypevar = subordinateclause THEN cpvar := cpvar * [Ssdc,Ssync,Sswhc,
                         Simpc, Srelfinc, Somtec, Sotec, Sctec,Sprpc, Spapc,
                         Scond];
  IF moodvar = declarative THEN cpvar := cpvar * [Smdc,Ssdc,
                    Somtec, Sotec, Sctec,Sprpc, Spapc ];
  IF moodvar = yesnointerrogative THEN cpvar := cpvar * [Smync,Ssync];
  IF moodvar = whinterrogative THEN cpvar := cpvar * [Smwhc,Sswhc];
  IF moodvar = conditional THEN cpvar := cpvar * [Scond];
  IF moodvar = latenmood THEN cpvar := cpvar * [Slaten];
  IF moodvar = relative THEN cpvar := cpvar * [Srelfinc];
  IF modusvar = prespart THEN cpvar := cpvar * [Sprpc];
  IF modusvar = pastpart THEN cpvar := cpvar * [Spapc];
  IF infsortvar IN [teinf,omteinf] THEN cpvar := cpvar * [Somtec,Sotec,Sctec];
  IF infsortvar IN [omteinf] THEN cpvar := cpvar * [Somtec];
  IF prosubjectvar = TRUE THEN cpvar := cpvar * [Somtec,Sotec, Sprpc,Spapc];
  IF prosubjectvar = FALSE THEN cpvar := cpvar * [Smdc,Smync,Smwhc, Ssdc,Ssync,Sswhc,
                         Simpc, Srelfinc, Sctec,Sprpc, Spapc, Scond, Slaten ]
END;
?

<* 

HINIT: BEGIN

                   reqvar          := [pospol, negpol, omegapol];
                   envvar          := [pospol, negpol, omegapol];
                   moodvar         := omegamood;
                   senttypevar     := omegaclause;
		   voicevar        := omegavoice;
                   PROsubjectvar   := false;
		   synvpefsvar     := [];
                   thetavpvar      := omegathetavp;
                   modusvar        := omegamodus;
                   aktionsartsvar  := [];  
                   aspectvar       := omegaAspect;
                   deixisvar       := omegadeixis; 
                   retrovar        := false;
                   finitenessvar   := omegafin;
                   infsortvar      := omegainf;        
                   superdeixisvar  := omegadeixis;
                   VRcomplvar      := false;
                   conjkeyvar      := 0;
                   adverbialvar    := false;
                   temporalvar     := false;
                   conjclassvar    := omegaTimeAdvClass;
                   conjdeixisvar   := omegadeixis;
                   conjaspectvar   := omegaAspect;
                   conjretrovar    := false;
		   coordpar            := nocoord;
		   corr1found          := false;
		   expkey              := 0;
		   itcommafound        := false;
		   itcoordfound        := false;
		   iterationfound      := false;
		   iterationok         := true;
                   cpvar               := []
       END;
 

1: 
       <*
         LOCALCONDITION: (correlative1 IN %COORD.kinds) AND
                         (%COORD.patterns * (AUX_coordVfcps+ AUX_coordV2cps)<>[])
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              corr1found := true;
                              expkey     := %COORD.correlative2key;
                              iterationok := %COORD.iteration;
                              coordpar   := corrcoord;
                              cpvar   := %COORD.patterns * 
                                          (AUX_coordVfcps+ AUX_coordV2cps)
                            END
       *>
 


2: 
       <*
         LOCALCONDITION: (%SENTENCE.coord = nocoord) 
         GLOBAL: #CONDITION: iterationok                                     AND
                             (iterationfound <=
				(
				 (moodvar        = %SENTENCE.mood)       AND
				 (senttypevar    = %SENTENCE.senttype)   AND
				 (PROsubjectvar  = %SENTENCE.PROsubject) AND
				 (modusvar       = %SENTENCE.modus)      AND
				 (finitenessvar  = %SENTENCE.finiteness) AND
				 (infsortvar     = %SENTENCE.infsort)    AND
				 (VRcomplvar     = %SENTENCE.VRcompl)    AND
				 (adverbialvar   = %SENTENCE.adverbial)  AND
				 (temporalvar    = %SENTENCE.temporal)   AND
				 (superdeixisvar = %SENTENCE.superdeixis)AND
			         (conjclassvar= %SENTENCE.conjclass)    AND
			         (conjdeixisvar = %SENTENCE.conjdeixis)  AND
			         (conjaspectvar = %SENTENCE.conjaspect)  AND
			         (conjretrovar = %SENTENCE.conjretro)    
				)
                             )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              IF (NOT iterationfound) THEN BEGIN
                                moodvar        := %SENTENCE.mood            ;
                                senttypevar    := %SENTENCE.senttype        ;
                                PROsubjectvar  := %SENTENCE.PROsubject      ;
                                modusvar       := %SENTENCE.modus           ;
                                finitenessvar  := %SENTENCE.finiteness      ;
                                infsortvar     := %SENTENCE.infsort         ;
                                VRcomplvar     := %SENTENCE.VRcompl         ;
                                adverbialvar   := %SENTENCE.adverbial       ;
                                temporalvar    := %SENTENCE.temporal        ;
                                superdeixisvar := %SENTENCE.superdeixis     
                              END;
                              IF (NOT iterationfound) THEN
                                   cpvar  := (AUX_coordVfcps+ AUX_coordV2cps);
                              reducepatterns(cpvar);

                              iterationfound := true
                            END
       *>
3: 
       <*
         LOCALCONDITION: %COORD.iteration                            
         GLOBAL: #CONDITION: (((NOT corr1found) <=
                               ( (%COORD.patterns * 
                                   (AUX_coordVfcps+ AUX_coordV2cps)<>[]) AND
                                 (simple IN %COORD.kinds)
                               ) 
                              )                                           AND
                              ( corr1found <=
                                 (( %COORD.key = expkey) AND
                                  ( correlative2 IN %COORD.kinds)
                                 )
                              )                                           AND
                              (NOT itcommafound)
                             )
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              IF (NOT corr1found) THEN BEGIN
                                 expkey := %COORD.key
                              END;
                              IF (NOT corr1found) THEN BEGIN
                                 cpvar := (AUX_coordVfcps+ AUX_coordV2cps)
                              END;
                              itcoordfound := true;
                              reducepatterns(cpvar);
                            END
       *>

4: 
       <*
         LOCALCONDITION: %PUNC.key = KEY_kommaPUNCkey
         GLOBAL: #CONDITION: (NOT itcoordfound)
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              itcommafound := true
                            END
       *>


5: 
       <*
         LOCALCONDITION: (%SENTENCE.coord = nocoord)
         GLOBAL: #CONDITION: (iterationfound <=
				(
				 (moodvar        = %SENTENCE.mood)       AND
				 (senttypevar    = %SENTENCE.senttype)   AND
				 (PROsubjectvar  = %SENTENCE.PROsubject) AND
				 (modusvar       = %SENTENCE.modus)      AND
				 (finitenessvar  = %SENTENCE.finiteness) AND
				 (infsortvar     = %SENTENCE.infsort)    AND
				 (VRcomplvar     = %SENTENCE.VRcompl)    AND
				 (adverbialvar   = %SENTENCE.adverbial)  AND
				 (temporalvar    = %SENTENCE.temporal)   AND
				 (superdeixisvar = %SENTENCE.superdeixis)AND
			         (conjclassvar= %SENTENCE.conjclass)    AND
			         (conjdeixisvar = %SENTENCE.conjdeixis)  AND
			         (conjaspectvar = %SENTENCE.conjaspect)  AND
			         (conjretrovar = %SENTENCE.conjretro)    
				)
                             )
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              IF iterationfound THEN BEGIN
                              END
                              ELSE BEGIN
                                moodvar        := %SENTENCE.mood            ;
                                senttypevar    := %SENTENCE.senttype        ;
                                PROsubjectvar  := %SENTENCE.PROsubject      ;
                                modusvar       := %SENTENCE.modus           ;
                                finitenessvar  := %SENTENCE.finiteness      ;
                                infsortvar     := %SENTENCE.infsort         ;
                                VRcomplvar     := %SENTENCE.VRcompl         ;
                                adverbialvar   := %SENTENCE.adverbial       ;
                                temporalvar    := %SENTENCE.temporal        ;
                                superdeixisvar := %SENTENCE.superdeixis     
                              END;
                            END
       *>

6: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (((NOT corr1found) <=
                               ( ((%COORD.patterns * 
                                   (AUX_coordVfcps+ AUX_coordV2cps)<>[])) AND
                                 (simple IN %COORD.kinds)
                               ) 
                              )                                           AND
                              ( corr1found <=
                                 (( %COORD.key = expkey) AND
                                  ( correlative2 IN %COORD.kinds)
                                 )
                              )                                           AND
                              (itcoordfound <= 
                                ((%COORD.key=expkey) AND
                                 (%COORD.patterns * 
                                   (AUX_coordVfcps+ AUX_coordV2cps)<>[])
                                )
                              )
                             )       
                 #ACTION:   BEGIN
                              SYNREL := conjrel;
                              iterationok := %COORD.iteration;
                              IF (simple IN %COORD.kinds) AND
                                 (coordpar = nocoord) THEN
                                coordpar := simplecoord;
                              IF (NOT corr1found) THEN BEGIN
                                 cpvar := %COORD.patterns;
                                 reducepatterns(cpvar)
                              END
                            END
       *>


7: 
       <*
         LOCALCONDITION: (%SENTENCE.coord = nocoord) 
         GLOBAL: #CONDITION:  
				 (moodvar        = %SENTENCE.mood)       AND
				 (senttypevar    = %SENTENCE.senttype)   AND
				 (PROsubjectvar  = %SENTENCE.PROsubject) AND
				 (modusvar       = %SENTENCE.modus)      AND
				 (finitenessvar  = %SENTENCE.finiteness) AND
				 (infsortvar     = %SENTENCE.infsort)    AND
				 (VRcomplvar     = %SENTENCE.VRcompl)    AND
				 (adverbialvar   = %SENTENCE.adverbial)  AND
				 (temporalvar    = %SENTENCE.temporal)   AND
				 (superdeixisvar = %SENTENCE.superdeixis)AND
			         (conjclassvar= %SENTENCE.conjclass)    AND
			         (conjdeixisvar = %SENTENCE.conjdeixis)  AND
			         (conjaspectvar = %SENTENCE.conjaspect)  AND
			         (conjretrovar = %SENTENCE.conjretro)    
                 #ACTION:   BEGIN
                              SYNREL := argrel
                            END
       *>


HFINAL: #CONDITION: (iterationfound <= iterationok) AND
                    (cpvar * (AUX_coordVfcps+ AUX_coordV2cps)<>[])
        #ACTION: BEGIN
                   MAKET_SENTENCE;
                   $SENTENCE.req := reqvar ;
                   $SENTENCE.env := envvar ;
                   $SENTENCE.mood := moodvar;
                   $SENTENCE.senttype := senttypevar ;
		   $SENTENCE.voice := voicevar ;
                   $SENTENCE.PROsubject := PROsubjectvar ;
		   $SENTENCE.synvpefs := synvpefsvar ;
                   $SENTENCE.thetavp := thetavpvar ;
                   $SENTENCE.modus := modusvar ;
                   $SENTENCE.aktionsarts := aktionsartsvar ;
                   $SENTENCE.aspect := aspectvar ;
                   $SENTENCE.deixis := deixisvar ;
                   $SENTENCE.retro := retrovar ;
                   $SENTENCE.finiteness := finitenessvar ;
                   $SENTENCE.infsort := infsortvar ;
                   $SENTENCE.superdeixis := superdeixisvar ;
                   $SENTENCE.VRcompl := VRcomplvar ;
                   $SENTENCE.conjkey := conjkeyvar ;
                   $SENTENCE.adverbial := adverbialvar ;
                   $SENTENCE.temporal := temporalvar ;
                   $SENTENCE.conjclass := conjclassvar ;
                   $SENTENCE.conjdeixis := conjdeixisvar ;
                   $SENTENCE.conjaspect := conjaspectvar ;
                   $SENTENCE.conjretro := conjretrovar; 
                   $SENTENCE.coord := coordpar
                  END
*>
END;
& 

%%
%DUTCH
&

!(*
The following attributes of sentence have to be computed:

req            :  } by a general req/env computation strategy
env            :  }
mood           : to be computed
senttype       :  to be determined      
voice          :
PROsubject     :
synvpefs       :
thetavp        :
modus          :
aktionsarts    :
aspect         : omegaaspect
deixis         :
retro          : false
finiteness     :
infsort        :
superdeixis    :omegadeixis
VRcompl        :false


Also : conjkey:keytype!

Aspect: It never distinguishes forms in Dutch, so after the application of time rules
it is set to omegaaspect

Retro: there is no direct connection between tense, auxiliaries and retro.
It is always false in surface structures.

superdeixis: it is assumed that upon substitution the attribute superdeixis
is always set to omegadeixis, and the attribute deixis to present or past.

VRcompl: the value true is only relevant in pruned sentences, hence it will
only occur with the value false  in surface structures. 

I decided to have RADVs always dominated by RADVP, to keep track of
the kindefs, and not to have ADVPs dominating them.
Originally kindefs was taken care of in RADV itself, but that is not
correct, since RADV is also a basic category.

RADVP has a RADVPrecord with the following attributes:

headkey: keytype:0
mood   : xpmoodtype:declxpmood
kindefs: kindeffSETtype: []


*)

% SENTENCEsrule
REGULAREXPRESSION:
 
SENTENCE = [COORD/79] .[PREP/62 | PREP/71]. [LDL] .[SH] .[CPOS] .[NP/10] .M1 
             .(VERBP/11 | NOVERBP) 
            .EXTRA .[SENTENCE/76] .[ [PUNC/2] . SENTENCE/44 ] .[PUNC/75]

LDL = (SENTENCE/1. [PUNC/2])  | (SENTENCE/46 . [PUNC/15])

SH = NP/3 | PREPP/4 | ADVP/5 | ADJP/6 | RADVP/7 | RELPRO/13 | RADVP/42

CPOS = CONJ/8 | VERB/9

M1 = CLITICS .{ STADV   | ERPOS | REFLPRO/25  | ([PUNC/15] . SENTENCE/43) }

     .{ LOCADV | QADV | NEG/29 | POS/30  }
 

ERPOS = (RADVP/26. [GLUE/48]) | PREPP/27 | RADVP/28 | RADVP/47 


CLITICS = [PERSPRO/22] . [PERSPRO/23] . [PERSPRO/24] 


STADV =  ADVP/31       | PREPP/32                        |

         ADVP/33     | PREPP/34     | NP/35              |

         NP/45       |  NP/36       |  NP/37             |

         QADV                                            |
          
         ADVP/14        

LOCADV = ADVP/38     | PREPP/39    | RADVP/40             


QADV =   ADVP/41


EXTRA = { PREPP/12} . [ [PUNC/15] .SENTENCE/17] .[ [PUNC/15]. SENTENCE/16 ] 
        .[ THANP/18 | ASP/19 ] . [ [PUNC/20] . SENTENCE/21 ]



NOVERBP = SVPADVS . SCOMPLS . [PART/65 | PREP/74] . SPOSTPPS


SVPADVS = {PREPP/69 | ADVP/70 |  ADVP/72 }

SCOMPLS = ([SIO] . [SDO] . [SREST] )

SIO     = NP/49 | PREPP/50 | PREPP/51 | PREPP/66

SDO     = NP/52 | PROSENT/78

SREST   = ( SREST1  . [ PREPP/63 | PREPP/64] ) |
         ( ( PREPP/63 | PREPP/64 ). SPPS )

SREST1  = ( SPPS  | ADVP/55 | ADVP/57 | ADVP/59 | 
            NP/60 | ADJP/61 | NP/73   | VERBP/77)

SPPS    = (PREPP/53 | PREPP/54 | PREPP/56 | PREPP/58)

SPOSTPPS = {PREPP/67} . {PREPP/68}


CONDITIONSANDACTIONS:

                            !(* erposrel,26,27 *)     !(*locadvrel,def, 28*)
!(* effect  stadv  . [RADVP/26 | PREPP/27] . RADVP/29 .stadv  *)

!(*'t,22*)          !(*iocl,23*)       !(*docl,24*)      !(*reflrel,25*)
           !(*'t,22*)          !(*iocl,23*)       !(*docl,24*)      !(*reflrel,25*)
         !(*sentadv,31 *)    !(*sentadv,32 *)             !(*tempadv,33*)   
!(*tempadv,34*)    !(*tempadv,35 *)           
!(*postsubj,45*) !(*preadv,io,36*)    !(*preadv,do,37 *)
         !(*locadv,38 *)   !(*locadv,39 *)   !(*locadv, indef,40 *)   
      !(* attrib q = true,e.g. opzettelijk, 41 *)        !(*postverb,14*) 
            !(*relsent,17*)  !(*extraposrel,16*) 
          !(* thanp,asp,18,19 *)        !(* resultrel,21 *)
!(* relative clause and complement clause do not exclude each other; *)
!(*47  errel *)




VAR

      teller             : INTEGER;
      aanobjrelfound     ::BOOLEAN;
      accobjfound        ::BOOLEAN;
      adhortfound        ::BOOLEAN;
      adjpinshiftfound   ::BOOLEAN;
      adjppredrelfound   :::BOOLEAN;
      adjunctsvar        ::adjunctSETtype;
      adjvpefsvar        ::synpatternEFFSETtype;
      adverbialvar       ::BOOLEAN;      
      advfound           ::BOOLEAN;
      advldlfound        :::BOOLEAN;
      advpinshiftfound   ::BOOLEAN;
      advppredrelfound   :::BOOLEAN;
      advprepfound       :::BOOLEAN;
      alsofcomplfound    ::BOOLEAN;
      classesvar         ::classSETtype;
      conjaspectvar      ::aspecttype;
      conjclassvar       ::timeadvclasstype;
      conjdeixisvar      ::deixistype;
      conjkeyvar         ::keytype;
      conjpatternsvar    ::synpatternEFFSETtype;
      conjrelfound       :::BOOLEAN;
      conjretrovar       ::retrotype;
      conjsentinm1found  :::BOOLEAN;
      coordfound         ::BOOLEAN;
      countennpfound     ::BOOLEAN;
      defradvrelfound    :::BOOLEAN;
      deixisvar          ::deixistype;
      dirargNPfound      :::BOOLEAN;
      dirargrelfound     :::BOOLEAN;
      dirprepfound       ::BOOLEAN;
      secondclrelfound   ::BOOLEAN;
      envvar             ::polarityEFFSETtype;
      erinerposrelfound  :::BOOLEAN;
      erinshiftfound     :::BOOLEAN;
      erposrelfound      :::BOOLEAN;
      erqrelfound        :::BOOLEAN;
      expparticle        :::keytype;
      extracanbeadjsubjvar ::BOOLEAN;
      extraposmodus      ::modustype;
      extraposmoodvar    ::moodtype;
      extraposrelfound   ::BOOLEAN;
      finalpuncfound     ::BOOLEAN;
      finitenessvar      ::finitenesstype;
      gelievefound       ::BOOLEAN;
      hetclrelfound      :::BOOLEAN;
      hierdaarinRposfound:::BOOLEAN;
      indobjrelfound     :::BOOLEAN;
      infsortvar         ::inftype;
      firstclrelfound    :::BOOLEAN;
      leftdislocpuncfound::BOOLEAN;
      leftdislocrelfound :::BOOLEAN;
      locargrelfound     :::BOOLEAN;
      modusvar           ::modustype;
      moodvar            ::moodtype;
      negorposfound      :::BOOLEAN;
      nodetnpfound       :: BOOLEAN;
      nodetnpfound2      :: BOOLEAN;
      nodetNPidvps       :: synpatternEFFSETtype;
      nodetNPidvps2      :: synpatternEFFSETtype;
      nppredrelfound     :::BOOLEAN;
      objrelfound        :::BOOLEAN;
      origsynvpefsvar    ::synpatternEFFSETtype;
      particlekey        :::keytype;
      postsubjnodetNPfound::BOOLEAN;
      postsubjpersonvar  ::persontype;
      postsubjnumbervar  ::numbertype;
      postsubjrelfound   :::BOOLEAN;
      postvporelfound    :::BOOLEAN;
      postvrelfound      :::BOOLEAN;
      ppinshiftfound     ::BOOLEAN;
      preadvandclfound   ::BOOLEAN;
      preadvok           ::BOOLEAN;
      preadvok2          ::BOOLEAN;
      preadvrel2found    :::BOOLEAN;
      preadvrelfound     :::BOOLEAN;
      predadjfound       ::BOOLEAN;
      prepkeyvar1        ::keytype;
      prepkeyvar2        ::keytype;
      prepobjrelfound    :::BOOLEAN;
      prepobj1found      :::BOOLEAN;
      prepobj2found      :::BOOLEAN;
      preprepobjrelfound :::BOOLEAN;
      prepppredrelfound  :::BOOLEAN;
      prepsynppsvar      ::synpatternSETtype;
      prosentfound       ::BOOLEAN;
      radvgluefound      ::BOOLEAN;
      reflafterNPfound   ::BOOLEAN;
      reflexivityvar     ::reflexivetype;
      reflrelfound       :::BOOLEAN;
      relprofound        ::BOOLEAN;
      reqvar             ::polarityEFFSETtype;
      resultpuncrelfound :::BOOLEAN;
      retrovar           ::retrotype;
      Rinshiftfound      ::BOOLEAN;
      senttypevar        ::senttypetype;
      shiftnodetNPfound  ::BOOLEAN;
      shiftNPhead        ::NPheadtype;
      shiftnptemporal    ::BOOLEAN;
      shiftnumbervar     ::numbertype;
      shiftpersonvar     ::persontype;
      shiftrelcases      ::caseSETtype;
      shiftrelfound      :::BOOLEAN;
      shiftxpmoodvar     ::xpmoodtype;
      stadvfound         :::BOOLEAN;
      strandedPPfound    :::BOOLEAN;
      strandedrelfound   :::BOOLEAN;
      subjnodetNPfound   ::BOOLEAN;
      subjNPhead         ::NPheadtype;
      subjnumbervar      ::numbertype;
      subjpersonvar      ::persontype;
      subjrelfound       :::BOOLEAN;
      synvpefsvar        ::synpatternEFFsettype;
      synvpefsvar2       ::synpatternEFFsettype;
      temporalvar        ::BOOLEAN;
      tensevar           ::tensetype;
      thetavpvar         ::thetavptype;
      unreducedvpsvar    ::synpatternEFFSETtype;
      v2adjuncts         :::adjunctSETtype;
      v2classesvar       ::classSETtype;
      v2found            :::BOOLEAN;
      v2modusvar         ::modustype;
      v2subcvar          :::verbsubctype;
      v2synvpefsvar      :::synpatternEFFSETtype;
      v2thetavpvar       ::thetavptype;
      verbadjuncts       ::adjunctSETtype;
      verbpersonsvar     ::personSETtype;
      verbnumbervar      ::numbertype;
      verbpfound         :::BOOLEAN;
      verbprepkeyvar1    ::keytype;
      verbprepkeyvar2    ::keytype;
      voicevar           ::voicetype;
      voorobjrelfound    ::BOOLEAN;
      Vmatrixheadvar     ::BOOLEAN;
      vpadjuncts         ::adjunctSETtype;
      vpclassesvar       ::classSETtype;
      vpcomplrelfound    ::BOOLEAN;
      vpinfsortvar       ::inftype;
      vpmodusvar         ::modustype;
      vpsynvpefsvar      ::synpatternEFFSETtype;
      vpthetavpvar       ::thetavptype;
      vrfound            ::BOOLEAN;
      anterelativeok     ::BOOLEAN;



?
HELP

FUNCTION IMPLIES(p,q : BOOLEAN):BOOLEAN;
BEGIN
IMPLIES :=
((NOT p) OR q);
END !(*IMPLIES*);


FUNCTION onlysubjraisingfound(th::thetavptype; vps::synpatterneffSETtype):BOOLEAN;
BEGIN
  onlysubjraisingfound := (th IN [vp010,vp012]) AND (vps <= AUX_closedsentvps);
END;

FUNCTION nosubjraisingfound(th::thetavptype; vps::synpatterneffSETtype):BOOLEAN;
BEGIN
  nosubjraisingfound := (th IN [vp010,vp012]) <= (vps * AUX_closedsentvps=[]);
END;

FUNCTION nodetNP(t:LSSTREE_pStree):BOOLEAN;
!(* 
pre: t=NP<NPrec1>[mu1] & mu1<>[]
post: nodetNP(t) <=>
(NPrec1.number = singular) AND
(NPrec1.actcomas = [count]) AND
(NPrec1.NPhead = otherNP)  AND
(EXIST(mu1, [head/CN<>[mu]]) AND
(NOT EXIST(mu1, [detrel/..])
*)
VAR result, detfound, cnfound : BOOLEAN;
    sonlist :LSSTREE_pRelnode;
BEGIN
  result := ((t^.ls^.NPfield^.number=singular) AND
             (t^.ls^.NPfield^.actcomas=[count]) AND
             (t^.ls^.NPfield^.NPhead=otherNP)
            );
  IF result THEN BEGIN
     sonlist:= t^.sons;
     detfound := false;
     cnfound := false;
     WHILE (sonlist<>NIL) AND ((NOT detfound) OR (NOT cnfound)) DO BEGIN
        IF (NOT detfound) THEN detfound := (sonlist^.relation=detrel);
        IF (NOT cnfound)  THEN cnfound := (sonlist^.relation=head) AND
                                          (sonlist^.node^.ls^.cat=CN);
        sonlist:=sonlist^.brother
     END;
  END;

  nodetNP := result AND cnfound AND (NOT detfound);
END !(*nodetNPok*);



FUNCTION specialNP(nph::NPheadtype):BOOLEAN;
BEGIN
specialNP :=
  (nph IN [hetNP, ditNP, datNP]);
END !(*specialNP*);


FUNCTION activeauxok:BOOLEAN;
BEGIN
activeauxok:=
( VERBPfound AND V2found AND
  (voicevar =active) AND
  (V2subcvar <> wordenaux )
);                                         
!(*
If VERBPfound and V2found, and voicevar = active, then V2subcvar is not allowed
to be the auxiliary worden.
*)
END !(*activeauxok*);



FUNCTION advsok:BOOLEAN;
BEGIN
 advsok := (preadvok          OR 
            preadvrelfound    OR
            erposrelfound     OR
            defRadvrelfound   OR
            erqrelfound       OR
            hetclrelfound     OR
            firstclrelfound   OR
            reflrelfound      OR
            stadvfound        OR
            advfound          OR
            negorposfound     OR
            conjsentinm1found);
END !(*advsok*);


PROCEDURE computeaktarts(     classes::classSETtype; 
                          VAR aktarts::aktionsartEFFSETtype
                        );
!(*
The procedure yields a set, aktarts (by means of a VAR variable)
representing the aktionsarts that are compatible with the verbclass
*)

BEGIN
 aktarts := [];
 IF   (stativeclass IN classes)
 THEN aktarts := aktarts + [stative];
 IF   (movementclass IN classes)
 THEN aktarts := aktarts + [stative, activity, accomplishment];
 IF   (durativeclass IN classes)
 THEN aktarts := aktarts + [stative, activity, accomplishment];
 IF   (momentaryclass IN classes)
 THEN aktarts := aktarts + [stative, achievement];
 IF   (iterativeclass IN classes)
 THEN aktarts := aktarts + [stative, activity];
END !(*computeaktarts*);


FUNCTION allpreadvsok:BOOLEAN;
BEGIN
allpreadvsok :=
( (NOT preadvrelfound) OR preadvok
)                                                    AND
( (NOT preadvrel2found) OR preadvok2
)                                                   

END !(*allpreadvsok*);


FUNCTION anterelativeconds:BOOLEAN;
BEGIN
anterelativeconds:=
(
 (NOT subjrelfound) AND (NOT postsubjrelfound) AND 
 ( IMPLIES( (modusvar =pastpart)                                   , 
            (((voicevar = passive) OR 
              (thetavpvar IN [vp010, vp012])
             )                                                AND
             (NOT objrelfound)                                AND
             (NOT preadvrel2found)                            AND
             (NOT hetclrelfound)                              AND
             (NOT secondclrelfound)                           AND
             (IMPLIES( (preadvrelfound OR firstclrelfound),
                       (synvpefsvar * AUX_indobjvps <> [])
                     )
             )
            )
          )
 )
);
END !(*anterelativeconds*);

FUNCTION extracanbeadjsubj:BOOLEAN;
BEGIN
  extracanbeadjsubj := (adjppredrelfound                            AND
                        IMPLIES(subjrelfound, (subjNphead=hetNP))   AND
                        IMPLIES((shiftrelfound and (NOT subjrelfound)
                                ),
                                ((shiftNPhead=hetNP) OR (shiftrelcases=[]))
                               )
                       )
END !(*extracanbeadjsubj*);

!(*
the extraposrel can be interpreted as a subject to an adjective if
a predicative adjp has been found, and
the subject if present = het , and
the shiftrel if present if no subject is present = het, or is no NP
-this function is called in checkpredadj
-The function allows absence of any real subject,and also, implicitly,
the presence of er in erposrel, or in shiftrel.
*)



PROCEDURE checkpredadj(VAR aps::synpatternEFFSETTYPE);
BEGIN
IF (NOT extracanbeadjsubjvar) THEN BEGIN
  IF    extraposrelfound 
  THEN  aps := aps * AUX_extraposvps;
  IF    (extraposmoodvar = declarative) 
  THEN  aps := aps * AUX_declcomplvps;
  IF    (extraposmoodvar IN [whinterrogative, yesnointerrogative]) 
  THEN  aps := aps * AUX_qcomplvps;
  IF    (extraposmodus = infinitive) AND 
        (extraposmoodvar = declarative) 
  THEN  aps := aps * AUX_teinfcomplvps;
  IF    (extraposmodus = indicative) AND
        (extraposmoodvar = declarative) 
  THEN  aps := aps * AUX_findeclcomplvps;
END
END !(*checkpredadj*);


FUNCTION conjandprepok:BOOLEAN;
BEGIN
  conjandprepok :=
(
 IMPLIES(advprepfound, ( (conjkeyvar = 0)              OR
                         (conjkeyvar = KEY_datconjkey)
                       )
        )
 
);

!(*
This function checks whether the found prep and the conjunction found, if any
are compatible
*)
END !(*conjandprepok*);


FUNCTION countenok:BOOLEAN;
BEGIN
  countenok := IMPLIES(countennpfound, (erqrelfound OR erinerposrelfound));

!(*
*)
END !(*countenok*);


!(*POSTVPOOK moved to LSSURFQUO:

FUNCTION postvpook:BOOLEAN;
BEGIN
 postvpook := (adjppredrelfound     OR 
               advppredrelfound     OR
               nppredrelfound       OR
               prepppredrelfound    OR
               (particlekey <> 0)   OR 
               strandedrelfound     OR 
               prepobjrelfound      OR
               locargrelfound       OR
               dirargrelfound
              );
END; postvpook*)


!(*POSTVOK moved to LSSURFQUO:
FUNCTION postvok(objrelfound,indobjrelfound:BOOLEAN):BOOLEAN;
BEGIN
 postvok := (postvpook       OR
             objrelfound     OR
             indobjrelfound  
            );
END; postvok*)


!(*EXTRAPPOK moved to LSSURFQUO
FUNCTION extrappok:BOOLEAN;
BEGIN
  extrappok := (verbpfound OR postvok(objrelfound,indobjrelfound) OR postvporelfound OR postvrelfound  );
END; extrappok*)



FUNCTION existconf(vps::synpatternEFFSETtype):BOOLEAN;
BEGIN
  existconf := ((rinshiftfound or erposrelfound) AND (synzijn IN vps));
END !(*existconf*);



FUNCTION prepandfinok:BOOLEAN;
BEGIN
  prepandfinok :=
      (NOT advprepfound)                             OR
      (IMPLIES((synTHATSENT IN prepsynppsvar),
               (modusvar = indicative)
              )                                
      )                                        AND
      (IMPLIES((synOPENTESENT IN prepsynppsvar),
               (modusvar = infinitive)
              )                               
      );
!(*
This function checks whether the found prep and the modus of the
sentence are compatible
*)
END !(*conjandprepok*);


FUNCTION argspresent:BOOLEAN;
VAR
shiftused, preadv1used, fclused, supershiftused, postvpoused, erposused,
prepobjused, defRadvused, hetclused,
shiftallowed, supershiftallowed, hiddenshiftallowed, hiddenshiftused,
subjok, objok, indobjok, dirargok, locargok, nppredok, adjppredok,
advppredok, prepppredok, prepobjok, aanobjok, voorobjok, strandedok,
synzijnok, VRok, extraok, prosentok, vpcomplok,
npinshiftfound, soprosentok,
result


                                     :BOOLEAN;

BEGIN

subjok          := true; 
objok           := true; 
indobjok        := true;
dirargok        := true; 
locargok        := true; 
nppredok        := true; 
adjppredok      := true;
advppredok      := true; 
prepppredok     := true; 
prepobjok       := true; 
aanobjok        := true; 
voorobjok       := true; 
strandedok      := true;
synzijnok       := true; 
VRok            := true;
extraok         := true; 
prosentok       := true;
vpcomplok       := true;
npinshiftfound  := true; 
soprosentok     := true;

 result         := true;
 shiftused      := false;
 preadv1used    := false;
 fclused        := false;
 hetclused      := false;
 erposused      := false;
 defRadvused    := false;
 prepobjused    := false;
 postvpoused    := false;
 strandedok     := false;
 supershiftused := false;
 hiddenshiftused:= false;

 npinshiftfound := (shiftrelfound AND (shiftrelcases <> [])) OR
                   relprofound; 
 
 shiftallowed := (moodvar = whinterrogative)      OR
                 ((moodvar = relative)     AND
                  (finitenessvar = finite)
                 )                                OR
                 ((moodvar = declarative)  AND
                  (senttypevar = mainclause)
                 ); 
 supershiftallowed := (moodvar = declarative)           AND
                      (senttypevar = subordinateclause) AND
                      (adverbialvar = false)            AND
                      ((finitenessvar = finite) OR
                       (infsortvar = teinf)
                      );

hiddenshiftallowed := (moodvar = relative)              AND
                      (finitenessvar = infinite);

!(*BEGIN indobj*)
 IF (synvpefsvar * AUX_indobjvps <> []) THEN BEGIN
   indobjok := indobjrelfound;
   IF (NOT indobjok) THEN BEGIN
      IF preadvrel2found AND (NOT preadv1used) THEN BEGIN 
        indobjok := true; preadv1used := true; 
      END;
   END !(*NOT indobjok*);
   IF (NOT indobjok) THEN BEGIN
      IF (secondclrelfound OR hetclrelfound OR extraposrelfound) AND 
         (NOT fclused) AND firstclrelfound THEN BEGIN 
       indobjok := true; fclused := true; 
      END
   END;
   IF (NOT indobjok) THEN BEGIN
      IF (hetclrelfound OR extraposrelfound) AND (NOT preadv1used) AND 
         preadvrelfound THEN BEGIN
         indobjok := true; preadv1used := true
      END
   END;
   IF (NOT indobjok) THEN BEGIN
      IF (NOT preadv1used) AND preadvrelfound THEN BEGIN
         indobjok := true; preadv1used := true
      END
   END;

   IF (NOT indobjok) THEN BEGIN
      IF (NOT fclused) AND firstclrelfound THEN BEGIN
        IF (synvpefsvar - AUX_emptyindobjvps = []) THEN BEGIN 
           indobjok := true; fclused := true
        END
      END;
      IF (synvpefsvar - AUX_emptyindobjvps <> []) THEN BEGIN     
         indobjok := true;
      END;

   END;
   IF (NOT indobjok) AND shiftallowed THEN BEGIN
     IF (synvpefsvar - AUX_emptyindobjvps = []) THEN BEGIN 
        IF npinshiftfound AND (NOT shiftused) THEN BEGIN
           indobjok := true; shiftused := true;
        END!(*shiftrelfound*)
     END;
     IF (synvpefsvar - AUX_emptyindobjvps <> []) THEN BEGIN     
        indobjok := true;
     END;
   END;

   IF (NOT indobjok) AND supershiftallowed THEN BEGIN
     IF (synvpefsvar - AUX_emptyindobjvps = []) THEN BEGIN 
       IF npinshiftfound AND (NOT shiftused) THEN BEGIN
          indobjok := true; shiftused := true;
       END!(*npinshiftfound*)
     END;
     IF (synvpefsvar - AUX_emptyindobjvps <> []) THEN BEGIN     
        indobjok := true;
     END;
   END!(*supershiftallowed*);

   IF (NOT indobjok) AND hiddenshiftallowed THEN BEGIN
     IF (synvpefsvar - AUX_emptyindobjvps = []) THEN BEGIN 
       IF (NOT hiddenshiftused) THEN BEGIN
          indobjok := true; hiddenshiftused := true;
       END;
     END;
     IF (synvpefsvar - AUX_emptyindobjvps <> []) THEN BEGIN     
        indobjok := true;
     END;
   END;
   IF (NOT indobjok) THEN BEGIN
     synvpefsvar := synvpefsvar - AUX_indobjvps;
     indobjok := true;
   END
 END !(** AUX_indobjvps*)
 ELSE indobjok := true;
 result := result AND indobjok;


 !(*BEGIN subj*)
IF result THEN BEGIN
 IF (finitenessvar = finite) AND (moodvar <> imperativemood) THEN BEGIN
  subjok := subjrelfound OR erposrelfound OR extraposrelfound           OR
	    postsubjrelfound                                            OR 
	    (leftdislocrelfound AND (NOT advldlfound))                  OR
	    ((thetavpvar = vp012) AND (synvpefsvar * AUX_indobjvps <> []))   OR 
	    ((voicevar = passive) AND (synvpefsvar * AUX_indobjvps <> []))   OR
            ((voicevar = passive) AND shiftallowed and ppinshiftfound);
  IF ((NOT subjok) AND shiftallowed) THEN BEGIN
     IF ((npinshiftfound OR ppinshiftfound OR Rinshiftfound) AND 
	 (NOT shiftused)) THEN BEGIN
	subjok := true; shiftused := true;
     END;
  END;
  IF ((NOT subjok) AND supershiftallowed AND (NOT supershiftused)) THEN BEGIN
    subjok := true; supershiftused := true;
  END !(*not subjok and supershiftallowed*);
 END!(*finitenessvar = finite*)
 ELSE subjok := true;
 result := result AND subjok;
END !(*SUBJ*);


 !(*BEGIN obj*)
IF result THEN BEGIN
 IF ((synvpefsvar * (AUX_objvps-[synzijn]) <> []) AND 
     (voicevar = active)              AND
     (thetavpvar IN [vp120,vp123])) THEN BEGIN
  objok := objrelfound OR secondclrelfound OR preadvrel2found;

  IF (NOT objok) THEN BEGIN
    IF (hetclrelfound AND (NOT hetclused)) THEN BEGIN
      hetclused := true; objok := true
    END;
  END;


  IF (NOT objok) THEN BEGIN
    IF (preadvrelfound AND (NOT preadv1used)) THEN BEGIN
      preadv1used := true; objok := true
    END;
  END;
  IF (NOT objok) THEN BEGIN
    IF (firstclrelfound AND (NOT fclused)) THEN BEGIN
      fclused := true; objok := true
    END;
  END;
  IF ((NOT objok) AND shiftallowed )THEN BEGIN
    IF (npinshiftfound AND (NOT shiftused)) THEN BEGIN
      shiftused := true; objok := true
    END;
  END;

  IF ((NOT objok) AND supershiftallowed )THEN BEGIN
    IF (NOT supershiftused) THEN BEGIN
      supershiftused := true; objok := true
    END;
  END;
 
   IF (NOT objok) AND hiddenshiftallowed THEN BEGIN
     IF (NOT hiddenshiftused) THEN BEGIN
       objok := true; hiddenshiftused := true;
     END; 
   END;

  IF (NOT objok) THEN BEGIN
     synvpefsvar := synvpefsvar - AUX_objvps;
     objok := true;
  END;

 END !(*objvps*)
 ELSE objok := true;
 result := result AND objok;
END !(*obj*);

!(*BEGIN dirarg*)
IF result THEN BEGIN
 IF (synvpefsvar * AUX_dirargvps <> []) THEN BEGIN
   dirargok := dirargrelfound;
   IF ((NOT dirargok) AND shiftallowed) THEN BEGIN
      IF  ((ppinshiftfound OR advpinshiftfound) AND (NOT shiftused)) THEN BEGIN
          shiftused := true; dirargok :=true;
      END;
   END;
   IF ((NOT dirargok) AND supershiftallowed) THEN BEGIN
      IF  (NOT supershiftused) THEN BEGIN
          supershiftused := true; dirargok :=true;
      END;
   END;

   IF (NOT dirargok) THEN BEGIN
      synvpefsvar := synvpefsvar - AUX_dirargvps;
      dirargok := true;
   END;
 END !(*dirargvps*)
 ELSE dirargok := true;
 result := result AND dirargok;
END !(*dirarg*);

!(*BEGIN locarg*)
IF result THEN BEGIN
 IF (synvpefsvar * AUX_locargvps <> []) THEN BEGIN
   locargok := locargrelfound;

   IF (NOT locargok) THEN BEGIN
      IF (NOT erposused) AND erposrelfound THEN BEGIN
         locargok := true; erposused := true
      END
   END;

   IF (NOT locargok) THEN BEGIN
      IF (NOT defRadvused) AND defRadvrelfound THEN BEGIN
         locargok := true; defRadvused := true
      END
   END;

   
   IF ((NOT locargok) AND shiftallowed) THEN BEGIN
      IF  ((ppinshiftfound OR advpinshiftfound) AND (NOT shiftused)) THEN BEGIN
          shiftused := true; locargok :=true;
      END;
   END;
   IF ((NOT locargok) AND supershiftallowed) THEN BEGIN
      IF  (NOT supershiftused) THEN BEGIN
          supershiftused := true; locargok :=true;
      END;
   END;

   IF (NOT locargok) AND hiddenshiftallowed THEN BEGIN
     IF (NOT hiddenshiftused) THEN BEGIN
       locargok := true; hiddenshiftused := true;
     END; 
   END;

   IF (NOT locargok) THEN BEGIN
      synvpefsvar := synvpefsvar - AUX_locargvps;
      locargok := true;
   END;
 END !(*locargvps*)
 ELSE locargok := true;
 result := result AND locargok;
END !(*locarg*);

!(*BEGIN prepobj*)
IF result THEN BEGIN
 IF (synvpefsvar * AUX_prepobjvps <> []) THEN BEGIN
   prepobjok := prepobjrelfound;

   IF (NOT prepobjok) THEN BEGIN
      IF  (postvporelfound AND (NOT postvpoused)) THEN BEGIN
          postvpoused := true; prepobjok :=true;
      END;
   END;
   
   IF ((NOT prepobjok) AND shiftallowed) THEN BEGIN
      IF  (ppinshiftfound AND (NOT shiftused)) THEN BEGIN
          shiftused := true; prepobjok :=true;
      END;
   END;
   IF ((NOT prepobjok) AND supershiftallowed) THEN BEGIN
      IF  (NOT supershiftused) THEN BEGIN
          supershiftused := true; prepobjok :=true;
      END;
   END;

   IF (NOT prepobjok) THEN BEGIN
      synvpefsvar := synvpefsvar - AUX_prepobjvps;
      prepobjok := true;
   END;
 END !(*prepobjvps*)
 ELSE prepobjok := true;
 result := result AND prepobjok;
END !(*prepobj*);

!(*BEGIN aanobj*)
IF result THEN BEGIN
 IF (synvpefsvar * AUX_aanobjvps <> []) THEN BEGIN
   aanobjok := aanobjrelfound;


   IF (NOT aanobjok) THEN BEGIN
      IF  (prepobjrelfound AND (NOT prepobjused)) THEN BEGIN
          prepobjused := true; aanobjok :=true;
      END;
   END;

   IF (NOT aanobjok) THEN BEGIN
      IF  (postvporelfound AND (NOT postvpoused)) THEN BEGIN
          postvpoused := true; aanobjok :=true;
      END;
   END;
   
   IF ((NOT aanobjok) AND shiftallowed) THEN BEGIN
      IF  (ppinshiftfound AND (NOT shiftused)) THEN BEGIN
          shiftused := true; aanobjok :=true;
      END;
   END;
   IF ((NOT aanobjok) AND supershiftallowed) THEN BEGIN
      IF  (NOT supershiftused) THEN BEGIN
          supershiftused := true; aanobjok :=true;
      END;
   END;

   IF (NOT aanobjok) THEN BEGIN
      synvpefsvar := synvpefsvar - AUX_aanobjvps;
      aanobjok := true;
   END;
 END !(*aanobjvps*)
 ELSE aanobjok := true;
 result := result AND aanobjok;
END !(*aanobj*);

!(*BEGIN voorobj*)
IF result THEN BEGIN
 IF (synvpefsvar * AUX_voorobjvps <> []) THEN BEGIN
   voorobjok := voorobjrelfound;


   IF (NOT voorobjok) THEN BEGIN
      IF  (prepobjrelfound AND (NOT prepobjused)) THEN BEGIN
          prepobjused := true; voorobjok :=true;
      END;
   END;

   IF (NOT voorobjok) THEN BEGIN
      IF  (postvporelfound AND (NOT postvpoused)) THEN BEGIN
          postvpoused := true; voorobjok :=true;
      END;
   END;
   
   IF ((NOT voorobjok) AND shiftallowed) THEN BEGIN
      IF  (ppinshiftfound AND (NOT shiftused)) THEN BEGIN
          shiftused := true; voorobjok :=true;
      END;
   END;
   IF ((NOT voorobjok) AND supershiftallowed) THEN BEGIN
      IF  (NOT supershiftused) THEN BEGIN
          supershiftused := true; voorobjok :=true;
      END;
   END;

   IF (NOT voorobjok) THEN BEGIN
      synvpefsvar := synvpefsvar - AUX_voorobjvps;
      voorobjok := true;
   END;
 END !(*voorobjvps*)
 ELSE voorobjok := true;
 result := result AND voorobjok;
END !(*voorobj*);

!(*BEGIN adjppred*)
IF result THEN BEGIN
 IF (synvpefsvar * (AUX_adjppredvps-[synzijn]) <> []) THEN BEGIN
   adjppredok := adjppredrelfound;

   IF ((NOT adjppredok) AND shiftallowed) THEN BEGIN
      IF  (adjpinshiftfound AND (NOT shiftused)) THEN BEGIN
          shiftused := true; adjppredok :=true;
      END;
   END;
   IF ((NOT adjppredok) AND supershiftallowed) THEN BEGIN
      IF  (NOT supershiftused) THEN BEGIN
          supershiftused := true; adjppredok :=true;
      END;
   END;

   IF (NOT adjppredok) THEN BEGIN
      synvpefsvar := synvpefsvar - AUX_adjppredvps;
      adjppredok := true;
   END;
 END !(*adjppredvps*)
 ELSE adjppredok := true;
 result := result AND adjppredok;
END !(*adjppred*);

!(*BEGIN nppred*)
IF result THEN BEGIN
 IF (synvpefsvar * (AUX_nppredvps-[synzijn]) <> []) THEN BEGIN
   nppredok := nppredrelfound;


   IF ((NOT nppredok) AND shiftallowed) THEN BEGIN
      IF  (npinshiftfound AND (NOT shiftused)) THEN BEGIN
          shiftused := true; nppredok :=true;
      END;
   END;
   IF ((NOT nppredok) AND supershiftallowed) THEN BEGIN
      IF  (NOT supershiftused) THEN BEGIN
          supershiftused := true; nppredok :=true;
      END;
   END;

   IF (NOT nppredok) AND hiddenshiftallowed THEN BEGIN
     IF (NOT hiddenshiftused) THEN BEGIN
       nppredok := true; hiddenshiftused := true;
     END; 
   END;

   IF (NOT nppredok) THEN BEGIN
      synvpefsvar := synvpefsvar - AUX_nppredvps;
      nppredok := true;
   END;
 END !(*nppredvps*)
 ELSE nppredok := true;
 result := result AND nppredok;
END !(*nppred*);

!(*BEGIN prepppred*)
IF result THEN BEGIN
 IF (synvpefsvar * (AUX_prepppredvps-[synzijn]) <> []) THEN BEGIN
   prepppredok := prepppredrelfound;


   IF ((NOT prepppredok) AND shiftallowed) THEN BEGIN
      IF  (ppinshiftfound AND (NOT shiftused)) THEN BEGIN
          shiftused := true; prepppredok :=true;
      END;
   END;
   IF ((NOT prepppredok) AND supershiftallowed) THEN BEGIN
      IF  (NOT supershiftused) THEN BEGIN
          supershiftused := true; prepppredok :=true;
      END;
   END;

   IF (NOT prepppredok) THEN BEGIN
      synvpefsvar := synvpefsvar - AUX_prepppredvps;
      prepppredok := true;
   END;
 END !(*prepppredvps*)
 ELSE prepppredok := true;
 result := result AND prepppredok;
END !(*prepppred*);

!(*BEGIN advppred*)
IF result THEN BEGIN
 IF (synvpefsvar * (AUX_advppredvps-[synzijn]) <> []) THEN BEGIN
   advppredok := advppredrelfound ;


   IF ((NOT advppredok) AND shiftallowed) THEN BEGIN
      IF  (advpinshiftfound AND (NOT shiftused)) THEN BEGIN
          shiftused := true; advppredok :=true;
      END;
   END;
   IF ((NOT advppredok) AND supershiftallowed) THEN BEGIN
      IF  (NOT supershiftused) THEN BEGIN
          supershiftused := true; advppredok :=true;
      END;
   END;

   IF (NOT advppredok) THEN BEGIN
      synvpefsvar := synvpefsvar - AUX_advppredvps;
      advppredok := true;
   END;
 END !(*advppredvps*)
 ELSE advppredok := true;
 result := result AND advppredok;
END !(*advppred*);

!(*BEGIN vpcomplok*)
IF result THEN BEGIN
 IF (synvpefsvar * AUX_vpcomplvps <> []) THEN BEGIN
   vpcomplok := vpcomplrelfound;

   IF (NOT vpcomplok) THEN BEGIN
      synvpefsvar := synvpefsvar - AUX_vpcomplvps;
      vpcomplok := true;
   END;
 END !(*vpcomplvps*)
 ELSE vpcomplok := true;
 result := result AND vpcomplok;
END !(*vpcompl*);


!(*BEGIN soprosentok*)
IF result THEN BEGIN
 IF (synvpefsvar * AUX_soprosentvps <> []) THEN BEGIN
   soprosentok := prosentfound OR verbpfound;

   IF (NOT soprosentok) THEN BEGIN
      synvpefsvar := synvpefsvar - AUX_soprosentvps;
      soprosentok := true;
   END;
 END !(*soprosentvps*)
 ELSE soprosentok := true;
 result := result AND soprosentok;
END !(*soprosentok*);




!(*BEGIN stranded*)
IF result THEN BEGIN
 IF strandedPPfound THEN BEGIN

  IF (NOT strandedok) THEN BEGIN
    IF (NOT erposused) AND (erposrelfound) THEN BEGIN
      erposused := true; strandedok := true;
    END
  END;

  IF ((NOT strandedok) AND shiftallowed) THEN BEGIN
    IF  (shiftrelfound AND (NOT shiftused)) THEN BEGIN
      shiftused := true; strandedok :=true;
    END;
  END;
  IF ((NOT strandedok) AND supershiftallowed) THEN BEGIN
     IF  (NOT supershiftused) THEN BEGIN
         supershiftused := true; strandedok :=true;
     END;
  END;

  IF ((NOT strandedok) AND hiddenshiftallowed) THEN BEGIN
     IF  (NOT hiddenshiftused) THEN BEGIN
         hiddenshiftused := true; strandedok :=true;
     END;
  END;

  IF (NOT strandedok) THEN BEGIN
     synvpefsvar := synvpefsvar - (AUX_locargvps +
                                   AUX_dirargvps +
                                   AUX_aanobjvps +
                                   AUX_voorobjvps +
                                   AUX_prepobjvps +
                                   AUX_prepppredvps
                                  );
     strandedok := true;
  END;

 END
 ELSE strandedok := true;
 result := result AND strandedok;
END !(*stranded*);

!(*BEGIN synzijn*)
IF result THEN BEGIN
  IF (synvpefsvar * [synzijn] <> []) THEN BEGIN
     synzijnok := adjppredrelfound OR nppredrelfound    OR
                  advppredrelfound OR prepppredrelfound OR
                  objrelfound ;

     IF (NOT synzijnok) THEN BEGIN
        IF (NOT fclused) AND firstclrelfound THEN BEGIN
           fclused := true; synzijnok := true;
        END
     END;

     IF (NOT synzijnok) THEN BEGIN
        IF (NOT hetclused) AND hetclrelfound THEN BEGIN
           hetclused := true; synzijnok := true;
        END
     END;

     IF (NOT synzijnok) AND shiftallowed THEN BEGIN
        IF (NOT shiftused) AND shiftrelfound THEN BEGIN
           shiftused := true; synzijnok := true;
        END
     END;
     IF (NOT synzijnok) AND supershiftallowed THEN BEGIN
        IF (NOT supershiftused) THEN BEGIN
           supershiftused := true; synzijnok := true;
        END
     END;

     IF (NOT synzijnok) AND hiddenshiftallowed THEN BEGIN
        IF (NOT hiddenshiftused) THEN BEGIN
           hiddenshiftused := true; synzijnok := true;
        END
     END;
     
     IF (NOT synzijnok) THEN BEGIN
        synvpefsvar := synvpefsvar - [synzijn]; synzijnok := true;
     END

  END
  ELSE synzijnok := true;
  result := result AND synzijnok;
END !(*synzijn*);

!(*BEGIN extrapos*)
IF result THEN BEGIN
  IF (synvpefsvar * (AUX_extraposvps-AUX_VRvps) <> []) THEN BEGIN
     extraok := extraposrelfound;

     IF (NOT extraok) THEN BEGIN
        synvpefsvar := synvpefsvar - (AUX_extraposvps-AUX_VRvps); 
        extraok:= true;
     END

  END
  ELSE extraok := true;
  result := result AND extraok;
END !(*extrapos*);

!(*BEGIN VR*)
IF result THEN BEGIN
  IF (synvpefsvar * AUX_oblVRvps <> []) THEN BEGIN
     VRok := VERBPfound;

     IF (NOT VRok) THEN BEGIN
        synvpefsvar := synvpefsvar - AUX_oblVRvps; VRok:= true;
     END

  END
  ELSE VRok := true;
  result := result AND VRok;
END !(*VR*);

!(*BEGIN PROSENTvps*)
IF result THEN BEGIN
  IF synvpefsvar * AUX_prosentvps <> [] THEN BEGIN
     IF hetclrelfound AND (NOT hetclused) THEN BEGIN
        prosentok := true; hetclused := true;
     END;

     IF (NOT prosentok) THEN BEGIN
       synvpefsvar := synvpefsvar - AUX_prosentvps;
       prosentok := true;
     END
  END
  ELSE prosentok := true;
  result := result AND prosentok;
END !(*synPROSENT*);
                          

argspresent := result AND (synvpefsvar <> []);

END !(*argspresent*);





FUNCTION conjandverbok:BOOLEAN;
BEGIN
conjandverbok:=

( 
  (NOT 
      (conjrelfound AND (NOT V2found)
      )
  )                                    OR
  (
   ( (conjpatternsvar * [synTHATSENT, synQSENT] <> []) AND
     (finitenessvar = finite) 
   )                                                          OR
   ( (conjpatternsvar * [synOPENTESENT] <> [])         AND
     (finitenessvar = infinite)                        AND
     (infsortvar = teinf)
   )
  )                                         
);
!(*Checks whether the found CONJ, if any, and finiteness
are  compatible*)                                                    
END !(*conjandverbok*);





PROCEDURE detargstrANDclasses( 
           VAR thetavpvar    :: thetavptype;
           VAR vpsynvpefsvar ::synpatternEFFSETtype;
           VAR classesvar    ::classSETtype;
           VAR verbadjuncts  ::adjunctSETtype;
           VAR adjunctsvar   ::adjunctSETtype
                             );
BEGIN

   IF   V2found
   THEN BEGIN
    IF   verbpfound
    THEN BEGIN
      IF ((V2subcvar IN [hebbenaux, zijnaux])      AND
	  (VPmodusvar IN [pastpart, infinitive])   AND
          (voicevar = active) 
	 )                                                 
	     !(* is .. beginnen te werken;aanhetV !
		heeft... moeten werken ;*)
                                                            OR
         ( (V2subcvar IN [zijnaux, wordenaux])     AND
           (VPmodusvar = pastpart)                 AND
           (voicevar = passive)
         )                                                  OR
         ( (V2subcvar = latenverb)                 AND
           (VPmodusvar =infinitive)                AND
           adhortfound
         )
      THEN BEGIN 
        IF    Vmatrixheadvar
        THEN BEGIN
	   thetavpvar   := VPthetavpvar;
	   synvpefsvar  := VPsynvpefsvar;
	   classesvar   := VPclassesvar;
           verbadjuncts := VPadjuncts;
           adjunctsvar  := VPadjuncts;
        END !(*Vmatrixheadvar*)
      END !(*V2subcvar IN THEN*)
      ELSE BEGIN
        IF  (NOT Vmatrixheadvar)
        THEN BEGIN
	   thetavpvar   := V2thetavpvar;
	   synvpefsvar  := V2synvpefsvar;
	   classesvar   := V2classesvar;
           verbadjuncts := VPadjuncts;
           adjunctsvar  := VPadjuncts;
        END !(*NOT Vmatrixheadvar*)
      END !(*else V2subcvar ELSE*)
    END!(* IF verbpfound THEN*)
    ELSE BEGIN
       thetavpvar   := V2thetavpvar;
       synvpefsvar  := V2synvpefsvar;
       classesvar   := V2classesvar;
       verbadjuncts := V2adjuncts;
    END !(*IF verbpfound ELSE*)
   END !(*V2found THEN*)
   ELSE BEGIN
     IF   (verbpfound AND Vmatrixheadvar)
     THEN BEGIN
       thetavpvar   := VPthetavpvar;
       synvpefsvar  := VPsynvpefsvar;
       classesvar   := VPclassesvar;
       verbadjuncts := VPadjuncts;
       adjunctsvar  := VPadjuncts;
     END !(*Vmatrixheadvar*)
     ELSE IF ((NOT verbpfound) AND adjppredrelfound) 
          THEN BEGIN
            thetavpvar  := thetavpaux;
            synvpefsvar := [synzijn];
            classesvar  := [stativeclass];
            verbadjuncts := [];
            adjunctsvar := [];
          END
   END !(*V2found ELSE*); 
END !(*detargstrANDclasses*);


FUNCTION yesnoconds:BOOLEAN;
BEGIN
  yesnoconds :=
   ( (NOT leftdislocrelfound) AND
     (
      subjrelfound     OR
      postsubjrelfound OR
      erposrelfound    OR
      indobjrelfound
     )
   );
END !(*yesnoconds*);




PROCEDURE determinemood16(VAR moodvar    ::moodtype; 
                          VAR senttypevar::senttypetype
                         );
BEGIN
 IF    (NOT shiftrelfound) AND (NOT adhortfound)
 THEN BEGIN
   IF   (NOT conjrelfound)
   THEN BEGIN
     IF   ((modusvar = infinitive) AND
           ( NOT subjrelfound )
          )
     THEN BEGIN
             moodvar     := declarative;                  !(*1*)
             senttypevar := subordinateclause;
     END;
     IF   (modusvar IN [omegamodus, prespart, pastpart]) AND
	  (anterelativeok)                   AND
	  anterelativeconds                  
     THEN BEGIN
             moodvar     := anterelative;                 !(*2*)
             senttypevar := subordinateclause;
     END
   END !(*IF (NOT conjrelfound THEN)*)
   ELSE BEGIN
     IF   (NOT V2found)
     THEN BEGIN
       IF    (synTHATSENT IN conjpatternsvar)
       THEN BEGIN
               moodvar := declarative;                    !(*4*)
               senttypevar := subordinateclause;               
       END
       ELSE BEGIN
              IF  ( synQsent  in conjpatternsvar )
              THEN BEGIN
                 moodvar := yesnointerrogative;             !(*3*)
                 senttypevar := subordinateclause;
              END 
              ELSE BEGIN
		     IF    (conjkeyvar = KEY_omCONJkey )
		     THEN BEGIN
			    moodvar := declarative;                    !(*omteinf*)
			    senttypevar := subordinateclause;               
                            infsortvar := omteinf;
		     END;
                     
                     IF gelievefound             AND
                        (modusvar = infinitive)  AND
                        (infsortvar = teinf)     AND
                        (NOT subjrelfound)       AND
                        (NOT postsubjrelfound)   AND
                        (NOT leftdislocrelfound) AND
                        (NOT shiftrelfound)
                     THEN BEGIN
			    moodvar := imperativemood;  !(*gelieve dit te doen*)
			    senttypevar := mainclause;               
                     END

              END               
       END
     END !(*IF (not v2found)*)
     ELSE BEGIN
       IF ( 
           (modusvar = imperative)             AND
           (NOT postsubjrelfound)              AND
	   ((NOT subjrelfound)              OR 
	    ((subjpersonvar IN [2,4]) AND
             (subjnumbervar = singular)
            )
	   )
          )
       THEN BEGIN
              moodvar := imperativemood;             !(*5*)
              senttypevar := mainclause;
       END;
       IF   (modusvar = indicative)  AND
            yesnoconds
       THEN BEGIN
               moodvar := yesnointerrogative ;        !(*6*)
               senttypevar := mainclause;
       END
     END !(*IF NOT v2found ELSE*)
   END !(*IF (NOT conjrelfound ELSE)*)
 END !(*IF (NOT shiftrelfound) THEN*)   

END !(*determinemood16*);



PROCEDURE determinemood7(VAR moodvar    ::moodtype; 
                          VAR senttypevar::senttypetype
                         );
BEGIN
 IF   (NOT shiftrelfound) AND
      (conjrelfound)
 THEN BEGIN
   IF   (V2found) AND (subjrelfound) AND adhortfound
   THEN IF (V2subcvar = latenverb) AND
	   ( subjpersonvar = 1) AND
	   (subjnumbervar = plural)
	THEN BEGIN
                moodvar     := latenmood;                   !(*7*)
                senttypevar := mainclause
        END;

   IF V2found AND subjrelfound AND (NOT adhortfound)
   THEN IF (modusvar = indicative)  AND
           (subjpersonvar = 2)      AND
           (subjnumbervar = plural) 
        THEN BEGIN
               moodvar     := imperativemood;  !(*Komen jullie binnen!*)
               senttypevar := mainclause;
        END;
 END !(*IF   (NOT shiftrelfound) AND
	   (conjrelfound) THEN *)

END !(*determinemood7*);



PROCEDURE determinemood8(VAR moodvar    ::moodtype; 
                          VAR senttypevar::senttypetype
                         );
BEGIN
 IF   (shiftrelfound)     AND
      (NOT conjrelfound)  AND
      (NOT adhortfound)
 THEN BEGIN
   IF (
       (
        (relprofound)        OR
        (shiftxpmoodvar = wh)
       )                         AND
       (modusvar = indicative)
      )
   THEN BEGIN
           moodvar     := relative;                        !(*8*) 
           senttypevar := subordinateclause;
   END
 END !(*IF (shiftrelfound) AND (NOT conjrelfound) THEN*)
END !(*determinemood8*);


PROCEDURE determinemood914(VAR moodvar    ::moodtype; 
                           VAR senttypevar::senttypetype
                          );
BEGIN
IF (NOT adhortfound) THEN BEGIN
 IF  (shiftrelfound) 
 THEN BEGIN
   IF  (NOT conjrelfound)
   THEN BEGIN
     IF   (shiftxpmoodvar = wh)
     THEN BEGIN
       IF (modusvar = indicative) 
       THEN BEGIN
                  !(* wat hij deed *)
               moodvar     := whinterrogative;                   !(*9a*)
               senttypevar := subordinateclause;
       END !(* IF (modusvar = indicative) THEN*)
       ELSE BEGIN
         IF  (modusvar = infinitive)   AND
             (infsortvar = teinf)
         THEN BEGIN
                    !(* wat te doen *)
               moodvar     := whinterrogative;                   !(*9b*)
               senttypevar := subordinateclause;
         END
       END !(* IF (modusvar = indicative) ELSE*)
     END !(*if shiftxpmoodvar = wh THEN*)     
   END !(*NOT conjrelfound THEN*)
   ELSE BEGIN
     IF  (shiftxpmoodvar = wh)
     THEN BEGIN
       IF   V2found
       THEN BEGIN
             !(* wat deed hij *)
         IF   (modusvar = indicative)   
         THEN BEGIN
               moodvar     := whinterrogative;                  !(*10*)
               senttypevar := mainclause;
         END
       END
       ELSE BEGIN
          !(* wat of hij deed *)
         IF (modusvar = indicative)      
         THEN BEGIN
               moodvar     := whinterrogative;                  !(*11*)
               senttypevar := subordinateclause;
         END
       END
     END;

     IF  (shiftxpmoodvar = declxpmood) AND
	 (V2found)                     AND
         (NOT RELPROfound)
     THEN BEGIN
             IF   (modusvar = indicative)
             THEN BEGIN
		moodvar := declarative;                             !(*12*)
		senttypevar := mainclause;
             END
     END
   END !(*NOT conjrelfound ELSE*)
 END !(*if shiftrelfound THEN*)
 ELSE BEGIN
   IF  (conjrelfound)
   THEN BEGIN
     IF   leftdislocrelfound      AND
          (modusvar = indicative)
     THEN BEGIN
            moodvar := declarative;                       !(*13*)
            senttypevar := mainclause;
     END;
     IF   (conjkeyvar = KEY_omCONJkey)
     THEN BEGIN
             moodvar := relative;                          !(*14*)
             senttypevar := subordinateclause;
             infsortvar := omteinf;
     END
   END !(*IF conjrelfound THEN*)
 END !(*if shiftrelfound ELSE*)
END !(*IF NOT adhortfound*)
END !(*determinemood914*);



PROCEDURE determinemood15ff(VAR moodvar    ::moodtype; 
                            VAR senttypevar::senttypetype
                           );
BEGIN
  IF  ((NOT shiftrelfound) AND
       (NOT adhortfound) 
      )
  THEN BEGIN
          IF    (V2found) AND (modusvar = indicative)
          THEN BEGIN
	     moodvar      := conditional;                      !(*15*)
	     senttypevar  := subordinateclause;
             adverbialvar := true;
          END
!(* for: Komt hij op tijd, (dan halen we het nog)  *)
  END
  ELSE BEGIN
         IF ((shiftxpmoodvar = wh)   AND
             (modusvar = infinitive) AND 
             (infsortvar = teinf)
            )
         THEN BEGIN
                 moodvar     := whinterrogative;               !(*16*)
                 senttypevar := mainclause;
         END 
  END

END !(*determinemood15*);


PROCEDURE determinemoodadv( VAR moodvar    ::moodtype; 
                            VAR senttypevar::senttypetype
                          );
BEGIN
  IF     (NOT shiftrelfound) AND
         conjandprepok       AND
         prepandfinok        AND
         (NOT adhortfound)
  THEN BEGIN
    moodvar     := declarative;
    senttypevar := subordinateclause;
  END;
END !(*determinemoodadv*);

FUNCTION dirargnpok:BOOLEAN;
BEGIN
  dirargnpok := ( ( NOT dirargnpfound)         OR
                  (dirprepfound OR verbpfound)
                );
END !(*dirargnpok*);



PROCEDURE EXTreducevps(VAR vps::synpatternEFFSETtype);
BEGIN

IF    (reflafterNPfound)
THEN  vps := vps * AUX_VRvps;
IF    extraposrelfound                     AND 
      (adjvpefsvar * AUX_extraposvps = []) AND
      (NOT extracanbeadjsubjvar)
THEN  vps := vps * AUX_extraposvps;
IF    alsofcomplfound
THEN  vps := vps * AUX_alsofcomplvps;
IF    (NOT alsofcomplfound)
THEN  vps := vps - AUX_alsofcomplvps;
IF    (extraposmoodvar = declarative) AND 
      (adjvpefsvar * AUX_extraposvps = []) AND
      (NOT extracanbeadjsubjvar)
THEN  vps := vps * AUX_declcomplvps;
IF    (extraposmoodvar IN [whinterrogative, yesnointerrogative]) AND 
      (adjvpefsvar * AUX_extraposvps = []) AND
      (NOT extracanbeadjsubjvar)
THEN  vps := vps * AUX_qcomplvps;
IF    (extraposmodus = infinitive) AND 
      (extraposmoodvar = declarative) AND 
      (adjvpefsvar * AUX_extraposvps = []) AND
      (NOT extracanbeadjsubjvar)
THEN  vps := vps * AUX_teinfcomplvps;
IF    (extraposmodus = indicative) AND
      (extraposmoodvar = declarative) AND 
      (adjvpefsvar * AUX_extraposvps = []) AND
      (NOT extracanbeadjsubjvar)
THEN  vps := vps * AUX_findeclcomplvps;
IF    ((NOT hetclrelfound) AND (shiftNPhead <> hetNP) AND (subjNPhead <> hetNP))
THEN  vps := vps - AUX_hetcomplvps;

!(*
This procedure reduce vps on the basis of information from outside the VERBP,
or from information that would be outside VERBP, if there were one. 
These reductions can apply even if VRfound = true
*)

END!(*EXTreducevps*);


PROCEDURE INTreducevps(VAR vps::synpatternEFFSETtype);
BEGIN
   IF    ((VERBPfound) AND
	  (Vmatrixheadvar = false)
	 )
   THEN BEGIN
        vps := vps * AUX_VRvps;
        IF   (VPinfsortvar = teinf) 
        THEN vps := vps * AUX_teinfcomplvps;
   END;
   IF indobjrelfound   AND
      ([benfactNP] * verbadjuncts = [])
   THEN vps := vps * AUX_indobjvps;
   IF indobjrelfound AND
      (benfactNP IN verbadjuncts)
   THEN adjunctsvar := adjunctsvar + [benfactNP];
   IF objrelfound AND (NOT existconf(vps)) 
   THEN vps := vps * AUX_objvps;
   IF objrelfound AND (existconf(vps)) 
   THEN vps := vps * (AUX_objvps + [synzijn]);
   IF accobjfound
   THEN vps := vps * AUX_accobjvps;
   IF   prosentfound
   THEN vps := vps * AUX_soprosentvps;
   IF  (NOT VRfound)
   THEN BEGIN
      IF    preadvrelfound AND ([benfactNP] * verbadjuncts = [])
      THEN  vps := vps * (AUX_objvps + AUX_indobjvps);
      IF    preadvrelfound AND ([benfactNP] * verbadjuncts <> [])
      THEN  vps := vps * AUX_objvps ;
      IF firstclrelfound AND (adjvpefsvar * (AUX_objvps + AUX_adjindobjvps) <> [])
      THEN  vps := vps * AUX_adjppredvps;
      IF firstclrelfound                                      AND 
         (adjvpefsvar * (AUX_objvps + AUX_adjindobjvps) = []) AND
         ([benfactNP] * verbadjuncts = [])
      THEN  vps := vps * (AUX_objvps + AUX_indobjvps + AUX_nppredvps);

      IF firstclrelfound                                      AND 
         (adjvpefsvar * (AUX_objvps + AUX_adjindobjvps) = []) AND
         ([benfactNP] * verbadjuncts <> [])
      THEN  vps := vps * (AUX_objvps +  AUX_nppredvps);
      
      preadvandclfound := (
                           (preadvrel2found OR secondclrelfound)   OR
	                   (preadvrelfound AND firstclrelfound)    OR
                           (firstclrelfound AND objrelfound)       OR
                           (preadvrelfound AND hetclrelfound)
                          );

      IF    (preadvandclfound  AND (adjvpefsvar = [])) AND
            ([benfactNP] * verbadjuncts = [])
      THEN  vps := vps * (AUX_indobjvps * AUX_objandhetvps);

      IF    (preadvandclfound  AND (adjvpefsvar = [])) AND
            ([benfactNP] * verbadjuncts <> [])
      THEN  vps := vps * AUX_objandhetvps;

      IF    (preadvandclfound  AND (adjvpefsvar <> [])) THEN BEGIN
        IF    (adjvpefsvar * (AUX_adjindobjvps + AUX_objandhetvps) = []) AND
              ([benfactNP] * verbadjuncts = [])
        THEN  vps := vps * (AUX_indobjvps * AUX_objandhetvps * AUX_adjppredvps);
        IF    (adjvpefsvar * (AUX_adjindobjvps + AUX_objandhetvps) = []) AND
              ([benfactNP] * verbadjuncts <> [])
        THEN  vps := vps * (AUX_objandhetvps * AUX_adjppredvps);

        IF    (adjvpefsvar * AUX_adjindobjvps  = []) AND
              ([benfactNP] * verbadjuncts = [])
        THEN  vps := vps * (AUX_indobjvps * AUX_adjppredvps);
        IF    (adjvpefsvar * AUX_adjindobjvps  = []) AND
              ([benfactNP] * verbadjuncts <> [])
        THEN  vps := vps *  AUX_adjppredvps;

        IF    (adjvpefsvar * AUX_objandhetvps = [])
        THEN  vps := vps * (AUX_adjppredvps * AUX_objandhetvps);
        IF    (adjvpefsvar * (AUX_adjindobjvps * AUX_objandhetvps) <> [])
        THEN  vps := vps * AUX_adjppredvps;
      END;

      IF (firstclrelfound AND hetclrelfound AND (adjvpefsvar = [])) AND
          ([benfactNP] * verbadjuncts = [])
      THEN vps := vps * (AUX_indobjvps * AUX_objandhetvps);

      IF (firstclrelfound AND hetclrelfound AND (adjvpefsvar = [])) AND
          ([benfactNP] * verbadjuncts <> [])
      THEN vps := vps *  AUX_objandhetvps;

      IF (firstclrelfound AND hetclrelfound AND (adjvpefsvar <> [])) THEN BEGIN 
        IF    (adjvpefsvar * (AUX_adjindobjvps + AUX_objandhetvps) = []) AND
              ([benfactNP] * verbadjuncts = [])
        THEN  vps := vps * (AUX_indobjvps * AUX_objandhetvps * AUX_adjppredvps);

        IF    (adjvpefsvar * (AUX_adjindobjvps + AUX_objandhetvps) = []) AND
              ([benfactNP] * verbadjuncts <> [])
        THEN  vps := vps * (AUX_objandhetvps * AUX_adjppredvps);

        IF    (adjvpefsvar * AUX_adjindobjvps  = []) AND
              ([benfactNP] * verbadjuncts = [])
        THEN  vps := vps * (AUX_indobjvps * AUX_adjppredvps);
        IF    (adjvpefsvar * AUX_adjindobjvps  = []) AND
              ([benfactNP] * verbadjuncts <> [])
        THEN  vps := vps * AUX_adjppredvps;

        IF    (adjvpefsvar * AUX_objandhetvps = [])
        THEN  vps := vps * (AUX_adjppredvps * AUX_objandhetvps);
        IF    (adjvpefsvar * (AUX_adjindobjvps * AUX_objandhetvps) <> [])
        THEN  vps := vps * AUX_adjppredvps;
      END;

   END;

   IF    (NOT VERBPfound)
   THEN BEGIN
      IF aanobjrelfound
      THEN vps := vps * AUX_aanobjvps;
      IF voorobjrelfound  AND
      ([benfactPP] * verbadjuncts = [])
      THEN vps := vps * AUX_voorobjvps;
      IF voorobjrelfound AND
         (benfactPP IN verbadjuncts)
      THEN adjunctsvar := adjunctsvar + [benfactPP];
      IF preprepobjrelfound
      THEN vps := vps * AUX_preprepobjvps;
      IF prepobjrelfound OR 
	 postvporelfound
      THEN BEGIN
	IF  ((prepkeyvar1 = KEY_aanioprepkey) OR
	     (prepkeyvar2 = KEY_aanioprepkey)
	    )                                            AND
	    (NOT aanobjrelfound AND NOT voorobjrelfound)
	THEN vps := vps * (AUX_prepobjvps + AUX_aanobjvps)
	ELSE IF   ((prepkeyvar1 = KEY_voorioprepkey) OR
		   (prepkeyvar2 = KEY_voorioprepkey)
		  )                                            AND
		  (NOT aanobjrelfound AND NOT voorobjrelfound) 
             THEN IF   ([benfactPP] * verbadjuncts = [])
	          THEN vps := vps * (AUX_prepobjvps + AUX_voorobjvps)
	          ELSE adjunctsvar := adjunctsvar + [benfactPP]
             ELSE vps := vps * AUX_prepobjvps
      END;
      IF locargrelfound AND
         ([locadjunct] * verbadjuncts = [])
      THEN vps := vps * AUX_locargvps;
      IF locargrelfound AND
         (locadjunct IN verbadjuncts)
      THEN verbadjuncts := verbadjuncts + [locadjunct];
      IF dirargrelfound AND
         ([diradjunct] * verbadjuncts = [])
      THEN vps := vps * AUX_dirargvps;
      IF dirargrelfound AND
         (diradjunct IN verbadjuncts)
      THEN adjunctsvar := adjunctsvar + [diradjunct];
      IF dirprepfound AND
         ([diradjunct] * verbadjuncts = [])
      THEN vps := vps * AUX_dirargvps;
      IF dirprepfound AND
         (diradjunct IN verbadjuncts)
      THEN adjunctsvar := adjunctsvar + [diradjunct];
      IF advppredrelfound  
      THEN vps := vps * AUX_advppredvps;
      IF adjppredrelfound AND
         ([resAP] * verbadjuncts = [])
      THEN vps := vps * AUX_adjppredvps;
      IF adjppredrelfound AND
         (resAP IN verbadjuncts)
      THEN adjunctsvar := adjunctsvar + [resAP];
      IF nppredrelfound  AND
         ([resNP] * verbadjuncts = [])
      THEN vps := vps  * AUX_nppredvps;
      IF nppredrelfound AND
         (resNP IN verbadjuncts)
      THEN adjunctsvar := adjunctsvar + [resNP];
      IF prepppredrelfound    AND
         ([resPP] * verbadjuncts = []) 
      THEN vps := vps * AUX_prepppredvps;
      IF prepppredrelfound AND
         (resPP IN verbadjuncts)
      THEN adjunctsvar := adjunctsvar + [resPP];
      IF vpcomplrelfound 
      THEN vps := vps * AUX_vpcomplvps;
      IF prepobj2found
      THEN vps := vps * AUX_twoprepobjvps;
   END !(*if not verbpfound then*)

!(*
This procedure reduces vps on the basis of information internal to VP and
on the basis of information outside the VP that can be used only if not VRfound
It is partially identical to reducematrixvps from the Vprule
*)
END !(*INTreducevps*);


FUNCTION infok:BOOLEAN;
BEGIN
  infok := 
   (
    (NOT (finitenessvar = infinite))  OR
    ( (NOT subjrelfound)     AND
      (NOT postsubjrelfound)
    )
   ); 
!(*
This function guarantees that no subject or postsubject is present in nonfinite
sentences
*)
END !(*infok*);



FUNCTION measureadjundernp(t1:LSSTREE_pstree):BOOLEAN;
     VAR result, CNfound,ADJPfound:BOOLEAN;
         sonlist:LSSTREE_prelnode;
BEGIN
   result :=false; CNfound := false; ADJPfound := false;
   sonlist:=t1^.sons;               
   IF sonlist <> NIL THEN BEGIN
      CNfound := (sonlist^.node^.cat = CN);
      WHILE (NOT CNfound) AND (sonlist^.brother<>NIL) DO BEGIN
	 sonlist := sonlist^.brother;
	 CNfound := (sonlist^.node^.cat = CN);
      END;
   END;
   IF CNfound THEN BEGIN
     sonlist:=sonlist^.node^.sons;               
     IF sonlist <> NIL THEN BEGIN
	ADJPfound := (sonlist^.node^.cat = ADJP);
        IF   ADJPfound 
        THEN result := (measureadj IN sonlist^.node^.ls^.ADJPfield^.actsubcefs);
	WHILE (NOT result) AND (sonlist^.brother<>NIL) DO BEGIN
	   sonlist := sonlist^.brother;
	   ADJPfound := (sonlist^.node^.cat = ADJP);
           IF   ADJPfound 
           THEN result := (measureadj IN sonlist^.node^.ls^.ADJPfield^.actsubcefs);
	END;
     END;
   END;
   measureadjundernp := result;
END {measureadjundernp};

!(*
yields true if the structures is: NP[...head/CN[...ADJP<measure>[...]...]...]
*)



FUNCTION watunderdetp(t1:LSSTREE_pstree):BOOLEAN;
     VAR result:BOOLEAN;
         sonlist:LSSTREE_prelnode;
     BEGIN
     result:=FALSE;
     sonlist:=t1^.sons;                {sonlist=../DETP}
     IF sonlist <> NIL THEN
       IF sonlist^.brother=NIL THEN
         IF sonlist^.node^.cat = DETP  THEN BEGIN
            sonlist := sonlist^.node^.sons;               {sonlist=../QP}
            IF sonlist <> NIL THEN BEGIN
               sonlist := sonlist^.node^.sons;            {sonlist=../Q}
               IF sonlist <> NIL THEN
                 IF sonlist^.node^.cat = Q THEN
                 result := (sonlist^.node^.ls^.Qfield^.key = KEY_s_hq_wat);
            END
         END;
     watunderdetp:=result;
END; !(*watunderdetp*)

{This function yields true if the structure is   NP
                                                 |
                                                DETP
                                                 |
                                                 QP
                                                 |
                                                 Q,key=s_hq_wat
 

}




FUNCTION noofargsok:BOOLEAN;
BEGIN
  noofargsok :=
    (
     (IMPLIES(preadvrelfound, (NOT indobjrelfound)       )) AND
     (IMPLIES(preadvrel2found,( (NOT indobjrelfound) AND
                                (NOT objrelfound)    AND
                                (NOT secondclrelfound)
                              ) 
             )
     )                                                      AND
     (IMPLIES(firstclrelfound, (NOT indobjrelfound)      )) AND 
     (IMPLIES(secondclrelfound,( (NOT indobjrelfound) AND
                                 (NOT objrelfound)    AND
                                 (NOT preadvrel2found)
                               )
             )
     )                                                      AND
     (IMPLIES((firstclrelfound AND 
               preadvrelfound
              ),
              ((NOT indobjrelfound) AND
               (NOT objrelfound)
              )
             )
     )                                                      AND
     (IMPLIES(hetclrelfound, (NOT secondclrelfound)     ))  AND
     (IMPLIES(hetclrelfound, (NOT objrelfound     )     ))
    );
END !(*noofargsok*);


FUNCTION NOplural45(ps::personSETtype;n::numbertype):BOOLEAN;
BEGIN
  Noplural45 :=
   ( NOT ( ( (ps = [4]) OR
             (ps = [5]) OR
             (ps = [4,5])
           )                                       AND
           (n = plural)
         )
   );
!(*
This function is true if the verb form is not only 
fourth or fifth person plural
*)
END !(*NOplural45*);



FUNCTION passiveauxok:BOOLEAN;
BEGIN
passiveauxok :=
( VERBPfound AND V2found                 AND 
  (voicevar=passive)                     AND
  (V2subcvar IN [wordenaux, zijnaux])
);                                        
!(*
If VERBP has been found and V2 has been found and voicevar is passive
THEN V2subcvar must be wordenaux OR zijnaux 
*) 
END !(*passiveauxok*);


FUNCTION postsubjok:BOOLEAN;
BEGIN
postsubjok := IMPLIES(postsubjrelfound, (erposrelfound  OR 
                                         ppinshiftfound OR 
                                         Rinshiftfound
                                        )
                     );
!(*
A postsubjrel requirs the presence of an RADV in shiftrel or in ereposrel
or a PREPP in shiftrel
*) 
END !(*postsubjok*);


FUNCTION prepkeyok(vpk,pk::keytype):BOOLEAN;
BEGIN
  prepkeyok := ((pk = vpk)                                               OR
                ((vpk = KEY_totprepkey) AND (pk = KEY_toeprepkey))       OR
                ((vpk = KEY_metprepkey) AND (pk = KEY_meeprepkey))
               );
END!(*prepkeyok*);



FUNCTION aanvoorprepobjok:BOOLEAN;
BEGIN
aanvoorprepobjok :=
(
   ( (prepkeyvar1 = KEY_aanioprepkey)          AND
     (NOT aanobjrelfound)                      AND
     ((synvpefsvar  * AUX_aanobjvps <> []) OR
      (synvpefsvar2 * AUX_aanobjvps <> [])
     )                                         AND
     (objrelfound )
   )                                                    OR
   ( (prepkeyvar1 = KEY_voorioprepkey)          AND
     (NOT voorobjrelfound)                      AND
     ((synvpefsvar  * AUX_voorobjvps <> []) OR
      (synvpefsvar2 * AUX_voorobjvps <> []) OR
      (benfactPP IN verbadjuncts)
     )                                         AND
     (objrelfound )
   )                                                   
)
END !(*aanvoorprepobjok*);


FUNCTION prepobjok:BOOLEAN;
BEGIN
  prepobjok := false;
  IF  (NOT prepobj1found)
  THEN BEGIN
    prepobjok := true;
  END !(*  IF  (NOT prepobj1found) THEN*)
  ELSE BEGIN
    IF   (NOT prepobj2found)
    THEN BEGIN 
      IF  prepkeyok(verbprepkeyvar1, prepkeyvar1) OR
          prepkeyok(verbprepkeyvar2, prepkeyvar1) OR
          aanvoorprepobjok  
      THEN BEGIN
        prepobjok := true;
      END !(*  IF prepkeyok.. THEN
          *)
      ELSE BEGIN
        prepobjok := false;
      END !(* IF prepkeyok ..
          *);
    END !(* IF   (NOT prepobj2found) THEN*)
    ELSE BEGIN
      IF  (                                                 !(*1*)
            ( prepkeyok(verbprepkeyvar1, prepkeyvar1) AND 
              prepkeyok(verbprepkeyvar2, prepkeyvar2)
            )                                      OR
            ( prepkeyok(verbprepkeyvar2, prepkeyvar1) AND
              prepkeyok(verbprepkeyvar1, prepkeyvar2)
            )
          )
      THEN BEGIN
        prepobjok := true;
      END !(* IF 1 THEN*)
      ELSE BEGIN
        prepobjok := false;
      END !(* IF 1 ELSE*);
    END; !(* IF   (NOT prepobj2found) ELSE *)
  END; !(*  IF  (NOT prepobj1found) ELSE*)
END !(*function prepobjok*);



FUNCTION preporconjfound :BOOLEAN;
BEGIN
  preporconjfound :=
   ( advprepfound        OR
     ( conjrelfound  AND
       (NOT V2found)
     )
   );
!(*
This function is true if either an adverbial prep is found, or
a conjunction has been found, or both have been found
*)
END;



FUNCTION reflexivesok:BOOLEAN;
BEGIN
  reflexivesok :=
(
 (IMPLIES( (reflexivityvar = reflexive),
           reflrelfound
         )
 )                                             AND
 (IMPLIES( (NOT VRfound),
           (IMPLIES( reflrelfound,
                     (reflexivityvar = reflexive)
                   )
           )
         )
 )
);
END !(*reflexivesok*);


FUNCTION Sunderadjp(t1:LSSTREE_pstree):BOOLEAN;
VAR result:BOOLEAN;
    sonlist:LSSTREE_prelnode;
BEGIN
  result:=FALSE;
  sonlist:=t1^.sons;
  IF sonlist <> NIL THEN BEGIN
     result := ( sonlist^.node^.cat IN [SENTENCE,NEG,POS]) OR
               (sonlist^.relation IN 
                    [reflrel, erposrel,postadjrel,omtemodrel, resultrel,
                     sentadvrel, tempadvrel, locadvrel, agvpadvrel
                    ]
               );
     sonlist:=sonlist^.brother;
  END;
  WHILE (NOT result) AND (sonlist<>NIL) DO BEGIN
       result := ( sonlist^.node^.cat IN [SENTENCE,NEG,POS]) OR
               (sonlist^.relation IN 
                    [reflrel, erposrel,postadjrel,omtemodrel, resultrel,
                     sentadvrel, tempadvrel, locadvrel, agvpadvrel
                    ]
               );
       sonlist:=sonlist^.brother
  END;
  Sunderadjp:=result;
END !(*Sunderadjp*);
!(*This function checks whether an Special elements occur under ADJP*)



FUNCTION subordcondsok:BOOLEAN;
BEGIN
  subordcondsok :=
  ( (NOT (senttypevar = subordinateclause) OR (NOT finalpuncfound)) AND
    ((senttypevar = subordinateclause) <= (NOT coordfound))         AND
   ( (NOT(senttypevar = subordinateclause))       OR
     ( (NOT (leftdislocrelfound))             AND
       ( (NOT shiftrelfound)               OR
         (NOT (shiftxpmoodvar =declxpmood))OR
         relprofound 
       )
     )
   )
  );
END !(*subordcondsok*);



!(* ********************************************* *)
FUNCTION SVAOK:BOOLEAN;

   VAR inversionfound: BOOLEAN;

   FUNCTION SVANomshiftok:BOOLEAN;
   BEGIN
      SVANomshiftok :=
	       (IMPLIES( ( 
			  ((shiftrelcases = [Nominative]) AND
			   (NOT specialNP(shiftNPhead))
                          )                                   OR
                          (shiftNPhead = jegenNP)
			 ),
			 (
			  (shiftpersonvar IN verbpersonsvar) AND
			  (shiftnumbervar = verbnumbervar)
			 )
		       )
	       );                                                     
   END !(*SVANomshiftok*);



   FUNCTION SVAspecNomshiftok:BOOLEAN;
   BEGIN
     SVAspecNomshiftok :=
	    (IMPLIES( ( 
		       (shiftrelcases = [Nominative]) AND
		       (specialNP(shiftNPhead))
		      ),
		      (
		       (3 IN verbpersonsvar) 
		      )
		    )
	    );                                                     
   END !(*SVAspecNomshiftok*);



   FUNCTION SVAerok:BOOLEAN;
   BEGIN
     SVAerok :=
	    (IMPLIES( (
		       erinshiftfound
		      ),
		      (
		       (3 IN verbpersonsvar)
		      )
		    )
	    );                                                     
   END !(*SVAerok*);



   FUNCTION SVArelprook:BOOLEAN;
   BEGIN
      SVArelprook :=
	    (IMPLIES( (relprofound AND (NOT subjrelfound)),
		      (3 IN verbpersonsvar)
		    )                                              
	    ); 
   END !(*SVArelprook*);


   FUNCTION shiftetcetera:BOOLEAN;          !(*inside SVAOK*)
   BEGIN
     shiftetcetera :=
     (
      SVANomshiftok     AND
      SVAspecNomshiftok AND
      SVAerok           AND
      SVArelprook
     );
   END !(*shiftetcetera*); !(* Function inside SVAOK*)





   FUNCTION SVAinvok:BOOLEAN;
   BEGIN
     SVAinvok :=
       (IMPLIES( (
		  subjrelfound  AND
		  inversionfound
		 ), 
		 (
		  (0 IN verbpersonsvar     ) AND
		  (verbnumbervar = singular)
		 )
	       )
       );                                                    
   END !(*SVAinok*);



   FUNCTION SVAnormsubjok:BOOLEAN;
   BEGIN
      SVAnormsubjok :=
       (IMPLIES( (
		   subjrelfound         AND
		   (NOT inversionfound) AND
		   (NOT specialNP(subjNPhead))
		 ),
		 (
		  (subjpersonvar IN verbpersonsvar) AND
		  (subjnumbervar = verbnumbervar)
		 )
	       )
       );
   END !(*SVAnormsubjok*);



   FUNCTION SVAspecsubjok:BOOLEAN;
   BEGIN
     SVAspecsubjok :=
       (IMPLIES( (
		   subjrelfound         AND
		   (NOT inversionfound) AND
		   (specialNP(subjNPhead))
		 ),
		 (
		  ( 3 IN verbpersonsvar) 
		 )
	       )
       );
   END !(*SVAspecsubjok*);



   FUNCTION SVApostsubjok:BOOLEAN;
   BEGIN
     SVApostsubjok :=
       (IMPLIES( ((NOT subjrelfound)    AND
		  (postsubjrelfound)
		 ),
		 (
		  (postsubjpersonvar IN verbpersonsvar)AND
		  (postsubjnumbervar = verbnumbervar)
		 )
	       )
       );
   END !(*SVApostsubjok*);




   FUNCTION SVAshiftok:BOOLEAN;
   BEGIN
     SVAshiftok :=
       (IMPLIES( (
		  (NOT subjrelfound)     AND
		  (NOT postsubjrelfound) AND
		  (shiftrelfound)
		 ),
		 (
		  shiftetcetera
		 )
	       )
       );
   END !(*SVAshiftok*);



   FUNCTION SVAelseok:BOOLEAN;
   BEGIN
     SVAelseok :=
       (IMPLIES( (
		  (NOT subjrelfound)          AND
		  (NOT postsubjrelfound)      AND
		  (
		   (NOT shiftrelfound)     OR
		   (
                    (NOT erinshiftfound) AND        
		    (shiftrelcases 
                        <> [Nominative]) AND 
		    (NOT relprofound)    AND
                    (shiftnphead <> jegenNP)
                   )
		  )
		 ),
		 (
		   3 IN verbpersonsvar
		 )
	       )
       );
   END !(*SVAelseok*);





BEGIN  !(*SVAOK*)
!(* check on finitenessvar *)
IF    (finitenessvar = infinite)  THEN  SVAOK := true
ELSE IF (V2modusvar = imperative) 
      THEN  BEGIN
           IF   ((not subjrelfound)    OR 
                 (subjpersonvar IN [2,4])
                ) 
           THEN SVAOK := true
      END
ELSE BEGIN
   inversionfound := 
    ( (subjpersonvar = 2) AND  (subjnumbervar = singular) AND 
      V2found             AND  (tensevar=presenttense)
    );

   SVAOK :=
   ( SVAinvok       AND
     SVAnormsubjok  AND
     SVAspecsubjok  AND
     SVApostsubjok  AND
     SVAshiftok     AND
     SVAelseok
   );

END !(*ELSE*); 
!(*This function checks subject verb agreement*)
END !(*SVAok*);


FUNCTION synvpsok:BOOLEAN;
BEGIN
  synvpsok :=
    ( (synvpefsvar <> [])                         AND
      IMPLIES(VRfound,      (synvpefsvar2 <> [])) AND
      IMPLIES(predadjfound, (adjvpefsvar <> [] ))
    );
END !(*synvpsok*);


FUNCTION temporalNPok(t:LSSTREE_pStree):BOOLEAN;
(*
pre: t=T & T.cat=NP & T.sons<>nil
post: temporalNP(t) <=>
t<> NP[head/CN[head/NOUN<sg>]] AND
t<> NP[detrel/DETP<def>[head/ART],head/CN[head/NOUN]]
*)
VAR rt,frt:LSSTREE_pRelnode;
    wrongtree:BOOLEAN;
BEGIN
  wrongtree:=true;
  frt:= t^.sons;
  wrongtree := frt^.relation IN [head,detrel];
  IF   wrongtree THEN BEGIN
    IF frt^.relation=head THEN BEGIN
      wrongtree:= (frt^.node^.cat=CN) AND (frt^.brother=nil);
      IF wrongtree THEN BEGIN
        rt:=frt^.node^.sons;
        wrongtree:= (rt^.node^.cat=NOUN) AND (rt^.brother=NIL);
        IF wrongtree THEN  wrongtree:=(rt^.node^.ls^.NOUNfield^.number=singular);
      END; 
    END
    ELSE BEGIN
      wrongtree:=(frt^.node^.cat=DETP) AND (frt^.brother<>NIL);
      IF wrongtree THEN wrongtree:=(frt^.node^.ls^.DETPfield^.definite=def);
      IF wrongtree THEN BEGIN
         rt:=frt^.node^.sons;
         wrongtree:= (rt^.node^.cat=ART) AND (rt^.brother=NIL);
      END;
      IF wrongtree THEN BEGIN
         rt:=frt^.brother;
         wrongtree:= (rt^.node^.cat=CN) AND (rt^.brother=NIL)
      END;   
      IF wrongtree THEN rt:=rt^.node^.sons;
      IF wrongtree THEN wrongtree:=(rt^.node^.cat=NOUN) AND (rt^.brother=NIL)
    END;
  END;
  temporalNPok := (NOT wrongtree);
END {temporalNPok};






FUNCTION thetacondsok:BOOLEAN;
BEGIN
thetacondsok := 
(
 (IMPLIES( postsubjrelfound,
           ( (thetavpvar IN [vp100, vp120, vp123]) OR
             ((thetavpvar IN [vp010, vp012]) AND 
              VRfound
             )
           )
         )
 )                                                               AND
 (NOT ( (thetavpvar =vp010)          AND
        (objrelfound)                AND
        (NOT subjrelfound)           AND
        (shiftNPhead <> hetNP)       AND
        (NOT ( erinerposrelfound OR
               erinshiftfound
             )
        )
      )
 )
);

!(*
A postsubjrel can appear only with real intransitives, transitives, 
ditransitives;
The argument of an 1-place ergative verb as an object requires the 
presence of (expletive) er in erposrel or in shiftrel.
!!
This is wrong: Daar kwam een man aan! (So any RADV in shift, erposrel will do)
It also must hold for passives!

or het is in shiftrel (e.g. het regent bakstenen)
*)
END !(*thetacondsok*); 



FUNCTION VPandV2ok:BOOLEAN;
BEGIN
VPandV2ok :=
(VERBPfound OR V2found OR (adjppredrelfound AND advsok)) AND
((V2subcvar IN [hebbenaux, zijnaux, wordenaux]) <= (VPinfsortvar <> teinf)) AND
( ( (NOT VERBPfound) AND (voicevar=active) ) OR
    passiveauxok                             OR
    activeauxok                              OR
    (VERBPfound AND (NOT V2found)
  )
);
!(*
Checks whether the found combination of VERBP and V2, if any is correct
*)                                                   
END !(*VPandV2ok*);


?




<*
HINIT: BEGIN

         teller             := 0;
         aanobjrelfound     := false;
	 accobjfound        := false;
         adhortfound        := false;
         adjpinshiftfound   := false;
         adjppredrelfound   := false;
         adjunctsvar        := [];
         adjvpefsvar        := [];
         adverbialvar       := false;
         advfound           := false;
         advldlfound        := false;
         advpinshiftfound   := false;
         advppredrelfound   := false;
         advprepfound       := false;
         alsofcomplfound    := false;
	 classesvar         := [];
         conjaspectvar      := omegaaspect;
         conjclassvar       := omegaTimeadvclass;
         conjdeixisvar      := omegadeixis;
	 conjkeyvar         := 0;
	 conjpatternsvar    :=[];
	 conjrelfound       := false;
         conjretrovar       := false;
	 conjsentinm1found  := false;
         coordfound         := false;
         countennpfound     := false;
	 defradvrelfound    := false;
	 deixisvar          := omegadeixis;
         dirargNPfound      := false;
         dirargrelfound     := false;
         dirprepfound       := false;
	 secondclrelfound   := false;
	 envvar             := [pospol, negpol, omegapol];
	 erinerposrelfound  := false;
	 erinshiftfound     := false;
	 erposrelfound      := false;
	 erqrelfound        := false;
         expparticle        := 0;
         extracanbeadjsubjvar := FALSE;
	 extraposmodus      := omegamodus;
	 extraposmoodvar    := omegamood;
	 extraposrelfound   := false;
         finalpuncfound     := false;
	 finitenessvar      := omegafin;
         gelievefound       := false;
	 hetclrelfound      := false;
	 hierdaarinRposfound:= false;
	 indobjrelfound     := false;
	 infsortvar         := omegainf;
	 firstclrelfound    := false;
	 leftdislocpuncfound:= false;
	 leftdislocrelfound := false;
         locargrelfound     := false;
	 modusvar           := omegamodus;
	 moodvar            := omegamood;
	 negorposfound      := false;
         nodetnpfound2      := false;
         nodetnpfound       := false;
         nodetNPidvps       := AUX_nodetNPidvps;
         nodetNPidvps2      := AUX_nodetNPidvps;
         nppredrelfound     := false;
	 objrelfound        := false;
         origsynvpefsvar    := [];
         particlekey        := 0;
         postsubjnodetNPfound  := false;
	 postsubjnumbervar  := omeganumber;
	 postsubjpersonvar  := 3;   
	 postsubjrelfound   := false;
         postvporelfound    := false;
         postvrelfound      := false;
         ppinshiftfound     := false;
         preadvandclfound   := false;
	 preadvok           := false;
	 preadvok2          := false;
	 preadvrel2found    := false;
	 preadvrelfound     := false;
         predadjfound       := false;
         prepkeyvar1        := 0;
         prepkeyvar2        := 0;
         prepobjrelfound    := false;
         prepobj1found      := false;
         prepobj2found      := false;
         prepppredrelfound  := false;
         preprepobjrelfound := false;
         prepsynppsvar      := [];
         prosentfound       := false;
	 radvgluefound      := false;
	 reflafterNPfound   := false;
	 reflexivityvar     := notreflexive;
	 reflrelfound       := false;
	 relprofound        := false;
	 reqvar             := [pospol, negpol, omegapol];
	 resultpuncrelfound := false;
	 retrovar           := false;
         Rinshiftfound      := false;
	 senttypevar        := omegaclause;
	 shiftNPhead        := otherNP;
         shiftnptemporal    := false;
	 shiftpersonvar     := 0;
         shiftnodetNPfound  := false;
	 shiftnumbervar     := omeganumber;
	 shiftrelcases      := [];
	 shiftrelfound      := false;
	 shiftxpmoodvar     := declxpmood;
	 stadvfound         := false;
         strandedppfound    := false;
         strandedrelfound   := false;
         subjnodetNPfound   := false;
	 subjNPhead         := otherNP;
	 subjnumbervar      := omeganumber;
	 subjpersonvar      := 0;
	 subjrelfound       := false;
	 synvpefsvar        := [];
	 synvpefsvar2       := [];
         temporalvar        := false;
	 tensevar           := omegatense;
	 thetavpvar         := omegathetavp;
	 unreducedvpsvar    := [];
         v2adjuncts         := [];
	 v2classesvar       := [];      
	 v2found            := false;
	 v2modusvar         := omegamodus;
	 v2subcvar          := mainverb;                          !(*!!*)
	 v2synvpefsvar      := [];
	 v2thetavpvar       := omegathetavp;
         verbadjuncts       := [];
	 verbpersonsvar     := [];
	 verbnumbervar      := omeganumber;
         verbprepkeyvar1    := 0;
         verbprepkeyvar2    := 0;
	 verbpfound         := false;
         Vmatrixheadvar     := false;
	 voicevar           := active;
         voorobjrelfound    := false;
         vpadjuncts         := [];
	 vpclassesvar       := [];      
         vpcomplrelfound    := false;
	 vpinfsortvar       := omegainf;
	 vpmodusvar         := omegamodus;
	 vpsynvpefsvar      := [];
	 vpthetavpvar       := omegathetavp;
	 vrfound            := false;
	 anterelativeok     := true;
       END !(*hinit*);



1: 
       <*
         LOCALCONDITION: ( %SENTENCE.adverbial = false)                  AND
                         ( %SENTENCE.senttype = subordinateclause
                         )                                               AND
                         (
			  ((%SENTENCE.finiteness = finite) AND
			   (%SENTENCE.conjkey <> 0)
			  )                                          OR
			  ( (%SENTENCE.modus = infinitive) AND
			    (%SENTENCE.infsort = inf)
			  )
                         )
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := leftdislocrel;
                              leftdislocrelfound := true;
                            END
       *>


2: 
       <*
         LOCALCONDITION: (%PUNC.key = KEY_kommapunckey)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := puncrel;
                              leftdislocpuncfound := true;
                            END
       *> 

3: 
       <*
         LOCALCONDITION: (%NP.NPhead <> watindefproNP)         AND
                         ((%NP.NPhead <> reducedpersproNP) OR
                          (Nominative IN %NP.cases))           AND
                         ((%NP.NPhead <> hetNP) OR
                          (Nominative IN %NP.cases))           AND
                         (NOT watunderdetp(b))          
                         !(* and other NP's that cannot be shifted *)
         GLOBAL: #CONDITION: (not shiftrelfound)  AND
                             ((leftdislocrelfound AND 
                               (NOT advldlfound)
                              )                         <=
                              (%NP.NPhead = datNP)
                             )
                 #ACTION:   BEGIN
                              SYNREL := shiftrel;
                              shiftxpmoodvar:= %NP.mood;
                              shiftrelfound := true;
                              shiftrelcases := %NP.cases;
                              shiftpersonvar:= %NP.person;
                              shiftnumbervar:= %NP.number;
                              shiftNPhead   := %NP.NPhead;
                              shiftNPtemporal := %NP.temporal;
                              IF (%NP.NPhead = enNP) AND
                                 (%NP.actcomas = [count])
                              THEN countennpfound := true;
                              IF   nodetNP(b) 
                              THEN shiftnodetNPfound := true
                            END
       *>


4: 
       <*
         LOCALCONDITION: (NOT %PREPP.stranded) AND
                         (%PREPP.actsubcefs <> [restprep])
         GLOBAL: #CONDITION: (not shiftrelfound)
                 #ACTION:   BEGIN
                              SYNREL := shiftrel;
                              shiftxpmoodvar := %PREPP.mood;
                              shiftrelfound := true;
                              ppinshiftfound := true;
                            END
       *>

5: 
       <*
         LOCALCONDITION: (%ADVP.actsubcefs * 
                           [sentadv,locadv,tempadv, causadv, 
                            subjvpadv,otheradv] <> []) OR
                         (%ADVP.mood = wh) 
         GLOBAL: #CONDITION: (NOT shiftrelfound)
                 #ACTION:   BEGIN
                              SYNREL := shiftrel;
                              shiftxpmoodvar:= %ADVP.mood;
                              shiftrelfound := true;
                              advpinshiftfound := true;
                            END
       *>

6: 
       <*
         LOCALCONDITION: (%ADJP.mood = wh) AND
                         (%ADJP.eORenForm = NoForm) AND
                         (predicative IN %ADJP.actuseefs)
         GLOBAL: #CONDITION: (NOT shiftrelfound)
                 #ACTION:   BEGIN
                              SYNREL := shiftrel;
                              shiftxpmoodvar:= %ADJP.mood;
                              shiftrelfound := true;
                              adjvpefsvar := %ADJP.adjpatternefs;
                              IF   adjvpefsvar <> []
                              THEN predadjfound := true;
                              adjpinshiftfound := true;
                            END
       *>



7: 
       <*
         LOCALCONDITION: (%RADVP.radvkey = KEY_erRADVkey)
         GLOBAL: #CONDITION: (NOT shiftrelfound)
                 #ACTION:   BEGIN
                              SYNREL := shiftrel;
                              shiftxpmoodvar:= declxpmood;
                              shiftrelfound := true;
                              Erinshiftfound := true;
                              Rinshiftfound := true;
                              advpinshiftfound := true;
                            END
       *>


8: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: ((NOT advprepfound)    OR
                              (NOT %CONJ.adverbial)
                             )                          AND 
                            (not conjrelfound)
                 #ACTION:   BEGIN
                              SYNREL          := conjrel; 
                              conjkeyvar      := %CONJ.key;
                              conjrelfound    := true;
                              conjpatternsvar := %CONJ.conjpatterns;
                              IF (NOT adverbialvar)
                              THEN adverbialvar    := %CONJ.adverbial;
                              IF (NOT temporalvar)
                              THEN temporalvar     := %CONJ.temporal;
                              conjaspectvar   := %CONJ.aspect;
                              conjdeixisvar   := %CONJ.deixis;
                              conjretrovar    := %CONJ.retro;
                              conjclassvar    := %CONJ.class;
                              IF (conjkeyvar = KEY_gelieveCONJkey) OR
                                 (conjkeyvar = KEY_ugelieveCONJkey)
                              THEN gelievefound := true;
                            END
       *>

9: 
       <*
         LOCALCONDITION: (%VERB.modus in [ indicative, 
                                            subjunctive, imperative] )   AND
                         (%VERB.status = bareV) AND
                         Noplural45(%VERB.persons, %VERB.number)
         GLOBAL: #CONDITION: (not conjrelfound)
                 #ACTION:   BEGIN
                              SYNREL          := conjrel;
                              conjrelfound    := true;
                              V2found         := true;
                              finitenessvar   := finite;
                              infsortvar      := omegainf;
                              V2modusvar      := %VERB.modus;
                              tensevar        := %VERB.tense;
                              V2thetavpvar    := %VERB.thetavp;
                              V2synvpefsvar   := %VERB.synvps;
                              V2subcvar       := %VERB.subc;
                              V2classesvar    := %VERB.classes;
                              V2adjuncts      := %VERB.adjuncts;
                              verbpersonsvar  := %VERB.persons;
                              verbnumbervar   := %VERB.number;
                              expparticle     := %VERB.particle;
                              verbprepkeyvar1 := %VERB.prepkey1;
                              verbprepkeyvar2 := %VERB.prepkey2;
                              reflexivityvar  := %VERB.reflexivity;
                            END
       *>



10: 
       <*
         LOCALCONDITION: (Nominative IN %NP.cases)
         GLOBAL: #CONDITION: (NOT ERinshiftfound)
                 #ACTION:   BEGIN
                              SYNREL := subjrel;
                              subjrelfound := true;
                              subjpersonvar := %NP.person;
                              subjnumbervar := %NP.number;
                              subjNPhead    := %NP.NPhead;
                              IF (%NP.NPhead = enNP) AND
                                 (%NP.actcomas = [count])
                              THEN countennpfound := true;
                              IF nodetNP(b) THEN BEGIN
                                 subjnodetnpfound := true;
                              END;
                            END
       *>

11: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: NOT (
                                   V2found                              AND 
                                   (V2subcvar IN [mainverb, modalverb]) AND
                                   (%VERBP.Vmatrixhead = true)
                                 )                                          AND
                             ((preadvrelfound AND V2found AND 
                               (V2synvpefsvar * AUX_indobjvps = [])
                              )                                    <=
                               (NOT %VERBP.objfound)
                             )
                 #ACTION:   BEGIN
                              SYNREL := predrel;
                              IF   (V2subcvar = latenverb)     AND 
                                   (%VERBP.Vmatrixhead = true) 
                              THEN adhortfound := true;
                              verbpfound      := true;
                              IF   (NOT preadvok)
                              THEN preadvok   := %VERBP.preadvok;
                              IF   (NOT preadvok2)
                              THEN preadvok2  := %VERBP.preadvok;
                              objrelfound     := %VERBP.objfound;
                              indobjrelfound  := %VERBP.indobjfound;
                              VPinfsortvar    := %VERBP.infsort;
                              VPthetavpvar    := %VERBP.thetavp;
                              VPsynvpefsvar   := %VERBP.synvpefs;
                              vpadjuncts      := %VERBP.adjuncts;
                              synvpefsvar2    := %VERBP.synvpefs2;
                              VPmodusvar      := %VERBP.modus;
                              voicevar        := %VERBP.voice;
                              IF   (NOT V2found)
                              THEN BEGIN
                                   tensevar := %VERBP.tense;
                                   infsortvar      := %VERBP.infsort;
                                   verbpersonsvar := %VERBP.persons;
                                   verbnumbervar  := %VERBP.number;
                                   IF    %VERBP.modus IN [indicative]
                                   THEN  finitenessvar := finite
                                   ELSE  finitenessvar := infinite;
                               END !(*not V2found*);

                              VRfound := (synvpefsvar2 <> []);
                              Vmatrixheadvar := %VERBP.Vmatrixhead;
                              VPclassesvar   := %VERBP.classes;
                              reflexivityvar := %VERBP.reflexivity;
                              adjvpefsvar    := %VERBP.adjvpefs;
                              IF   adjvpefsvar <> []
                              THEN predadjfound := true;
                              IF %VERBP.countenfound THEN
                              countennpfound := true;
                              locargrelfound := %VERBP.locargfound;
                              dirargrelfound := %VERBP.dirargfound;
                              prepobjrelfound:= %VERBP.prepobjfound;
                              aanobjrelfound := %VERBP.aanobjfound;
                              voorobjrelfound := %VERBP.voorobjfound;
                              nppredrelfound  := %VERBP.nppredfound;
                              adjppredrelfound  := %VERBP.adjpppredfound;
                              prepppredrelfound  := %VERBP.prepppredfound;
                              postvporelfound := %VERBP.postvpofound;
                              strandedrelfound := %VERBP.strandedfound;
                              vpcomplrelfound := %VERBP.vpcomplfound;
                            END
       *>


12: 
       <*
         LOCALCONDITION: (NOT (%PREPP.actsubcefs = [dir])) AND
                         (NOT %PREPP.stranded) AND
                         (%PREPP.actsubcefs * [loc, temp, according ,
                            excepting, topic, caus] <> [])
         GLOBAL: #CONDITION: extrappok(rec^)
                 #ACTION:   BEGIN
                              SYNREL := spostverbrel;
                              anterelativeok := false;
                            END
       *>


13: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (NOT shiftrelfound)
                 #ACTION:   BEGIN
                              SYNREL := shiftrel;
                              shiftrelfound := true;
                              relprofound := true;
                            END
       *>

14: 
       <*
         LOCALCONDITION: (subjvpadv IN %ADVP.actsubcefs)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := subjvpadvrel;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                              stadvfound := true;
                            END
       *>


15:         
       <*
         LOCALCONDITION: (%PUNC.key = KEY_kommapunckey)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL :=puncrel;

                            END
       *>


16: 
       <*
         LOCALCONDITION:((NOT %SENTENCE.adverbial) OR
                         (%SENTENCE.conjkey = KEY_alsofCONJkey)
                        )                                              AND 
                          (%SENTENCE.mood IN 
                            [declarative, yesnointerrogative, 
                               WHinterrogative]
                          )                                            AND
                          (%SENTENCE.senttype = subordinateclause)     AND
                          (
                           (%SENTENCE.finiteness <> infinite) OR
                           (%SENTENCE.infsort IN [teinf, omteinf])
                          )
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := extraposrel;
                              extraposrelfound := true;
                              IF   %SENTENCE.conjkey = KEY_alsofCONJkey
                              THEN alsofcomplfound := true;
                              extraposmoodvar := %SENTENCE.mood;
                              extraposmodus   := %SENTENCE.modus;
                              anterelativeok := false;
                            END
       *>

17: 
       <*
         LOCALCONDITION: (NOT %SENTENCE.adverbial)                       AND
                         (%SENTENCE.mood = relative)  AND
                         (%SENTENCE.senttype = subordinateclause)
         GLOBAL: #CONDITION: (verbpfound             OR
                              (objrelfound       AND
                               postvpook( adjppredrelfound,advppredrelfound,
                                nppredrelfound, prepppredrelfound,
                                strandedrelfound,prepobjrelfound, 
                                locargrelfound,dirargrelfound,particlekey)
                              )
                             )
                 #ACTION:   BEGIN
                              SYNREL := relsentrel;
                              anterelativeok := false;

                            END
       *>

18: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := thanascomplrel;
                              anterelativeok := false;
                            END
       *>


19: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := ascomplrel;
                              anterelativeok := false;
                            END
       *>

20:
       <*
         LOCALCONDITION: (%PUNC.key = KEY_kommaPUNCkey)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := puncrel;
                              resultpuncrelfound := true
                            END
       *>

21: 
       <*
         LOCALCONDITION: (NOT %SENTENCE.adverbial)                AND
                         (%SENTENCE.mood = declarative)           AND
                         (%SENTENCE.senttype = subordinateclause) AND
                         (%SENTENCE.conjkey <> 0)
         GLOBAL: #CONDITION: (NOT (%SENTENCE.finiteness = finite)) OR
                             (resultpuncrelfound)
                 #ACTION:   BEGIN
                              SYNREL := resultrel;
                              anterelativeok := false;
                            END
       *>



22: 
       <*
         LOCALCONDITION: (%PERSPRO.NPhead = hetNP) AND
                         (Accusative IN %PERSPRO.persprocases)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := hetclrel;
                              hetclrelfound := true;
                            END
       *>

23: 
       <*
         LOCALCONDITION: ([Dative, Accusative] 
                             * %PERSPRO.persprocases <> []) AND
                         (%PERSPRO.NPhead <> hetNP)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := firstclrel;
                              firstclrelfound := true;
                            END
       *>

24: 
       <*
         LOCALCONDITION: ([Dative, Accusative] 
                           * %PERSPRO.persprocases <> []) AND
                         (%PERSPRO.NPhead <> hetNP)
                       
         GLOBAL: #CONDITION: (NOT hetclrelfound )              AND
                             (firstclrelfound)                 AND
                             (NOT(firstclrelfound          AND
                                 (%PERSPRO.persprocases= [Dative])))        
                                  !(* to exclude hun  ?or should we allow it?*)
                 #ACTION:   BEGIN
                              SYNREL := secondclrel;
                              secondclrelfound := true;
                            END
       *>


25: 
       <*
         LOCALCONDITION: (NOT %REFLPRO.zelf)
         GLOBAL: #CONDITION: (NOT stadvfound) AND
                             (NOT erqrelfound)       AND
                             ((NOT erposrelfound) OR
                              (erinerposrelfound) )  AND
                             (NOT reflrelfound)      AND
                             (NOT conjsentinm1found)
                 #ACTION:   BEGIN
                              SYNREL := reflrel;
                              reflrelfound := true;
                              IF   (preadvrelfound)
                              THEN reflafterNPfound := true; 
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
!(* has been put into the loop, 
cf. dat er zich hebben voorgedaan vs hij heeft zich er.. *)
                            END
       *>

26: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (NOT postsubjrelfound)  AND
                             (NOT erposrelfound)     AND
                             (NOT defRadvrelfound)   AND
                             (NOT conjsentinm1found) AND
                             (NOT erinshiftfound)
                 #ACTION:   BEGIN
                              SYNREL := erposrel;
                              erposrelfound := true;
                              IF   (%RADVP.radvkey = KEY_erRADVkey)
                              THEN erinerposrelfound := true;
                              IF   ((%RADVP.radvkey =  KEY_hierRADVkey) OR
                                    (%RADVP.radvkey =  KEY_daarRADVkey)
                                   )
                              THEN hierdaarinRposfound := true;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                            END
       *>

27: 
       <*
         LOCALCONDITION:  ( (%PREPP.radvkey = KEY_hierRADVkey) OR
                            (%PREPP.radvkey = KEY_daarRadvkey)
                          )
                          !(* daar,hier in the PREPP *)
         GLOBAL: #CONDITION: (NOT postsubjrelfound)  AND
                             (NOT erposrelfound)     AND
                             (NOT defRadvrelfound)   AND
                             (NOT conjsentinm1found) AND
                             (NOT erinshiftfound)
                 #ACTION:   BEGIN
                              SYNREL := erposrel;
                              erposrelfound := true;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                              stadvfound := true
                            END
       *>


28: 
       <*
         LOCALCONDITION: (%RADVP.radvkey = KEY_daarRadvkey) OR
                         (%RADVP.radvkey = KEY_hierRADVkey)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := defRadvrel;
                              defRadvrelfound := true;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                              stadvfound := true
                            END
       *>


29: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (NOT negorposfound)
                 #ACTION:   BEGIN
                              SYNREL := negrel;
                              negorposfound := true;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                            END
       *>

30: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (NOT negorposfound)
                 #ACTION:   BEGIN
                              SYNREL := posrel;
                              negorposfound := true;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                            END
       *>


31: 
       <*
         LOCALCONDITION: (%ADVP.actsubcefs *[sentadv, causadv] <> [])
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := sentadvrel;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                              stadvfound := true
                            END
       *>


32: 
       <*
         LOCALCONDITION: (%PREPP.actsubcefs * [according, caus] <> []) AND
                         (NOT %PREPP.stranded)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := sentadvrel;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                              stadvfound := true
                            END
       *>


33: 
       <*
         LOCALCONDITION: (tempadv IN %ADVP.actsubcefs)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := tempadvrel;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                              stadvfound := true
                            END
       *>


34: 
       <*
         LOCALCONDITION: (temp IN %PREPP.actsubcefs) AND
                         (NOT %PREPP.stranded)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := tempadvrel;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                              stadvfound := true
                            END
       *>

35: 
       <*
         LOCALCONDITION: (%NP.temporal = true)                        AND
                         (temporalNPok(b))                            AND
                         ((%NP.actsubcs 
                           * [unitnoun,plurunitnoun,daynoun,monthnoun]<>[]) OR
                          (measureadjundernp(b)) 
                         )
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := tempadvrel;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                              stadvfound := true
                            END
       *>

36: 
       <*
         LOCALCONDITION: (%NP.cases <> [Nominative]) AND
                         (NOT (%NP.NPhead IN [hetNP, persproNP, jegenNP, 
                           zegenNP, watindefproNP, reducedpersproNP])) AND
                         (NOT nodetNP(b))
         GLOBAL: #CONDITION: (NOT preadvrelfound) 
                 #ACTION:   BEGIN
                              SYNREL := preadvrel;
                              preadvrelfound := true;
                              IF (%NP.NPhead = enNP) AND
                                 (%NP.actcomas = [count])
                              THEN countennpfound := true;
                            END
       *>



37: 
       <*
         LOCALCONDITION: (%NP.cases <> [Nominative]) AND
                         (NOT (%NP.NPhead IN [hetNP, persproNP, jegenNP, 
                           zegenNP, watindefproNP, reducedpersproNP]))  AND
                         (NOT nodetNP(b))
         GLOBAL: #CONDITION:  preadvrelfound AND
                             (NOT preadvrel2found) 
                 #ACTION:   BEGIN
                              SYNREL := preadvrel;
                              preadvrel2found := true;
                              IF (%NP.NPhead = enNP) AND
                                 (%NP.actcomas = [count])
                              THEN countennpfound := true;
                            END
       *>

38: 
       <*
         LOCALCONDITION: (locadv IN %ADVP.actsubcefs)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := locadvrel;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                              advfound := true;
                            END
       *>

39: 
       <*
         LOCALCONDITION: (NOT %PREPP.stranded)        AND
                         (loc IN %PREPP.actsubcefs)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := locadvrel;
                              advfound := true;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                            END
       *>


40: 
       <*
         LOCALCONDITION: (%RADVP.radvkey <> KEY_erRADVkey  ) AND
                         (%RADVP.radvkey <> KEY_daarRADVkey) AND 
                         (%RADVP.radvkey <> KEY_hierRADVkey)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := locadvrel;
                              advfound := true;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                            END
       *>

41: 
       <*
         LOCALCONDITION: (%ADVP.Qstatus = true) AND
                         (agvpadv IN %ADVP.actsubcefs )
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := agvpadvrel;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                              stadvfound := true;
                            END
       *>


42: 
       <*
         LOCALCONDITION: (%RADVP.radvkey <> KEY_erRADVkey)
         GLOBAL: #CONDITION: (NOT shiftrelfound)
                 #ACTION:   BEGIN
                              SYNREL := shiftrel;
                              shiftxpmoodvar:= %RADVP.mood;
                              shiftrelfound := true;
                              Rinshiftfound := true;
                              advpinshiftfound := true;
                            END
       *>


43: 
       <*
         LOCALCONDITION: %SENTENCE.adverbial                  AND
                         (NOT(%SENTENCE.mood = conditional))      
                        !(* can be a intermediate adverbial sent *)
         GLOBAL: #CONDITION: (NOT conjsentinm1found)
                 #ACTION:   BEGIN
                              IF   %SENTENCE.temporal
                              THEN SYNREL := tempadvrel 
                              ELSE SYNREL := sentadvrel;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                              conjsentinm1found := true;
                            END
       *>


44: 
       <*
         LOCALCONDITION: %SENTENCE.adverbial                 AND
                         (%SENTENCE.finiteness = finite)     AND
                         (NOT(%SENTENCE.mood = conditional))      
                        !(* can be a final adverbial sent *)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              IF   %SENTENCE.temporal
                              THEN SYNREL := posttemprel
                              ELSE SYNREL := postsentadvrel;
                              anterelativeok := false;
                            END
       *>


45: 
       <*
         LOCALCONDITION: (%NP.definite = indef) 
         GLOBAL: #CONDITION: (NOT postsubjrelfound) AND
                             (NOT subjrelfound) AND
                             (NOT preadvrelfound)
                 #ACTION:   BEGIN
                              SYNREL := postsubjrel;
                              postsubjrelfound := true;
                              postsubjpersonvar := %NP.person;
                              postsubjnumbervar := %NP.number;
                              IF (%NP.NPhead = enNP) AND
                                 (%NP.actcomas = [count])
                              THEN countennpfound := true;
                              IF nodetNP(b) 
                              THEN postsubjnodetNPfound:=true;
                            END
       *>


46: 
       <*
         LOCALCONDITION: (%SENTENCE.adverbial)
                         !(* can be an initial conjsent *)
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := leftdislocrel;  !(* cf als.. dan *)
                              leftdislocrelfound := true;
                              advldlfound := true;
                            END
       *>


47: 
       <*
         LOCALCONDITION: (%RADVP.radvkey = KEY_erRADVkey)
         GLOBAL: #CONDITION: (NOT erqrelfound)             AND
                             (
                              (erposrelfound  AND
                               (NOT erinerposrelfound)
                              )                        OR
                              erinshiftfound
                             )                             AND
                             (NOT postsubjrelfound)        AND
                             (NOT conjsentinm1found)      
                 #ACTION:   BEGIN
                              SYNREL := erqrel;
                              erqrelfound := true;
                              IF preadvrelfound THEN preadvok := true;
                              IF preadvrel2found THEN preadvok2 := true;
                            END
       *>


48: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: erinerposrelfound OR
                             (hierdaarinRposfound)
                 #ACTION:   BEGIN
                              SYNREL := gluerel;
                              radvgluefound := true;
                            END
       *>



49:   !(* cf. 1 from VP *) 
       <*
         LOCALCONDITION: (%NP.animate in [ yesanimate, omegaanimate]) AND
                         (Dative IN %NP.cases) AND 
                         (NOT(%NP.NPhead IN [reducedpersproNP, jegenNP, 
                            zegenNP, hetNP]))                           
         GLOBAL: #CONDITION: V2found AND
                             ((V2synvpefsvar * AUX_indobjvps <> []) OR
                              (benfactNP IN v2adjuncts)
                             )
                 #ACTION:   BEGIN
                              SYNREL := indobjrel;
                              indobjrelfound := true;
                              IF (%NP.NPhead = enNP) AND
                                 (%NP.actcomas = [count])
                              THEN countennpfound := true;
                              IF nodetNP(b) THEN BEGIN
                                 nodetNPfound := true;
                                 nodetNPidvps := nodetNPidvps 
                                                    * AUX_ionodetidvps;
                              END;
                            END
       *>

50: !(* cf. 2 from VP *) 
       <*
         LOCALCONDITION: (NOT %PREPP.stranded)               AND
                         (%PREPP.headkey = KEY_aanioprepkey) AND
                         (%PREPP.radvkey = 0) 
         GLOBAL: #CONDITION: V2found AND
                             (V2synvpefsvar * AUX_aanobjvps <> [])
                 #ACTION:   BEGIN
                              SYNREL := aanobjrel;
                              aanobjrelfound := true;
                              !(* preadvok := true; *)
                            END
       *>
 

51: !(* cf. 3 from VP *)  
       <*
         LOCALCONDITION: (NOT %PREPP.stranded)                AND
                         (%PREPP.headkey = KEY_voorioprepkey) AND
                         (%PREPP.radvkey = 0) 
         GLOBAL: #CONDITION: V2found AND
                             ((V2synvpefsvar * AUX_voorobjvps <> []) OR
                              (benfactPP IN v2adjuncts)
                             )
                 #ACTION:   BEGIN
                              SYNREL := voorobjrel;
                              voorobjrelfound := true;
                              !(* preadvok := true; *)
                            END
       *>



52:  !(* cf. 4 from VP *) 
       <*
         LOCALCONDITION: ([nominative, accusative] * %NP.cases <> []) AND
                         (%NP.cases <> [Nominative]) AND
                         (NOT(%NP.NPhead IN [reducedpersproNP, jegenNP, 
                            zegenNP, hetNP]))                          
         GLOBAL: #CONDITION: V2found                               AND
                             (V2synvpefsvar * 
                                 ( AUX_objvps + [synzijn])<> [])   AND
                             ((V2synvpefsvar * AUX_indobjvps = []) 
                                  <= (NOT preadvrelfound)
                             )
                 #ACTION:   BEGIN
                              SYNREL := objrel;
                              IF    NOT (nominative IN %NP.cases) 
                              THEN  accobjfound := true;
                              objrelfound := true;
                              IF (%NP.NPhead = enNP) AND
                                 (%NP.actcomas = [count])
                              THEN countennpfound := true;
                              IF nodetNP(b) THEN BEGIN
                                 nodetNPfound := true;
                                 nodetNPidvps := nodetNPidvps 
                                                    * AUX_donodetidvps;
                              END;
                            END
       *>


53:  !(* cf. 5 from VP *)  
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: (NOT prepobj2found)              AND
                             (%PREPP.radvkey = 0)             AND
                             V2found  AND
                             ((V2synvpefsvar * ( AUX_aanobjvps + 
                               AUX_voorobjvps + AUX_prepobjvps) <> [])  OR
                              ((%PREPP.headkey = KEY_voorioprepkey)AND
                               (benfactPP IN v2adjuncts)
                              )
                             )
                 #ACTION:   BEGIN
                              SYNREL := prepobjrel;
                              prepobjrelfound := true;
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepkeyvar2   := %PREPP.headkey
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepkeyvar1   := %PREPP.headkey
                              END !(*if prepobj1found else*);
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepobj2found := true
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepobj1found := true
                              END !(*if prepobj1found else*);
                              IF   %PREPP.stranded
                              THEN strandedPPfound := true;
                            END
       *>

54:  !(* cf. 6 from VP *)  
       <*
         LOCALCONDITION: (dir IN %PREPP.actsubcefs)
         GLOBAL: #CONDITION: (NOT preprepobjrelfound)  AND
                             (%PREPP.radvkey = 0)      AND
                             V2found  AND
                             ((V2synvpefsvar * AUX_dirargvps <> []) OR
                              (diradjunct IN v2adjuncts)
                             )
                 #ACTION:   BEGIN
                              SYNREL := dirargrel;
                              dirargrelfound := true;
                              IF   %PREPP.stranded
                              THEN strandedPPfound := true;
                            END
       *>


55: !(* cf. 7 from VP *) 
       <*
         LOCALCONDITION: (diradv IN %ADVP.actsubcefs)
         GLOBAL: #CONDITION: (NOT preprepobjrelfound) AND
                             V2found  AND
                             ((V2synvpefsvar * AUX_dirargvps <> []) OR
                              (diradjunct IN v2adjuncts)
                             )
                 #ACTION:   BEGIN
                              SYNREL := dirargrel;
                              dirargrelfound := true;
                            END
       *>


56: !(* cf. 8 from VP *)  
       <*
         LOCALCONDITION: (loc IN %PREPP.actsubcefs)
         GLOBAL: #CONDITION: (NOT preprepobjrelfound)  AND
                             (%PREPP.radvkey = 0) AND
                             V2found  AND
                             ((V2synvpefsvar * AUX_locargvps <> []) OR
                              (locadjunct IN v2adjuncts)
                             )
                 #ACTION:   BEGIN
                              SYNREL := locargrel;
                              locargrelfound := true;
                              IF   %PREPP.stranded
                              THEN strandedPPfound := true;
                            END
       *>


57:  !(* cf. 9 from VP *)  
       <*
         LOCALCONDITION: (locadv IN %ADVP.actsubcefs) 
         GLOBAL: #CONDITION: (NOT preprepobjrelfound) AND
                             V2found  AND
                             ((V2synvpefsvar * AUX_locargvps <> []) OR
                              (locadjunct IN v2adjuncts)
                             )
                 #ACTION:   BEGIN
                              SYNREL := locargrel;
                              locargrelfound := true;
                            END
       *>



58:  !(* cf. 10 from VP *)  
       <*
         LOCALCONDITION: (%PREPP.actsubcefs * [ other] <> [])  AND
                         (NOT %PREPP.stranded)
         GLOBAL: #CONDITION: (NOT preprepobjrelfound)    AND
                             (%PREPP.radvkey = 0) AND
                             V2found  AND
                             ((V2synvpefsvar * AUX_prepppredvps <> []) OR
                              (resPP IN v2adjuncts)
                             )
                 #ACTION:   BEGIN
                              SYNREL := predrel;
                              prepppredrelfound := true;
                            END
       *>

59:  !(* cf. 11 from VP *)  
       <*
         LOCALCONDITION: (%ADVP.actsubcefs * [otherAdv] <> [])
         GLOBAL: #CONDITION: (NOT preprepobjrelfound) AND
                             V2found  AND
                             (V2synvpefsvar * AUX_prepppredvps <> [])
                 #ACTION:   BEGIN
                              SYNREL := predrel;
                              advppredrelfound := true;
                            END
       *>

60:  !(* cf. 12 from VP *)  
       <*
         LOCALCONDITION: (%NP.cases <> [Nominative]) AND
                         (accusative IN %NP.cases)   AND
                         (NOT(%NP.NPhead IN [reducedpersproNP, hetNP, jegenNP,
                                 zegenNP]))          AND
                         (%NP.posspred = true)  !(*NP can be used predicatively*) 
         GLOBAL: #CONDITION: (NOT preprepobjrelfound) AND
                             V2found  AND
                             ((V2synvpefsvar * AUX_nppredvps <> [])  OR
                              (resPP IN v2adjuncts)
                             )
                 #ACTION:   BEGIN
                              SYNREL := predrel;     
                              nppredrelfound :=true;
                              IF (%NP.NPhead = enNP) AND
                                 (%NP.actcomas = [count])
                              THEN countennpfound := true;
                            END
       *>


61: !(* cf. 13 from VP *) 
       <*
         LOCALCONDITION: ( predicative IN %ADJP.actuseefs) AND
                         (( %ADJP.eORenForm  <> NoForm ) <= (NOT V2found)) AND
                         (NOT Sunderadjp(b))
         GLOBAL: #CONDITION: (NOT preprepobjrelfound) AND
                             (V2found  <= 
                               ((V2synvpefsvar * AUX_adjppredvps <> []) OR
                                (resAP IN v2adjuncts)
                               )
                             )                                              AND
                             ((NOT V2found) <= (attributive IN %ADJP.actuseefs))
                 #ACTION:   BEGIN
                              SYNREL := predrel;
                              adjppredrelfound := true;
                              adjvpefsvar := %ADJP.adjpatternefs;
                              IF   adjvpefsvar <> []
                              THEN predadjfound := true;
                              IF (NOT V2found) 
                              THEN finitenessvar := infinite;
                            END
       *>


62:  !(* for temporal PREP introducing an adverbial clause *)
       <*
         LOCALCONDITION: (temp IN %PREP.subcs)              AND
                         (%PREP.synpps * 
                             [synTHATSENT, synOPENTESENT] <> []
                         )
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := modrel;
                              prepsynppsvar := %PREP.synpps;
                              advprepfound  := true;
                              temporalvar   := true;
                              adverbialvar  := true;     
                            END
       *>

63: !(* cf. 15 from VP *) !(* for stranded preprep heads *)
       <*
         LOCALCONDITION: (%PREPP.stranded) 
         GLOBAL: #CONDITION: (NOT prepobj2found) AND
                             (NOT strandedPPfound)   AND
                             (NOT preprepobjrelfound) AND
                             V2found 
                 #ACTION:   BEGIN
                              SYNREL := strandedrel;
                              strandedrelfound := true;
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepkeyvar2   := %PREPP.headkey
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepkeyvar1   := %PREPP.headkey
                              END !(*if prepobj1found else*);
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepobj2found := true
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepobj1found := true
                              END !(*if prepobj1found else*);
                            END
       *>



64: !(* cf. 16 from VP *) !(* for stranded adverbials *)
       <*
         LOCALCONDITION: (%PREPP.actsubcefs * [instrum,comitative] <> [])  AND 
                         (%PREPP.stranded) 
         GLOBAL: #CONDITION: (NOT strandedPPfound) AND
                             V2found 
                 #ACTION:   BEGIN
                              SYNREL := strandedrel;
                              strandedrelfound := true;
                            END
       *>


65:  !(* cf. 17 from VP *)  
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: V2found AND
                             (expparticle = %PART.key)
                 #ACTION:   BEGIN
                              SYNREL := partrel;
                              particlekey := %PART.key;
                            END
       *>


66:  !(* cf. 21 from VP *) 
       <*
         LOCALCONDITION: (%PREPP.radvkey = 0)          AND
                         (NOT %PREPP.stranded)
         GLOBAL: #CONDITION: (NOT prepobj2found) AND
                             V2found 
                 #ACTION:   BEGIN
                              SYNREL := prepobjrel;
                              preprepobjrelfound := true;
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepkeyvar2   := %PREPP.headkey
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepkeyvar1   := %PREPP.headkey
                              END !(*if prepobj1found else*);
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepobj2found := true
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepobj1found := true
                              END !(*if prepobj1found else*);
                            END
       *>



67:    !(* cf. 22 from VP *) 
       <*
         LOCALCONDITION:  (NOT %PREPP.stranded)   AND
                          (%PREPP.radvkey = 0)
         GLOBAL: #CONDITION: (NOT prepobj2found)  AND
                             postvpook(
                           adjppredrelfound,advppredrelfound,nppredrelfound,
                           prepppredrelfound,strandedrelfound,prepobjrelfound,
                           locargrelfound,dirargrelfound,particlekey) AND
                             V2found  AND
                             ((V2synvpefsvar * ( AUX_prepobjvps
                              + AUX_aanobjvps + AUX_voorobjvps) <> []) OR
                              (benfactPP IN v2adjuncts)
                             )
                 #ACTION:   BEGIN
                              SYNREL := postvporel;
                              postvporelfound := true;
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepkeyvar2   := %PREPP.headkey
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepkeyvar1   := %PREPP.headkey
                              END !(*if prepobj1found else*);
                              IF   (prepobj1found)
                              THEN BEGIN
                                prepobj2found := true
                              END !(*if prepobj1found then*)
                              ELSE BEGIN
                                prepobj1found := true
                              END !(*if prepobj1found else*);
                            END
       *>


68:  !(* cf. 23 from VP *) 
       <*
         LOCALCONDITION:  (NOT %PREPP.stranded)  AND
                          (%PREPP.radvkey = 0)   AND
                          (%PREPP.actsubcefs * [doorby, instrum, 
                                  comitative] <> [])
         GLOBAL: #CONDITION: postvok(adjppredrelfound,advppredrelfound,
                           nppredrelfound,prepppredrelfound,strandedrelfound,
                           prepobjrelfound,locargrelfound,dirargrelfound,
                           objrelfound,indobjrelfound,particlekey) AND V2found
                 #ACTION:   BEGIN
                              SYNREL := postverbrel;
                              postvrelfound := true;
                            END
       *>


69:  !(* cf. 25 from VP *) 
       <*
         LOCALCONDITION: (%PREPP.actsubcefs * [instrum, comitative!(*, voor!!*)] 
                                  <> []) AND
                         (%PREPP.radvkey = 0)                              AND
                         (NOT %PREPP.stranded)
         GLOBAL: #CONDITION: V2found
                 #ACTION:   BEGIN
                              SYNREL := vpadvrel;
                              preadvok := true;
                            END
       *>


70:    !(* cf. 26 from VP *)  
       <*
         LOCALCONDITION: (%ADVP.actsubcefs * [vpadv] <> []) AND
                         (%ADVP.Qstatus = false)
         GLOBAL: #CONDITION: V2found
                 #ACTION:   BEGIN
                              SYNREL   := vpadvrel;
                              preadvok := true;
                            END
       *>

71:  !(* for nontemporal PREP introducing an adverbial clause *)
       <*
         LOCALCONDITION: (%PREP.subcs - [temp] <> [])              AND
                         (%PREP.synpps * 
                             [synTHATSENT, synOPENTESENT] <> []
                         )
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := modrel;
                              prepsynppsvar := %PREP.synpps;
                              advprepfound  := true;
                              adverbialvar  := true;     
                            END
       *>


72:  !(* cf. 28 from VP *)  
       <*
         LOCALCONDITION: (%ADVP.actsubcefs * [agvpadv] <> []) AND
                         (%ADVP.Qstatus = false)
         GLOBAL: #CONDITION: V2found
                 #ACTION:   BEGIN
                              SYNREL   := agvpadvrel;
                              preadvok := true;
                            END
       *>


73: !(* cf. 34 from the VP rule *) 
       <*
         LOCALCONDITION:  ([nominative, accusative] * %NP.cases <> []) AND
                         (%NP.cases <> [Nominative]) AND
                         (NOT(%NP.NPhead IN [reducedpersproNP, jegenNP, 
                            zegenNP, hetNP]))                          
         GLOBAL: #CONDITION: (NOT preprepobjrelfound) AND
                             V2found  AND
                             ((V2synvpefsvar * AUX_dirargvps <> []) OR
                              (diradjunct IN v2adjuncts)
                             )
                 #ACTION:   BEGIN
                              SYNREL := dirargrel;
                              dirargrelfound := true;
                              dirargNPfound  := true;
                              IF nodetNP(b) THEN BEGIN
                                 nodetNPfound := true;
                                 nodetNPidvps := nodetNPidvps 
                                                    * AUX_dirnodetidvps;
                              END;
                            END
       *>


74: 
       <*
         LOCALCONDITION: (dir IN %PREP.subcs)        AND
                         (%PREP.preptype = postprep) 
         GLOBAL: #CONDITION: (NOT dirargrelfound) OR
                             (dirargNPfound) AND
                             V2found  AND
                             (V2synvpefsvar * AUX_dirargvps <> [])
                 #ACTION:   BEGIN
                              SYNREL := partrel;
                              dirprepfound := true; 
                            END
       *>

75: 
       <*
         LOCALCONDITION: true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := puncrel;
                              finalpuncfound := true;
                            END
       *>


76: 
       <*
         LOCALCONDITION: (%SENTENCE.finiteness = infinite)        AND
                         (%SENTENCE.mood = declarative)           AND
                         ((%SENTENCE.adverbial)               OR
                          (%SENTENCE.conjkey = KEY_omCONJkey)
                         )
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              IF   %SENTENCE.temporal
                              THEN SYNREL := posttemprel
                              ELSE SYNREL := postsentadvrel;
                              anterelativeok := false;
                            END
       *>


77: 
       <*
         LOCALCONDITION: (%VERBP.voice = passive)     AND
                         (%VERBP.Vmatrixhead = true)  AND
                         (%VERBP.modus = pastpart)    AND
                         (%VERBP.foundauxes = [])     AND
                         (%VERBP.synvpefs2 =[])       AND
                         (%VERBP.objfound = false)    AND
                         (%VERBP.indobjfound = false) AND
                         (%VERBP.adjvpefs = [])       AND
                         (%VERBP.countenfound = false)AND
                         (%VERBP.vpcomplfound =false) 
         GLOBAL: #CONDITION: (NOT preprepobjrelfound) AND
                             V2found                  AND
                             (V2synvpefsvar * AUX_vpcomplvps <> [])
                 #ACTION:   BEGIN
                              SYNREL := complrel;
                              vpcomplrelfound := true;
                            END
       *>



78: 
       <*
         LOCALCONDITION: %PROSENT.so = true
         GLOBAL: #CONDITION: V2found AND
                             (V2synvpefsvar * AUX_soprosentvps <> [])
                 #ACTION:   BEGIN
                              SYNREL := objrel;
                              prosentfound := true;
                            END
       *>



79: 
       <*
         LOCALCONDITION: %COORD.Sintroducer = true
         GLOBAL: #CONDITION: true
                 #ACTION:   BEGIN
                              SYNREL := argrel;
                              COORDfound := true;
                            END
       *>


HFINAL: #CONDITION: postsubjok                                           AND
                    countenOK                                            AND
                    ((NOT leftdislocpuncfound) OR (shiftrelfound ))      AND
                    VPandV2ok                                            AND
                    conjandverbok                                        AND
                    allpreadvsok                                         AND
                    SVAOK                                                AND
                    noofargsok                                           AND
                    reflexivesok                                         AND
                    ( (NOT(shiftrelcases = [Nominative])) OR
                      ((NOT subjrelfound) AND (NOT postsubjrelfound))
                    )                                                    AND
                    (particlekey = expparticle)                          AND
                    infok                                                AND
                    dirargnpok                                           AND
                    IMPLIES(conjsentinm1found, 
                      (postvok(adjppredrelfound,advppredrelfound,
                           nppredrelfound,prepppredrelfound,strandedrelfound,
                           prepobjrelfound,locargrelfound,dirargrelfound,
                           objrelfound,indobjrelfound,particlekey)
                           OR verbpfound))


        #ACTION: BEGIN
                 !(*
                    Determine values of thetavpvar, synvpefsvar, classesvar 
                 *)

                    detargstrANDclasses(
                                     thetavpvar , vpsynvpefsvar , classesvar , 
                                     verbadjuncts , adjunctsvar );


                    !(* modusvar: *)
                    IF   V2found
                    THEN modusvar := V2modusvar
                    ELSE modusvar := VPmodusvar;

                    !(* deixisvar: *)
                    IF   (tensevar = presenttense)
                    THEN deixisvar := presentdeixis
                    ELSE IF (tensevar = pasttense)
                         THEN deixisvar := pastdeixis
                         ELSE IF    (modusvar = imperative)
                              THEN deixisvar := presentdeixis;

                    IF gelievefound THEN deixisvar := presentdeixis;


                    !(* conditions on thetavp *)
                    IF  (thetacondsok AND
                         prepobjok
                        )
                    THEN BEGIN         
                      unreducedvpsvar := synvpefsvar;
                      extracanbeadjsubjvar := extracanbeadjsubj;

                      IF   (NOT VRfound) 
                      THEN BEGIN
			 IntReducevps(synvpefsvar);

			 ExtReducevps(synvpefsvar);

                         IF (subjnodetNPfound OR shiftnodetNPfound) 
                         THEN BEGIN
                           nodetNPidvps := nodetNPidvps * 
                               (AUX_subjnodetidvps + AUX_donodetidvps);
                           nodetNPfound := true; 
                         END;
                         IF postsubjnodetNPfound
                         THEN BEGIN
                           nodetNPidvps := 
                              nodetNPidvps * AUX_subjnodetidvps;
                           nodetNPfound := true;
                         END;
                         IF   (nodetNPfound)
                         THEN synvpefsvar := synvpefsvar * nodetNPidvps;

                      END
                      ELSE BEGIN
                         Intreducevps(synvpefsvar);
                         EXTreducevps(synvpefsvar2);
                         IF (subjnodetNPfound OR shiftnodetNPfound )
                         THEN IF NOsubjraisingfound(thetavpvar,synvpefsvar)
                              THEN BEGIN
                                 nodetNPidvps := nodetNPidvps * 
                                      (AUX_subjnodetidvps + AUX_donodetidvps);
                                 nodetNPfound := true; 
                              END
                              ELSE IF (onlysubjraisingfound
                                              (thetavpvar, synvpefsvar))
                              THEN BEGIN
                                 nodetNPidvps2 := nodetNPidvps2 * 
                                      (AUX_subjnodetidvps + AUX_donodetidvps);
                                 nodetNPfound2:= true; 
                              END;
                         IF postsubjnodetNPfound
                         THEN IF NOsubjraisingfound(thetavpvar,synvpefsvar)
                              THEN BEGIN
                                 nodetNPidvps := nodetNPidvps * 
                                                  AUX_subjnodetidvps ;
                                 nodetNPfound := true; 
                              END
                              ELSE IF (onlysubjraisingfound
                                               (thetavpvar, synvpefsvar))
                              THEN BEGIN
                                 nodetNPidvps2 := nodetNPidvps2 * 
                                      AUX_subjnodetidvps ;
                                 nodetNPfound2:= true; 
                              END;
                         IF   (nodetNPfound)
                         THEN synvpefsvar := synvpefsvar * nodetNPidvps;
                         IF   (nodetNPfound2)
                         THEN synvpefsvar2 := synvpefsvar2 * nodetNPidvps2;
                      END;

                      IF predadjfound THEN BEGIN
                         checkpredadj(adjvpefsvar);
                      END;

		      IF   (synvpsok)
		      THEN BEGIN
                    
			 !(* determine moodvar: cases 1-6 *)
			 moodvar     := omegamood;
                         senttypevar := omegaclause;
                         origsynvpefsvar := synvpefsvar;
                         
                         IF    (NOT adverbialvar)
                         THEN  determinemood16(moodvar, senttypevar);
                        
			 IF (moodvar <> omegamood)   AND
                            subordcondsok          AND
                            argspresent
			 THEN BEGIN
			   MAKET_SENTENCE;
			   $SENTENCE.req         := reqvar ;
			   $SENTENCE.env         := envvar ;
			   $SENTENCE.mood        := moodvar ;
			   $SENTENCE.senttype    := senttypevar;
			   $SENTENCE.voice       := voicevar ;
			   $SENTENCE.PROsubject  := (finitenessvar = infinite );
			   $SENTENCE.synvpefs    := synvpefsvar ;
			   $SENTENCE.thetavp     := thetavpvar ;
			   $SENTENCE.modus       := modusvar ;
                           computeaktarts( classesvar,
			                   $SENTENCE.aktionsarts
                                         );
			   $SENTENCE.aspect      := omegaaspect ;
			   $SENTENCE.deixis      := deixisvar ;
			   $SENTENCE.retro       :=  false ;
			   $SENTENCE.finiteness  := finitenessvar ;
			   $SENTENCE.infsort     := infsortvar;
			   $SENTENCE.superdeixis := omegadeixis ;
			   $SENTENCE.VRcompl     := false ;
			   $SENTENCE.conjkey     := conjkeyvar;
                           $SENTENCE.adverbial   := adverbialvar;
                           $SENTENCE.temporal    := temporalvar;
                           $SENTENCE.conjaspect  := conjaspectvar;
                           $SENTENCE.conjclass   := conjclassvar;
                           $SENTENCE.conjdeixis  := conjdeixisvar;
                           $SENTENCE.conjretro   := conjretrovar;
                           $SENTENCE.adjuncts    := adjunctsvar;
			 END; !(*if moodvar <> omegamood then, cases 1-6*)
	

			 !(* determine moodvar; case 7 *)
			 moodvar := omegamood;
                         senttypevar := omegaclause;
                         synvpefsvar := origsynvpefsvar;

                         IF (NOT adverbialvar)
                         THEN determinemood7(moodvar, senttypevar);
			 IF (moodvar <> omegamood) AND
                            subordcondsok          AND
                            argspresent
			 THEN BEGIN
			   MAKET_SENTENCE;
			   $SENTENCE.req  := reqvar ;
			   $SENTENCE.env  := envvar ;
			   $SENTENCE.mood := moodvar ;
			   $SENTENCE.senttype := senttypevar;
			   $SENTENCE.voice := voicevar ;
			   $SENTENCE.PROsubject := (finitenessvar = infinite );
			   $SENTENCE.synvpefs := synvpefsvar ;
			   $SENTENCE.thetavp := thetavpvar  ;
			   $SENTENCE.modus := modusvar ;
                           computeaktarts( classesvar,
			                   $SENTENCE.aktionsarts
                                         );
			   $SENTENCE.aspect := omegaaspect ;
			   $SENTENCE.deixis := deixisvar ;
			   $SENTENCE.retro :=  false ;
			   $SENTENCE.finiteness := finitenessvar ;
			   $SENTENCE.infsort := infsortvar;
			   $SENTENCE.superdeixis := omegadeixis  ;
			   $SENTENCE.VRcompl := false ;
			   $SENTENCE.conjkey := conjkeyvar;
                           $SENTENCE.adverbial   := adverbialvar;
                           $SENTENCE.temporal    := temporalvar;
                           $SENTENCE.conjaspect  := conjaspectvar;
                           $SENTENCE.conjclass   := conjclassvar;
                           $SENTENCE.conjdeixis  := conjdeixisvar;
                           $SENTENCE.conjretro   := conjretrovar;
                           $SENTENCE.adjuncts    := adjunctsvar;
			 END; !(*if moodvar <> omegamood then, case 7*)
	

			 !(* determine moodvar, case 8 *)
			 moodvar := omegamood;
                         senttypevar := omegaclause;
                         synvpefsvar := origsynvpefsvar;

                         IF   (NOT adverbialvar)
                         THEN determinemood8(moodvar, senttypevar);
                 
			 IF (moodvar <> omegamood)     AND
                            subordcondsok              AND
                            argspresent
			 THEN BEGIN
			   MAKET_SENTENCE;
			   $SENTENCE.req  := reqvar ;
			   $SENTENCE.env  := envvar ;
			   $SENTENCE.mood := moodvar ;
			   $SENTENCE.senttype := senttypevar;
			   $SENTENCE.voice := voicevar ;
			   $SENTENCE.PROsubject := (finitenessvar = infinite );
			   $SENTENCE.synvpefs := synvpefsvar ;
			   $SENTENCE.thetavp := thetavpvar ;
			   $SENTENCE.modus := modusvar ;
                           computeaktarts( classesvar,
			                   $SENTENCE.aktionsarts
                                         );
			   $SENTENCE.aspect := omegaaspect ;
			   $SENTENCE.deixis := deixisvar ;
			   $SENTENCE.retro :=  false ;
			   $SENTENCE.finiteness := finitenessvar ;
			   $SENTENCE.infsort := infsortvar;
			   $SENTENCE.superdeixis := omegadeixis  ;
			   $SENTENCE.VRcompl := false ;
			   $SENTENCE.conjkey := conjkeyvar;
                           $SENTENCE.adverbial   := adverbialvar;
                           $SENTENCE.temporal    := temporalvar;
                           $SENTENCE.conjaspect  := conjaspectvar;
                           $SENTENCE.conjclass   := conjclassvar;
                           $SENTENCE.conjdeixis  := conjdeixisvar;
                           $SENTENCE.conjretro   := conjretrovar;
                           $SENTENCE.adjuncts    := adjunctsvar;
			 END; !(*if moodvar <> omegamood then, case 8*)

	
			 !(* determination of moodvar, cases 9-14 *)


			 moodvar := omegamood;
                         senttypevar := omegaclause;
                         synvpefsvar := origsynvpefsvar;

                         IF   (NOT adverbialvar)
                         THEN determinemood914(moodvar, senttypevar);

                 
			 IF (moodvar <> omegamood)    AND
                            subordcondsok             AND
                            argspresent
			 THEN BEGIN

			   MAKET_SENTENCE;
			   $SENTENCE.req  := reqvar ;
			   $SENTENCE.env  := envvar ;
			   $SENTENCE.mood := moodvar ;
			   $SENTENCE.senttype := senttypevar;
			   $SENTENCE.voice := voicevar ;
			   $SENTENCE.PROsubject := (finitenessvar = infinite );
			   $SENTENCE.synvpefs := synvpefsvar ;
			   $SENTENCE.thetavp := thetavpvar ;
			   $SENTENCE.modus := modusvar ;
                           computeaktarts( classesvar,
			                   $SENTENCE.aktionsarts
                                         );
			   $SENTENCE.aspect := omegaaspect ;
			   $SENTENCE.deixis := deixisvar ;
			   $SENTENCE.retro :=  false ;
			   $SENTENCE.finiteness := finitenessvar ;
			   $SENTENCE.infsort := infsortvar;
			   $SENTENCE.superdeixis := omegadeixis  ;
			   $SENTENCE.VRcompl := false ;
			   $SENTENCE.conjkey := conjkeyvar;
                           $SENTENCE.adverbial   := adverbialvar;
                           $SENTENCE.temporal    := temporalvar;
                           $SENTENCE.conjaspect  := conjaspectvar;
                           $SENTENCE.conjclass   := conjclassvar;
                           $SENTENCE.conjdeixis  := conjdeixisvar;
                           $SENTENCE.conjretro   := conjretrovar;
                           $SENTENCE.adjuncts    := adjunctsvar;
			 END; !(*if moodvar <> omegamood then, case 9-14*)

	
			 !(* determination of moodvar, case 15ff *)


			 moodvar := omegamood;
                         senttypevar := omegaclause;
                         synvpefsvar := origsynvpefsvar;

                         IF   (NOT adverbialvar)
                         THEN determinemood15ff(moodvar, senttypevar);
                 
                 
			 IF (moodvar <> omegamood)  AND
                            subordcondsok           AND
                            argspresent
			 THEN BEGIN
			   MAKET_SENTENCE;
			   $SENTENCE.req  := reqvar ;
			   $SENTENCE.env  := envvar ;
			   $SENTENCE.mood := moodvar ;
			   $SENTENCE.senttype := senttypevar;
			   $SENTENCE.voice := voicevar ;
			   $SENTENCE.PROsubject := (finitenessvar = infinite );
			   $SENTENCE.synvpefs := synvpefsvar ;
			   $SENTENCE.thetavp := thetavpvar ;
			   $SENTENCE.modus := modusvar ;
                           computeaktarts( classesvar,
			                   $SENTENCE.aktionsarts
                                         );
			   $SENTENCE.aspect := omegaaspect ;
			   $SENTENCE.deixis := deixisvar ;
			   $SENTENCE.retro :=  false ;
			   $SENTENCE.finiteness := finitenessvar ;
			   $SENTENCE.infsort := infsortvar;
			   $SENTENCE.superdeixis := omegadeixis  ;
			   $SENTENCE.VRcompl := false ;
			   $SENTENCE.conjkey := conjkeyvar;
                           $SENTENCE.adverbial   := adverbialvar;
                           $SENTENCE.temporal    := temporalvar;
                           $SENTENCE.conjaspect  := conjaspectvar;
                           $SENTENCE.conjclass   := conjclassvar;
                           $SENTENCE.conjdeixis  := conjdeixisvar;
                           $SENTENCE.conjretro   := conjretrovar;
                           $SENTENCE.adjuncts    := adjunctsvar;

			 END; !(*if moodvar <> omegamood then, case 15*)

			 !(* determination of moodvar, case 15ff *)



			 moodvar := omegamood;
                         senttypevar := omegaclause;
                         synvpefsvar := origsynvpefsvar;

                         IF   adverbialvar
                         THEN determinemoodadv(moodvar, senttypevar);
                 
                 
			 IF (moodvar <> omegamood)  AND
                            preporconjfound         AND
                            subordcondsok           AND
                            argspresent
			 THEN BEGIN
			   MAKET_SENTENCE;
			   $SENTENCE.req  := reqvar ;
			   $SENTENCE.env  := envvar ;
			   $SENTENCE.mood := moodvar ;
			   $SENTENCE.senttype := senttypevar;
			   $SENTENCE.voice := voicevar ;
			   $SENTENCE.PROsubject := (finitenessvar = infinite );
			   $SENTENCE.synvpefs := synvpefsvar ;
			   $SENTENCE.thetavp := thetavpvar ;
			   $SENTENCE.modus := modusvar ;
                           computeaktarts( classesvar,
			                   $SENTENCE.aktionsarts
                                         );
			   $SENTENCE.aspect := omegaaspect ;
			   $SENTENCE.deixis := deixisvar ;
			   $SENTENCE.retro :=  false ;
			   $SENTENCE.finiteness := finitenessvar ;
			   $SENTENCE.infsort := infsortvar;
			   $SENTENCE.superdeixis := omegadeixis  ;
			   $SENTENCE.VRcompl := false ;
			   $SENTENCE.conjkey := conjkeyvar;
                           $SENTENCE.adverbial   := adverbialvar;
                           $SENTENCE.temporal    := temporalvar;
                           $SENTENCE.conjaspect  := conjaspectvar;
                           $SENTENCE.conjclass   := conjclassvar;
                           $SENTENCE.conjdeixis  := conjdeixisvar;
                           $SENTENCE.conjretro   := conjretrovar;
                           $SENTENCE.adjuncts    := adjunctsvar;

			 END; !(*if moodvar <> omegamood then, adverbial cases *)


                      END !(*if synvpsok  THEN*)


                    END !(*thetaconds*)
        END !(*finalaction*)
*>                 
END;
& !(* SENTENCEsrule *)

%%
