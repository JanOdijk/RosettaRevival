h55370
s 00002/00002/05241
d D 1.3 93/04/02 11:51:41 odijkje 3 2
c 
e
s 05243/00001/00000
d D 1.2 92/02/21 15:40:31 rous 2 1
c 
e
s 00001/00000/00000
d D 1.1 92/02/11 11:47:06 rous 1 0
c date and time created 92/02/11 11:47:06 by rous
e
u
U
f e 0
t
T
I 1
D 2
 
E 2
I 2
DUTCH 109
&
\begin{verbatim}

This file contains the following rules and transformations:

   NAME                          TASK
RCNmodADVP1            Introduction of a-temporal postnominal ADVP
RCNmodADVP2            Introduction of temporal postnominal ADVP
RCNmodPostParticple    Introduction of potnominal participle modifiers
RCNmodRELSENT1         Introduction of relative clauses
RnonCNmodRELSENT1      Introduction of sentential modifiers to non-CNs
RCNmodinfrel           Introduction of postnominal 'om-te'-modifier


_____________________________________________________________________________
\end {verbatim}
\newpage
\begin{verbatim}
NOTES: 

------------------------------------------------------------------------------
\end {verbatim}
\newpage
\begin{verbatim}


%
% RULE RCNmodADVP1                   (* CN is substituent *)
< SUBST:
  m1: CN{CNrec1}[mu1,
                 I1:head/N1[mu2],
                 I3:mu3
                 ]

  m2: OPENADVPPROP{OPENADVPPROPrec1}
                              [subjrel/CNVAR{CNVARrec1},
                               predrel/I2::ADVP{ADVPrec1}[mu4]
                              ]
>

< m : CN{CNrec2}[mu1,
                 I1:head/N1[mu2],
                 I3:mu3,
                 postmodrel/I2::ADVP{ADVPrec1}[mu4]
                ]
>

   MATCHCONDITIONS
      <
       I1: N1.CAT  IN [NOUN, EN]
       I2: (ADVPrec1.actsubcefs  * [VPAdv, Locadv, DirAdv, 
                                    causadv, OtherAdv] <> []) AND
           ADVPrec1.mood = declxpmood
       I3: NOT EXIST(mu3,[postmodrel/SENTENCE{SENTENCErec1}[mu9] ]) 
      >

   PARAMETERS
      <
       LEVEL
      >

      COMP
         <
          C1: (OPENADVPPROPrec1 = COPYT_ADVPtoPROP(ADVPrec1)
                      EXCEPT FOR [superdeixis, 
                                  PROsubject, aktionsarts]) AND
              (OPENADVPPROPrec1.actsubcefs = ADVPrec1.actsubcefs) AND
              (OPENADVPPROPrec1.PROsubject = true) AND
              (OPENADVPPROPrec1.aktionsarts = [stative]) AND
              (OPENADVPPROPrec1.superdeixis = CNrec1.superdeixis) AND
              (CNVARrec1 = COPYT_CNtoVAR(CNrec1)) AND
              (CNVARrec1.index = LEVEL)
          A1: CNrec2 := CNrec1;
              CNrec2.possgeni := false;
         >

      DECOMP
         <
          C1: true (* CNrec2.possgeni = false; via TCnnounposs *)
          A1: CNrec1 := CNrec2;
              OPENADVPPROPrec1 := COPYT_ADVPtoPROP(ADVPrec1);
              OPENADVPPROPrec1.PROsubject := true;
              OPENADVPPROPrec1.aktionsarts := [stative];
              OPENADVPPROPrec1.superdeixis := CNrec1.superdeixis;
              CNVARrec1 := COPYT_CNtoVAR(CNrec2);
              CNVARrec1.index := LEVEL
         >
&


\end{verbatim}
\newpage
\begin{description}
\item[* name:] CNmodADVP1
\item[* relevant examples:] (die lange) man {\em daar}
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] CNformation
\item[* class:] (name of rule, transformation or filter class) mod1rules
\item[* date of creation:] 02-MAR-1990 11:33:59  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] modification of a CN by a non-temporal ADVPPROP.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
The CN is the substituent (the argument) of the ADVPPROP (the function),
i.e. the CN is substituted for the VAR (= CNVAR) of the ADVPPROP.
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
% RULE RCNmodADVP2

<  m1: CN{CNrec1}[mu1,
                 I1:head/N1[mu2],
                 I3:mu3
                 ]

  m2: I2::ADVP{ADVPrec1}[mu4]
>

< m : CN{CNrec2}[mu1,
                 I1:head/N1[mu2],
                 I3:mu3,
                 postmodrel/I2::ADVP{ADVPrec1}[mu4]
                ]
>

   MATCHCONDITIONS
      <
       I1: N1.CAT  IN [NOUN, EN]
       I2: tempadv IN ADVPrec1.actsubcefs AND
           ADVPrec1.mood = declxpmood
       I3: NOT EXIST(mu3,[postmodrel/SENTENCE{SENTENCErec1}[mu9] ]) 
      >


      COMP
         <
          C1: ADVPrec1.superdeixis = CNrec1.superdeixis 
          A1: CNrec2 := CNrec1;
              CNrec2.possgeni := false;
         >

      DECOMP
         <
          C1: true (* CNrec2.possgeni = false; via TCNnounposs *)
          A1: ADVPrec1.superdeixis := CNrec2.superdeixis;
              CNrec1 := CNrec2;
              
         >
&


\end{verbatim}
\newpage
\begin{description}
\item[* name:] CNmodADVP2
\item[* relevant examples:] (de) vergadering 
gisteren, maandag aanstaande (aangenomen dat postnominaal {\em aanstaande} 
adverbium is zonder flectie; Cf.  het aanstaand weekend vs. het weekend 
aanstaande. 
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] CNformation
\item[* class:] (name of rule, transformation or filter class) mod1rules
\item[* date of creation:] 02-MAR-1990 11:33:59  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] modification of a CN by introduction of a temporal ADVP.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
% RULE RCNmodPostParticple                   (* CN is substituent *)
(* NIET AF; komma's *)

< SUBST:
  m1: CN{CNrec1}[mu1,
                 head/N1[mu2],
                 I5:mu3
                 ]


  m2:I4::SENTENCE{SENTENCErec1}
                 [ subjrel/CNVAR{CNVARrec1},
                   mu4,
                   predrel/VERBP{VERBPrec1}
                         [ mu5,
                           head/I3::VERB{VERBrec1}[mu6] 
                         ] 
                 ]
>

< m :CN{CNrec2}
       [mu1,
        head/N1[mu2],
        I5:mu3,
        postmodrel/I2::SENTENCE{SENTENCErec2}
               [ mu4,
                 predrel/VERBP{VERBPrec1}
                        [ mu5,
                          head/I3::VERB{VERBrec1}[mu6] 
                        ] 
               ]
       ]
>

   MATCHCONDITIONS
      <
       I2: SENTENCErec2 = 
               { mood       : anterelative
                 PROsubject : true
               } AND
           SENTENCErec2.modus IN [prespart, pastpart]
       I4: SENTENCErec1 = 
               { mood       : anterelative
                 PROsubject : true
               } AND
           SENTENCErec1.modus IN [prespart, pastpart]
       I3: ((VERBrec1.status = bareV) OR
           (VERBrec1.status = partV)) AND
           VERBrec1.eorenform = noform
       I5: NOT EXIST(mu3, [I15:rel1/T1])
       I15: T1.CAT IN [SENTENCE]
      >

   PARAMETERS
      <
       LEVEL
      >

      COMP
         <
          C1: (CNVARrec1.index = LEVEL) AND
              (CNVARrec1 =  COPYT_CNtoVAR(CNrec1) EXCEPT FOR [cases] ) AND
              (CNVARrec1.cases = [Nominative])
              (* req and env still to be accounted for *)

              C11: (* temporally independent *)
                   SENTENCErec1.superdeixis = omegadeixis AND
                   NOT (QUOTE_temprefnotfound(mu2))
              A11: SENTENCErec2 := SENTENCErec1;

              C12: (* temporally dependent *)
                   (CNrec1.superdeixis = SENTENCErec1.superdeixis) AND
                   (SENTENCErec1.deixis = omegadeixis)
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.superdeixis := omegadeixis;
           A1: CNrec2 := CNrec1;
               CNrec2.possgeni := false;
         >


      DECOMP
         <
          C1: true (* CNrec2.possgeni = false; via TCNnounposs *)
              C11: (* temporally independent *)
                   SENTENCErec2.superdeixis = omegadeixis AND
                   NOT (QUOTE_temprefnotfound(mu2))
              A11: SENTENCErec1 := SENTENCErec2;

              C12: (* temporally dependent *)
                   SENTENCErec2.superdeixis = omegadeixis AND
                   SENTENCErec2.deixis = omegadeixis
              A12: SENTENCErec1:= SENTENCErec2;
                   SENTENCErec1.superdeixis := CNrec2.superdeixis;

          A1: CNrec1 := CNrec2;
              CNVARrec1 := COPYT_CNtoVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Nominative];
                            (* req and env still to be accounted for *)

         >
&


\end{verbatim}
\newpage
\begin{description}
\item[* name:] CNmodPostParticiplemod
\item[* relevant examples:] (die lange) man {\em komend van links}
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] CNformation
\item[* class:] (name of rule, transformation or filter class) mod1rules
\item[* date of creation:] 02-MAR-1990 11:33:59  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] modification of a CN by a non-temporal ADVPPROP.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
The CN is the substituent (the argument) of the ADVPPROP (the function),
i.e. the CN is substituted for the VAR (= CNVAR) of the ADVPPROP.
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
% RULE RCNmodRELSENT1
< SUBST:
  m1: CN{CNrec1}[I1:mu1]                 (* substituent *)
  m2: I2::SENTENCE{SENTENCErec1}
              [ shiftrel/T1,
                mu2 
              ] 


>

< m : CN{CNrec2}[ I1:mu1, 
                  postmodrel/I4::SENTENCE{SENTENCErec2}
	                [ shiftrel/T2,
                          mu2 
			],
                  I3:sig1 
                ]
>

   MATCHCONDITIONS
      <
       I1: NOT EXIST(mu1,[head/EN{ENrec1}])
       I2: SENTENCErec1 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : finite
                 }
       I3: ALL(sig1, puncrel/PUNC(KEY_kommapunckey){PUNCrec2})
       I4: SENTENCErec2 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : finite
                 }
      >



   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE  (* datrelpro, comma *)
      < T1: CNVAR{CNVARrec1}>
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
        T2:RELPRO(KEY_datrelprokey){RELPROrec1}
      >

      (* No COMP part *)

      DECOMP
         <
          C1: (Neutgender IN  CNrec2.genders ) AND 
                (singular IN CNrec2.numbers)
            C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = CNrec2.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Nominative, Accusative, Dative];
              CNrec1 := CNrec2;
         >

   SUBRULE  (* datrelpro, no comma *)
      < T1: CNVAR{CNVARrec1}>
      < sig1: []
        T2:RELPRO(KEY_datrelprokey){RELPROrec1}
      >

      COMP
         <
          C1: (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              ( (Neutgender IN  CNrec1.genders ) AND 
                (singular IN CNrec1.numbers)
              )                                  AND
              (CNVARrec1.cases * [Nominative, Dative, Accusative] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec1.superdeixis = omegadeixis) AND
                   (((SENTENCErec1.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec1.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )

              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   (SENTENCErec1.deixis = omegadeixis) AND
                   (SENTENCErec1.superdeixis = CNrec1.superdeixis)
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.deixis := CNrec1.superdeixis;
                   SENTENCErec2.superdeixis := omegadeixis;
          A1: CNrec2 := CNrec1;
              CNrec2.possgeni := false;
         > 


      DECOMP
         <
          C1:  (Neutgender IN  CNrec2.genders ) AND 
                (singular IN CNrec2.numbers) 
               (* CNrec2.possgeni = false; via TCNnounposs *)
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = CNrec2.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Nominative, Accusative, Dative];
D 3
              CNrec2 := CNrec1;
              CNrec2.possgeni := false;
E 3
I 3
              CNrec1 := CNrec2;
              (*CNrec2.possgeni := false;*)
E 3
         >

   SUBRULE  (* dierelpro, comma *)
      <T1: CNVAR{CNVARrec1}>
      <sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
       T2: RELPRO(KEY_dierelprokey){RELPROrec1} 
      >

      (* No COMP part *)

      DECOMP
         <
          C1: (CNrec2.genders * [mascgender, femgender] <> []) OR
                (plural IN CNrec2.numbers)
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = CNrec2.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Nominative, Accusative, Dative];
              CNrec2 := CNrec1;
         >

   SUBRULE  (* dierelpro, no comma *)
      <T1: CNVAR{CNVARrec1}>
      <sig1: []
       T2: RELPRO(KEY_dierelprokey){RELPROrec1}
      >

      COMP
         <
          C1: (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              ( (CNrec1.genders *[mascgender, femgender] <> [] ) OR
                (plural IN CNrec1.numbers)
              )                                  AND
              (CNVARrec1.cases * [Nominative, Dative, Accusative] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec1.superdeixis = omegadeixis) AND
                   (((SENTENCErec1.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec1.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   (SENTENCErec1.deixis = omegadeixis) AND
                   (SENTENCErec1.superdeixis = CNrec1.superdeixis)
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.deixis := CNrec1.superdeixis;
                   SENTENCErec2.superdeixis := omegadeixis;

          A1: CNrec2 := CNrec1;
              CNrec2.possgeni := false;
         >

      DECOMP
         <
          C1:  (CNrec2.genders * [mascgender, femgender] <> []) OR
                (plural IN CNrec2.numbers) 
                 (* CNrec2.possgeni =false; via TCNnounposs *)
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = CNrec2.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Nominative, Accusative, Dative];
              CNrec1 := CNrec2;
         >


   SUBRULE  (* RADVP+PREP (waarvan); comma *)
      <T1: VARPREPP{VARPREPPrec1}
             [errel/RADVP{RADVPrec1}[head/CNVAR{CNVARrec1}],
              gluerel/GLUE{},
              head/PREP{PREPrec1}
             ]
       >
       <
       sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
       T2: PREPP{PREPPrec1}
              [errel/RADVP{RADVPrec2}[head/RADV(KEY_waarradvkey){RADVrec1}],
               gluerel/GLUE{},
               head/PREP{PREPrec1}
              ]
       >

      (* No COMP part *)

      DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              PREPPrec1.radvkey = KEY_waarradvkey
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = CNrec2.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := relativexpmood;
              VARPREPPrec1.radvkey := 0;
              RADVPrec1 :=
                        {
                         mood    : declxpmood
                         kindefs : [Pk]
                         radvkey : 0
                         };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;
         >

   SUBRULE  (* RADVP+PREP (waarvan); no comma *)

       <
       T1: VARPREPP{VARPREPPrec1}
              [errel/RADVP{RADVPrec1}[head/CNVAR{CNVARrec1}],
               gluerel/GLUE{},
               head/PREP{PREPrec1}
              ]
       >
       <
       sig1: []
       T2: PREPP{PREPPrec1}
              [errel/RADVP{RADVPrec2}[head/RADV(KEY_waarradvkey){RADVrec1}],
               gluerel/GLUE{},
               head/PREP{PREPrec1}
              ]
       >

      COMP
         <
          C1: Pk IN RADVPrec1.kindefs AND
              VARPREPPrec1.radvkey = 0 AND
              VARPREPPrec1.mood = relativexpmood AND
              RADVPrec1.radvkey = 0 AND              
              (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              (CNVARrec1.human <> yeshuman) (* in COMP only *)  AND
              (CNVARrec1.cases * [Rcase] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec1.superdeixis = omegadeixis) AND
                   (((SENTENCErec1.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec1.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   (SENTENCErec1.deixis = omegadeixis) AND
                   (SENTENCErec1.superdeixis = CNrec1.superdeixis)
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.deixis := CNrec1.superdeixis;
                   SENTENCErec2.superdeixis := omegadeixis;

          A1: PREPPrec1 := VARPREPPrec1;
              PREPPrec1.mood := wh;
              PREPPrec1.radvkey := KEY_waarRADVkey;
              RADVPrec2 :=
                 { mood    : wh
                   radvkey : KEY_waarRADVkey
                   kindefs : [Pk]
                 };
              CNrec2 := CNrec1;
              CNrec2.possgeni := false;
         >

      DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              PREPPrec1.radvkey = KEY_waarRADVkey AND
              RADVPrec2 =
                 { mood    : wh
                   radvkey : KEY_waarRADVkey
                   kindefs NI Pk
                 } (* CNrec2.possgeni =false; via TCNnounposs *)
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = CNrec2.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := relativexpmood;
              VARPREPPrec1.radvkey := 0;
              RADVPrec1 := 
                        {
                         mood    : declxpmood
                         kindefs : [Pk]
                         radvkey : 0
                         };      
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;
         >

   SUBRULE  (* RADVP .... PREP (waar .... van); comma *)

       <       
        T1: RADVP{RADVPrec1}[head/CNVAR{CNVARrec1}]
       >       
       <       
        sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
        T2: RADVP{RADVPrec2}[head/RADV(KEY_waarradvkey){RADVrec1}]
       >       

      (* No COMP part *)


      DECOMP
         <
          C1: RADVPrec2 = 
                        {
                         mood    : wh
                         kindefs NI pk
                         radvkey : RADVrec1.key
                         }
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = CNrec2.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: RADVPrec1 :=
                {
                  mood    : declxpmood
                  radvkey : 0
                  kindefs : [Pk]
                };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;
         >

   SUBRULE  (* RADVP .... PREP (waar .... van); no comma *)

       <
       T1: RADVP{RADVPrec1}[head/CNVAR{CNVARrec1}]
       >
       <
       sig1: []
       T2: RADVP{RADVPrec2}[head/RADV(KEY_waarradvkey){RADVrec1}]
       >

      COMP
         <
          C1: pk IN RADVPrec1.kindefs AND
              RADVPrec1.radvkey = 0 AND              
              RADVPrec1.mood = declxpmood AND
              (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              (CNVARrec1.human <> yeshuman) (* only in COMP *)  AND
              (CNVARrec1.cases * [Rcase] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec1.superdeixis = omegadeixis) AND
                   (((SENTENCErec1.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec1.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   (SENTENCErec1.deixis = omegadeixis) AND
                   (SENTENCErec1.superdeixis = CNrec1.superdeixis)
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.deixis := CNrec1.superdeixis;
                   SENTENCErec2.superdeixis := omegadeixis;

          A1: RADVPrec2 :=
                {
                 mood    : wh
                 kindefs : [Pk]   
                 radvkey : KEY_waarRADVkey
                };
              CNrec2 := CNrec1;
              CNrec2.possgeni := false;

         >
      DECOMP
         <
          C1: RADVPrec2 = 
                        {
                         mood    : wh
                         kindefs NI Pk
                         radvkey : KEY_waarRADVkey
                        } 
              (* CNrec2.possgeni = false; via TCNnounposs *)
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = CNrec2.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: RADVPrec1 := 
                 {
                   mood    : declxpmood
                   kindefs : [Pk]
                   radvkey : 0
                 };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;
         >

   SUBRULE  (* RADVP (waar); comma *)

       <
       T1: VARPREPP{VARPREPPrec1}
                    [ head/PREP(KEY_inprepkey){PREPrec1},
                      objrel/CNVAR{CNVARrec1}
                    ]
       >
       <
       sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
       T2: RADVP{RADVPrec2}[head/RADV(KEY_waarradvkey){RADVrec1}]
       >

      (* No COMP part *)


      DECOMP
         <
          C1: RADVPrec2 = 
                        {
                         mood    : wh
                         kindefs  NI Lk
                         radvkey : RADVrec1.key
                         }
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = CNrec2.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1:
              VARPREPPrec1:= 
                 {
                   mood:              relativexpmood
                   actsubcefs:        PREPrec1.subcs
                   synppefs:          PREPrec1.synpps
                   thetapp:           PREPrec1.thetapp 
                   headkey:           PREPrec1.key
                   class:             PREPrec1.class
                   deixis:            PREPrec1.deixis
                   aspect:            PREPrec1.aspect
                   retro:             PREPrec1.retro

                   radvkey:           0
                   specQ:             yesspec
                 };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [accusative];
              CNrec1 := CNrec2;
         >


   SUBRULE  (* RADVP (waar); no comma *)

       <
       T1: VARPREPP{VARPREPPrec1}
                    [ head/PREP(KEY_inprepkey){PREPrec1},
                      objrel/CNVAR{CNVARrec1}
                    ]
       >
       <
       sig1: []
       T2: RADVP{RADVPrec2}[head/RADV(KEY_waarradvkey){RADVrec1}]
       >



      COMP
         <
          C1: VARPREPPrec1 = 
                 {
                   mood:              relativexpmood
                   actsubcefs:        PREPrec1.subcs
                   thetapp:           PREPrec1.thetapp 
                   headkey:           PREPrec1.key
                   class:             PREPrec1.class
                   deixis:            PREPrec1.deixis
                   aspect:            PREPrec1.aspect
                   retro:             PREPrec1.retro

                   radvkey:           0
                   specQ:             yesspec
                }  AND
              VARPREPPrec1.synppefs * PREPrec1.synpps <> [] AND
              (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              (CNVARrec1.human <> yeshuman) (* only in COMP *)  AND
              (CNVARrec1.cases * [Accusative] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec1.superdeixis = omegadeixis) AND
                   (((SENTENCErec1.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec1.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   (SENTENCErec1.deixis = omegadeixis) AND
                   (SENTENCErec1.superdeixis = CNrec1.superdeixis)
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.deixis := CNrec1.superdeixis;
                   SENTENCErec2.superdeixis := omegadeixis;

          A1: RADVPrec2.kindefs := [Lk];
              RADVPrec2.mood := wh;
              RADVPrec2.radvkey := KEY_waarRADVkey;
              CNrec2 := CNrec1;
              CNrec2.possgeni := false;

         >

      DECOMP
         <
          C1: RADVPrec2 = 
                        {
                         mood    : wh
                         kindefs NI lk
                         radvkey : KEY_waarRADVkey
                         }
              (* CNrec2.possgni = false; via TCNnounposs *)
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = CNrec2.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: 
              VARPREPPrec1:= 
                 {
                   mood:              relativexpmood
                   actsubcefs:        PREPrec1.subcs
                   synppefs:          PREPrec1.synpps
                   thetapp:           PREPrec1.thetapp 
                   headkey:           PREPrec1.key
                   class:             PREPrec1.class
                   deixis:            PREPrec1.deixis
                   aspect:            PREPrec1.aspect
                   retro:             PREPrec1.retro

                   radvkey:           0
                   specQ:             yesspec
                 };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Accusative];
              CNrec1 := CNrec2;

         >


   SUBRULE  (* PREP + WHPRO  (van wie); comma *)

       <
       T1: VARPREPP{VARPREPPrec1}
                    [head/PREP{PREPrec1},
                     objrel/CNVAR{CNVARrec1}
                    ]
       >
       <
       sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
       T2: PREPP{PREPPrec1}
                 [head/PREP{PREPrec1},
                  objrel/NP{NPrec1}[head/WHPRO{WHPROrec1}
                                     [head/BWHPRO(KEY_wiemsgWHPROkey){BWHPROrec1}]
                                   ]
                 ]
       >


      (* No COMP part *)


      DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              WHPROrec1 = COPYT_BWHPROtoWHPRO(BWHPROrec1) AND
              NPrec1 = 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                     posspred       : true
                  }                                         AND
                  NPrec1.cases * [dative, accusative] <> []

              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = CNrec2.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := relativexpmood;
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.human := yeshuman; 
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := NPrec1.cases;
              CNrec1 := CNrec2;
        >

   SUBRULE  (* PREP + WHPRO  (van wie); no comma *)

     <
     T1: VARPREPP{VARPREPPrec1}
                  [head/PREP{PREPrec1},
                   objrel/CNVAR{CNVARrec1}
                  ]
     >
     <
     sig1: []
     T2: PREPP{PREPPrec1}
               [head/PREP{PREPrec1},
                objrel/NP{NPrec1}[head/WHPRO{WHPROrec1}
                                   [head/BWHPRO(KEY_wiemsgWHPROkey){BWHPROrec1}]
                                 ]
               ]
     >


      COMP
         <
          C1: (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              (CNVARrec1.human = yeshuman) AND
              (CNVARrec1.cases * [Rcase] = [] ) AND
              VARPREPPrec1.mood = relativexpmood
              C11: (* temporally independent *)
                   (SENTENCErec1.superdeixis = omegadeixis) AND
                   (((SENTENCErec1.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec1.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   (SENTENCErec1.deixis = omegadeixis) AND
                   (SENTENCErec1.superdeixis = CNrec1.superdeixis)
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.deixis := CNrec1.superdeixis;
                   SENTENCErec2.superdeixis := omegadeixis;

          A1: PREPPrec1 := VARPREPPrec1;
              PREPPrec1.mood := wh;
              WHPROrec1 := COPYT_BWHPROtoWHPRO(BWHPROrec1);
              NPrec1 := 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                     posspred       : true
                  };
              CNrec2 := CNrec1;
              CNrec2.possgeni := false;
         >

      DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              WHPROrec1 = COPYT_BWHPROtoWHPRO(BWHPROrec1) AND
              NPrec1 = 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                     posspred       : true
                  }  AND
              NPrec1.cases * [dative, accusative] <> []
              (* CNrec2.possgeni = false; via TCNnounposs *)
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = CNrec2.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := relativexpmood;
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.human := yeshuman; 
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := NPrec1.cases;
              CNrec1 := CNrec2;

         >

   SUBRULE  (* RELPRO (dat) de dag dat hij kwam; no comma *)

       <
       T1: VARPREPP{VARPREPPrec1}
                    [ head/PREP(KEY_'s_prep1243607'){PREPrec1},
                      objrel/CNVAR{CNVARrec1}
                    ]
       >
       <
       sig1: []
       T2: RELPRO(KEY_datRELPROkey){RELPROrec1}
       >



      COMP
         <
          C1: VARPREPPrec1 = 
                 {
                   mood:              relativexpmood
                   actsubcefs:        PREPrec1.subcs
                   thetapp:           PREPrec1.thetapp 
                   headkey:           PREPrec1.key
                   class:             PREPrec1.class
                   deixis:            PREPrec1.deixis
                   aspect:            PREPrec1.aspect
                   retro:             PREPrec1.retro

                   radvkey:           0
                   specQ:             yesspec
                }  AND
              VARPREPPrec1.synppefs * PREPrec1.synpps <> [] AND
              (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              (CNrec1.temporal = true) AND
              (CNVARrec1.cases * [Accusative] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec1.superdeixis = omegadeixis) AND
                   (SENTENCErec1.deixis <> omegadeixis) 
              A11: SENTENCErec2 := SENTENCErec1;
          A1: CNrec2 := CNrec1;
              CNrec2.possgeni := false;
         >

      DECOMP
         <
          C1: CNrec2.temporal = true 
              (* CNrec2.possgeni = false; via TCNnounposs *)
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (CNrec2.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = CNrec2.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: 
              VARPREPPrec1:= 
                 {
                   mood:              relativexpmood
                   actsubcefs:        PREPrec1.subcs
                   synppefs:          PREPrec1.synpps
                   thetapp:           PREPrec1.thetapp 
                   headkey:           PREPrec1.key
                   class:             PREPrec1.class
                   deixis:            PREPrec1.deixis
                   aspect:            PREPrec1.aspect
                   retro:             PREPrec1.retro

                   radvkey:           0
                   specQ:             yesspec
                 };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Accusative];
              CNrec1 := CNrec2;

         >


>

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RCNmodRELSENT1
\item[* relevant examples:]  
\begin{enumerate}
\item  de stad die ik haat/ het werk dat ik haat (was modrelsent1)
\item  de stad waarvan ik droom (was modrelsent2)
\item  de stad waar ik van droom (was modrelsent3)
\item  de stad waar ik woon (was modrelsent4)
\item  de man van wie ik droom (was modrelsent5)
\end{enumerate}
                            
\item[* language:] Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 23-SEP-1988 11:36:19  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 31/10/88\ \ \ \ \ author: Lisette Appelo
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] to substitue CNVAR in sentences by CN; 
Subrules have taken over the role of the original modrelsent1-5. 
Cf. the examples.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In addition to {\em de man van wie ik droom}, 
{\em de man waarvan ik droom} is accepted in analysis, but only the former
will be  generated;
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:31/10/88: Added superdeixis condition/actions. In the 
superdeixis case the deixis value for the relative clause is given a value in 
generation and set to omega in analysis. This is done for the surface parser. 
It is the same task as is carried out for complement sentences in the 
superdeixisadaptation transformations.\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
RULE RCNmodRELSENT1
< SUBST:
  m1: CN{CNrec1}[I1:mu1]                 (* substituent *)
  m2: I2::SENTENCE{SENTENCErec1}
              [ shiftrel/CNVAR{CNVARrec1},
                mu2 
              ] 


>

< m : CN{CNrec2}[ I1:mu1, 
                  postmodrel/I2::SENTENCE{SENTENCErec1}
			      [ shiftrel/T1,
				mu2 
			      ],
                  I3:sig1 
                ]
>

   MATCHCONDITIONS
      <
       I1: NOT EXIST(mu1,[head/EN{ENrec1}])
       I2: SENTENCErec1 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : finite
                 }
       I3: ALL(sig1, puncrel/PUNC(KEY_kommapunckey){PUNCrec2})
      >

   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE  (* datrelpro, comma *)
      < >
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
        T1:RELPRO(KEY_datrelprokey){RELPROrec1}
      >

      COMP
         <
          C1: (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              ( (Neutgender IN  CNrec1.genders ) AND 
                (singular IN CNrec1.numbers)
              )                                  AND
              (CNVARrec1.cases * [Nominative, Dative, Accusative] <> [] )

          A1: CNrec2 := CNrec1;
              CNrec2.possgeni := false
         >


      DECOMP
         <
          C1: (Neutgender IN  CNrec2.genders ) AND 
                (singular IN CNrec2.numbers)
              (* CNrec2.possgeni= false; via TCNnounposs *)
          A1: CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Nominative, Accusative, Dative];
              CNrec1 := CNrec2;

         >

   SUBRULE  (* datrelpro, no comma *)
      < >
      <sig1: []
       T1:RELPRO(KEY_datrelprokey){RELPROrec1}
      >

           (* no COMP part *)


      DECOMP
         <
          C1:  (Neutgender IN  CNrec2.genders ) AND 
                (singular IN CNrec2.numbers)
          A1: CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Nominative, Accusative, Dative];
              CNrec1 := CNrec2;

         >

   SUBRULE  (* dierelpro, comma *)
      < >
      <sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
       T1: RELPRO(KEY_dierelprokey){RELPROrec1} 
      >

      COMP
         <
          C1: (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              ( (CNrec1.genders *[mascgender, femgender] <> [] ) OR
                (plural IN CNrec1.numbers)
              )                                  AND
              (CNVARrec1.cases * [Nominative, Dative, Accusative] <> [] )

          A1: CNrec2 := CNrec1;
              CNrec2.possgeni := false;
          
         >

      DECOMP
         <
          C1: (CNrec2.genders * [mascgender, femgender] <> []) OR
                (plural IN CNrec2.numbers)
              (* CNrec2.possgeni= false; via TCNnounposs *)
          A1: CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Nominative, Accusative, Dative];
              CNrec1 := CNrec2;

         >

   SUBRULE  (* dierelpro, no comma *)
      < >
      <sig1: []
       T1: RELPRO(KEY_dierelprokey){RELPROrec1}
      >

         (* no COMP part *)

      DECOMP
         <
          C1:  (CNrec2.genders * [mascgender, femgender] <> []) OR
                (plural IN CNrec2.numbers)
          A1: CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Nominative, Accusative, Dative];
              CNrec1 := CNrec2;

         >

>
&


\end{verbatim}
\newpage
\begin{description}
\item[* name:] CNmodRELSENT1
\item[* relevant examples:] 
man + [x2 hij zag ] $\rightarrow$ [man [die hij zag],]\\
huis + [x2 hij zag ] $\rightarrow$ [huis [dat hij zag],]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] NP-subgrammar
\item[* class:] (name of rule, transformation or filter class) modrules
\item[* date of creation:] 10-FEB-1987 11:57:36  
\item[* author:] Elly van Munster, Jan Odijk
\item[* copied from:] --
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Modification of a CN by a restrictive, finite, relative SENTENCE.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
The subrules can be divided in the following way:\\
subrule 1 and 2 are for the relative pronoun {\em dat}\\
subrule 3 and 4 are for the relative pronoun {\em die}\\

In the first and third rule a comma is present behind the relative clause
both in generation and in analysis.\\
In the second and fourth subrule cases where no comma is present are dealt with
, only analytically.

\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] In analysis the absence 
of a comma behind the  relative sentence \'{i}s accepted, but in generation
a comma is always generated. 
\item[\  \ suggested semantics:] 
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\
\item modifications:\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
RULE RCNmodRELSENT2
< SUBST:
  m1: CN{CNrec1}[I1:mu1]                 (* substituent *)
  m2: I2::SENTENCE{SENTENCErec1}
              [ shiftrel/VARPREPP{VARPREPPrec1}
                         [errel/RADVP{RADVPrec1}[head/CNVAR{CNVARrec1}],
                          gluerel/GLUE{},
                          head/PREP{PREPrec1}
                         ],
                mu2 
              ] 


>

< m : CN{CNrec2}[ I1:mu1, 
                  postmodrel/I2::SENTENCE{SENTENCErec1}
	                [ shiftrel/PREPP{PREPPrec1}
                                [errel/RADV(KEY_waarradvkey){RADVrec1},
                                 gluerel/GLUE{},
                                 head/PREP{PREPrec1}
                                ],
                          mu2 
			],
                  I3:sig1 
                ]
>

   MATCHCONDITIONS
      <
       I1: NOT EXIST(mu1,[head/EN{ENrec1}])
       I2: SENTENCErec1 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : finite
                 }
       I3: ALL(sig1, puncrel/PUNC(KEY_kommapunckey){PUNCrec2})
      >

   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE  (* comma *)
      < >
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
      >

      COMP
         <
          C1: lk IN RADVPrec1.kindefs AND
              RADVPrec1.radvkey = KEY_waarRADVkey AND              
              (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              (CNVARrec1.human <> yeshuman) (* in COMP only *)  AND
              (CNVARrec1.cases * [Rcase] <> [] )

          A1: PREPPrec1 := VARPREPPrec1;
              PREPPrec1.mood := wh;
              CNrec2 := CNrec1;
              CNrec2.possgeni := false;

         >


      DECOMP
         <
          C1: PREPPrec1.mood  = wh
              (* CNrec2.possgeni= false; via TCNnounposs *)
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              RADVPrec1 := 
                        {
                         mood    : declxpmood
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;
         >

   SUBRULE  (* no comma *)
      < >
      <sig1: []
      >

           (* no COMP part *)



      DECOMP
         <
          C1: PREPPrec1.mood  = wh
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              RADVPrec1 := 
                        {
                         mood    : declxpmood
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         };      
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;
         >
>

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RCNmodRELSENT2
\item[* relevant examples:] de stad waarvan ik droom
\item[* language:] Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 23-SEP-1988 11:36:19  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] to substitue CNVAR in VARPREPP by CN; 
in relsent RADV takes the place of CNVAR.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In addition to {\em de man van wie ik droom}, 
{\em de man waarvan ik droom} is accepted in analysis, but only the former
will be  generated;
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
 RULE RCNmodRELSENT3
< SUBST:
  m1: CN{CNrec1}[I1:mu1]                 (* substituent *)
  m2: I2::SENTENCE{SENTENCErec1}
              [ shiftrel/RADVP{RADVPrec1}
                         [head/CNVAR{CNVARrec1}],
                mu2 
              ] 


>

< m : CN{CNrec2}[ I1:mu1, 
                  postmodrel/I2::SENTENCE{SENTENCErec1}
	                [ shiftrel/RADVP{RADVPrec2}
                                   [head/RADV(KEY_waarradvkey){RADVrec1}],
                          mu2 
			],
                  I3:sig1 
                ]
>

   MATCHCONDITIONS
      <
       I1: NOT EXIST(mu1,[head/EN{ENrec1}])
       I2: SENTENCErec1 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : finite
                 }
       I3: ALL(sig1, puncrel/PUNC(KEY_kommapunckey){PUNCrec2})
      >

   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE  (* comma *)
      < >
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
      >

      COMP
         <
          C1: lk IN RADVPrec1.kindefs AND
              RADVPrec1.radvkey = KEY_waarRADVkey AND              
              RADVPrec1.mood = declxpmood AND
              (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              (CNVARrec1.human <> yeshuman) (* only in COMP *)  AND
              (CNVARrec1.cases * [Rcase] <> [] )

          A1: RADVPrec2 := RADVPrec1;
              RADVPrec2.mood := wh;
              CNrec2 := CNrec1;
              CNrec2.possgeni := false;
         >


      DECOMP
         <
          C1: RADVPrec2 = 
                        {
                         mood    : wh
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         }
              (* CNrec2.possgeni= false; via TCNnounposs *)
          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.mood := declxpmood;
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;

         >

   SUBRULE  (* no comma *)
      < >
      <sig1: []
      >

           (* no COMP part *)
      DECOMP
         <
          C1: RADVPrec2 = 
                        {
                         mood    : wh
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         }
          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.mood := declxpmood;
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;

         >
>

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RCNmodRELSENT3
\item[* relevant examples:] de stad waar ik van droom
\item[* language:] Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 23-SEP-1988 11:36:19  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] to substitue CNVAR in RADVP by CN; in relsent RADV takes 
the place of CNVAR.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In addition to {\em de man van wie ik droom}, 
{\em de man waar ik van droom} is accepted in analysis, but only the former
will be  generated;
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
 RULE RCNmodRELSENT4
< SUBST:
  m1: CN{CNrec1}[I1:mu1]                 (* substituent *)
  m2: I2::SENTENCE{SENTENCErec1}
              [ shiftrel/VARPREPP{VARPREPPrec1}
                         [errel/RADVP{RADVPrec1}[head/CNVAR{CNVARrec1}],
                          gluerel/GLUE{},
                          head/PREP(KEY_inprepkey){PREPrec1}
                         ],
                mu2 
              ] 

>

< m : CN{CNrec2}[ I1:mu1, 
                  postmodrel/I2::SENTENCE{SENTENCErec1}
	                [ shiftrel/RADVP{RADVPrec2}
                                [head/RADV(KEY_waarradvkey){RADVrec1}],
                          mu2 
			],
                  I3:sig1 
                ]
>

   MATCHCONDITIONS
      <
       I1: NOT EXIST(mu1,[head/EN{ENrec1}])
       I2: SENTENCErec1 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : finite
                 }
       I3: ALL(sig1, puncrel/PUNC(KEY_kommapunckey){PUNCrec2})
      >

   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE  (* comma *)
      < >
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
      >

      COMP
         <
          C1: VARPREPPrec1 = 
                 {
                   mood:              declxpmood
                   actsubcefs:        PREPrec1.subcs
                   synppefs:          PREPrec1.synpps
                   thetapp:           PREPrec1.thetapp 
                   headkey:           PREPrec1.key
                   class:             PREPrec1.class
                   deixis:            PREPrec1.deixis
                   aspect:            PREPrec1.aspect
                   retro:             PREPrec1.retro

                   radvkey:           RADVPrec1.radvkey
                   specQ:             yesspec
                }  AND
              RADVPrec1.mood = declxpmood AND
              lk IN RADVPrec1.kindefs AND
              RADVPrec1.radvkey = KEY_waarRADVkey AND 
              (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              (CNVARrec1.human <> yeshuman) (* only in COMP *)  AND
              (CNVARrec1.cases * [Rcase] <> [] )

          A1: RADVPrec2 := RADVPrec1;
              RADVPrec2.mood := wh;
              CNrec2 := CNrec1;
              CNrec2.possgeni := false;

         >


      DECOMP
         <
          C1: RADVPrec1 = 
                        {
                         mood    : wh
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         }
              (* CNrec2.possgeni= false; via TCNnounposs *)
          A1: RADVPrec1 := RADVPrec2;
              VARPREPPrec1:= 
                 {
                   mood:              declxpmood
                   actsubcefs:        PREPrec1.subcs
                   synppefs:          PREPrec1.synpps
                   thetapp:           PREPrec1.thetapp 
                   headkey:           PREPrec1.key
                   class:             PREPrec1.class
                   deixis:            PREPrec1.deixis
                   aspect:            PREPrec1.aspect
                   retro:             PREPrec1.retro

                   radvkey:           RADVPrec2.radvkey
                   specQ:             yesspec
                 };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;

         >

      SUBRULE  (* comma *)
      < >
      < sig1: []
      >


           (* no COMP part *)

      DECOMP
         <
          C1: RADVPrec1 = 
                        {
                         mood    : wh
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         }
          A1: RADVPrec1 := RADVPrec2;
              VARPREPPrec1:= 
                 {
                   mood:              declxpmood
                   actsubcefs:        PREPrec1.subcs
                   synppefs:          PREPrec1.synpps
                   thetapp:           PREPrec1.thetapp 
                   headkey:           PREPrec1.key
                   class:             PREPrec1.class
                   deixis:            PREPrec1.deixis
                   aspect:            PREPrec1.aspect
                   retro:             PREPrec1.retro

                   radvkey:           RADVPrec2.radvkey
                   specQ:             yesspec
                 };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;

         >
>

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RCNmodRELSENT4
\item[* relevant examples:] de stad waar ik woon
\item[* language:] Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 23-SEP-1988 11:36:19  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] to substitue CNVAR in VARPREP by CN; 
in relsent RADV takes the place of
CNVAR, while the preposition is deleted
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
 RULE RCNmodRELSENT5
< SUBST:
  m1: CN{CNrec1}[I1:mu1]                 (* substituent *)
  m2: I2::SENTENCE{SENTENCErec1}
              [ shiftrel/VARPREPP{VARPREPPrec1}
                         [head/PREP{PREPrec1},
                          objrel/CNVAR{CNVARrec1}
                         ],
                mu2 
              ] 


>

< m : CN{CNrec2}[ I1:mu1, 
                  postmodrel/I2::SENTENCE{SENTENCErec1}
	                [ shiftrel/PREPP{PREPPrec1}
                                [head/PREP{PREPrec1},
                                 objrel/NP{NPrec1}[head/WHPRO{WHPROrec1}
                                                     [head/
                                                         I4::BWHPRO{BWHPROrec1}]
                                                  ]
                                ],
                          mu2 
			],
                  I3:sig1 
                ]
>

   MATCHCONDITIONS
      <
       I1: NOT EXIST(mu1,[head/EN{ENrec1}])
       I2: SENTENCErec1 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : finite
                 }
       I3: ALL(sig1, puncrel/PUNC(KEY_kommapunckey){PUNCrec2})
       I4: BWHPROrec1.key = 10152 (* wiebwhpro *)

      >

   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE  (* comma *)
      < >
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
      >

      COMP
         <
          C1: (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              (CNVARrec1.human = yeshuman) AND
              (CNVARrec1.cases * [Rcase] <> [] )

          A1: PREPPrec1 := VARPREPPrec1;
              PREPPrec1.mood := wh;
              WHPROrec1 := COPYT_BWHPROtoWHPRO(BWHPROrec1);
              NPrec1 := 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [dative, accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                  };
              CNrec2 := CNrec1;
              CNrec2.possgeni := false;

         >


      DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              WHPROrec1 = COPYT_BWHPROtoWHPRO(BWHPROrec1) AND
              NPrec1 = 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [dative, accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                  }
              (* CNrec2.possgeni= false; via TCNnounposs *)
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.human := yeshuman; 
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;
         >

   SUBRULE  (* no comma *)
      < >
      <sig1: []
      >

           (* no COMP part *)

      DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              WHPROrec1 = COPYT_BWHPROtoWHPRO(BWHPROrec1) AND
              NPrec1 = 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [dative, accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : nogeneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                  }
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.human := yeshuman; 
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;
         >
>

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RCNmodRELSENT5
\item[* relevant examples:] de man van wie ik droom
\item[* language:] Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 23-SEP-1988 11:36:19  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 19/04/89\ \ \ \ \ author: Lisette Appelo\\
Changed superdeixisconditions/actions for independent sentences: allowed are:\\
- presentdeixis without refadv and CN.superdeixis <> presentdeixis\\
- presentdeixis with refadv\\
- pastdeixis without refadv and  CN.superdeixis <> pastdeixis\\
- pastdeixis with refadv
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] to substitue CNVAR met .human = yeshuman in VARPREPP by CN; 
in relsent WHPRO takes the place of CNVAR.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
% RULE RnonCNmodRELSENT1
< SUBST:
  m1: NP{NPrec1}[I1:head/T2]                 (* substituent *)
  m2: I2::SENTENCE{SENTENCErec1}
              [ shiftrel/T4,
                mu2 
              ] 


>

< m :  NP{NPrec1}[I1:head/T2,
                  I3:sig1,
                  postmodrel/I5::SENTENCE{SENTENCErec2}
			      [ shiftrel/T1,
				mu2 
			      ],
                  I4:sig2
                ]
>

   MATCHCONDITIONS
      <
       I1: T2.CAT IN [PROPERNOUN, INDEFPRO, PERSPRO]
       I2: SENTENCErec1 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : finite
                 }
       I3: ALL(sig1, puncrel/PUNC(KEY_kommapunckey){PUNCrec3})
       I4: ALL(sig2, puncrel/PUNC(KEY_kommapunckey){PUNCrec4})
       I5: SENTENCErec2 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : finite
                 }
      >

   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE  (* PROPERNOUN, dierelpro, two comma's *)

      < T2: PROPERNOUN{PROPERNOUNrec1}[mu6]
        T4: NPVAR{NPVARrec1}
      >
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: PROPERNOUN{PROPERNOUNrec1}[mu6]
        T1:RELPRO(KEY_dierelprokey){RELPROrec1}
      >

      COMP
         <
          C1: (NPrec1.genders *[mascgender, femgender] <> [] ) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Nominative, Dative, Accusative] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec1.superdeixis = omegadeixis) AND
                   (((SENTENCErec1.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec1.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   (SENTENCErec1.deixis = omegadeixis) AND
                   (SENTENCErec1.superdeixis = NPrec1.superdeixis)
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.deixis := NPrec1.superdeixis;
                   SENTENCErec2.superdeixis := omegadeixis;

          A1: @
         >


      DECOMP
         <
          C1: (NPrec1.genders *[mascgender, femgender] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = NPrec1.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := NPrec1.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >


   SUBRULE  (* dierelpro, one comma *)
      < T2: T3
        T4: NPVAR{NPVARrec1}
      >
      < sig1: []
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: T3
        T1:RELPRO(KEY_dierelprokey){RELPROrec1}
         >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [PERSPRO, INDEFPRO]
      >


      COMP
         <
          C1: (NPrec1.genders *[mascgender, femgender] <> [] ) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Nominative, Dative, Accusative] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec1.superdeixis = omegadeixis) AND
                   (((SENTENCErec1.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec1.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   (SENTENCErec1.deixis = omegadeixis) AND
                   (SENTENCErec1.superdeixis = NPrec1.superdeixis)
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.deixis := NPrec1.superdeixis;
                   SENTENCErec2.superdeixis := omegadeixis;

          A1: @
         >

      DECOMP
         <
          C1: (NPrec1.genders *[mascgender, femgender] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = NPrec1.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := NPrec1.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >

   SUBRULE  (* dierelpro, no comma *)
      < T2: T3
        T4: NPVAR{NPVARrec1}
      >
      < sig1: []
        sig2: []
        T2: T3
        T1:RELPRO(KEY_dierelprokey){RELPROrec1}
      >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [PERSPRO, INDEFPRO]
      >

         (* no COMP part *)

      DECOMP
         <
          C1: (NPrec1.genders *[mascgender, femgender] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = NPrec1.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := NPrec1.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >

   SUBRULE  (* datrelpro, one comma *)
      < T2: INDEFPRO{INDEFPROrec1}[mu6]
        T4: NPVAR{NPVARrec1}
      >
      < sig1: []
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: INDEFPRO{INDEFPROrec1}[mu6]
        T1:RELPRO(KEY_datrelprokey){RELPROrec1}
      >


      COMP
         <
          C1: (NPrec1.genders = [neutgender] ) AND
              (NPrec1.animate = noanimate) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Nominative, Dative, Accusative] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec1.superdeixis = omegadeixis) AND
                   (((SENTENCErec1.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec1.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   (SENTENCErec1.deixis = omegadeixis) AND
                   (SENTENCErec1.superdeixis = NPrec1.superdeixis)
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.deixis := NPrec1.superdeixis;
                   SENTENCErec2.superdeixis := omegadeixis;

          A1: @
         >

      DECOMP
         <
          C1: (NPrec1.genders = [neutgender] ) AND
              (NPrec1.animate = noanimate)
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = NPrec1.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := NPrec1.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >


   SUBRULE  (* watbwhpro, one comma *)
      < T2: INDEFPRO{INDEFPROrec1}[mu6]
        T4: NPVAR{NPVARrec1}
      >
      < sig1: []
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: INDEFPRO{INDEFPROrec1}[mu6]
        T1:BWHPRO(KEY_watwhprokey){BWHPROrec1}
      >


      COMP
         <
          C1: (NPrec1.genders = [neutgender] ) AND
              (NPrec1.animate = noanimate) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Nominative, Dative, Accusative] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec1.superdeixis = omegadeixis) AND
                   (((SENTENCErec1.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec1.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   (SENTENCErec1.deixis = omegadeixis) AND
                   (SENTENCErec1.superdeixis = NPrec1.superdeixis)
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.deixis := NPrec1.superdeixis;
                   SENTENCErec2.superdeixis := omegadeixis;

          A1: @
         >

      DECOMP
         <
          C1: (NPrec1.genders = [neutgender] ) AND
              (NPrec1.animate = noanimate)
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = NPrec1.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := NPrec1.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >

   SUBRULE  (* datrelpro, no comma *)
      < T2: INDEFPRO{INDEFPROrec1}[mu6]
         T4: NPVAR{NPVARrec1}
      >
     < sig1: []
        sig2: []
        T2: INDEFPRO{INDEFPROrec1}[mu6]
        T1:RELPRO(KEY_datrelprokey){RELPROrec1}
      >

         (* no COMP part *)

      DECOMP
         <
          C1: (NPrec1.genders = [neutgender] ) AND
              (NPrec1.animate = noanimate)
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;

               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = NPrec1.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := NPrec1.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >

   SUBRULE  (* watbwhpro, no comma *)

      < T2: INDEFPRO{INDEFPROrec1}[mu6]
        T4: NPVAR{NPVARrec1}
      >
      < sig1: []
        sig2: []
        T2: INDEFPRO{INDEFPROrec1}[mu6]
        T1:BWHPRO(KEY_watwhprokey){BWHPROrec1}
      >

         (* no COMP part *)

      DECOMP
         <
          C1: (NPrec1.genders = [neutgender] ) AND
              (NPrec1.animate = noanimate)
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = NPrec1.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := NPrec1.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >

   SUBRULE  (* PROPERNOUN antecedent, RADV + PREP (waarvan); two comma 's*)

    < T2: PROPERNOUN{PROPERNOUNrec1}[mu6]
      T4: VARPREPP{VARPREPPrec1}
                         [errel/RADVP{RADVPrec1}[head/NPVAR{NPVARrec1}],
                          gluerel/GLUE{},
                          head/PREP{PREPrec1}
                         ]
    >
    < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
      sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
      T2: PROPERNOUN{PROPERNOUNrec1}[mu6]                
      T1:PREPP{PREPPrec1}
              [errel/RADV(KEY_waarradvkey){RADVrec1},
               gluerel/GLUE{},
               head/PREP{PREPrec1}
              ] 
    >

      COMP
         <
          C1: lk IN RADVPrec1.kindefs AND
              RADVPrec1.radvkey = KEY_waarRADVkey AND              
              (NPrec1.genders *[mascgender, femgender] <> [] ) AND
              (NPrec1.human = nohuman) (* in COMP only *) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Rcase] <> [] ) 
              C11: (* temporally independent *)
                   (SENTENCErec1.superdeixis = omegadeixis) AND
                   (((SENTENCErec1.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec1.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   (SENTENCErec1.deixis = omegadeixis) AND
                   (SENTENCErec1.superdeixis = NPrec1.superdeixis)
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.deixis := NPrec1.superdeixis;
                   SENTENCErec2.superdeixis := omegadeixis;
          A1: PREPPrec1 := VARPREPPrec1;
              PREPPrec1.mood := wh;
         >


      DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              (NPrec1.genders *[mascgender, femgender] <> [] )
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = NPrec1.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := NPrec1.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              RADVPrec1 := 
                        {
                         mood    : declxpmood
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         };
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Rcase];
         >


   SUBRULE  (* INDEFPRO/DEMPRO antecedent, waar + PREP (waarvan; one comma *)

      < T2: T3
        T4: VARPREPP{VARPREPPrec1}
                         [errel/RADVP{RADVPrec1}[head/NPVAR{NPVARrec1}],
                          gluerel/GLUE{},
                          head/PREP{PREPrec1}
                         ]
      >
      < sig1: []
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: T3
        T1:PREPP{PREPPrec1}
              [errel/RADV(KEY_waarradvkey){RADVrec1},
               gluerel/GLUE{},
               head/PREP{PREPrec1}
              ] 
      >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [DEMPRO, INDEFPRO]
      >

      COMP
         <
          C1: lk IN RADVPrec1.kindefs AND
              RADVPrec1.radvkey = KEY_waarRADVkey AND              
              (NPrec1.human = nohuman) (* in COMP only *) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Rcase] <> [] ) 
              C11: (* temporally independent *)
                   (SENTENCErec1.superdeixis = omegadeixis) AND
                   (((SENTENCErec1.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec1.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   (SENTENCErec1.deixis = omegadeixis) AND
                   (SENTENCErec1.superdeixis = NPrec1.superdeixis)
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.deixis := NPrec1.superdeixis;
                   SENTENCErec2.superdeixis := omegadeixis;
          A1: PREPPrec1 := VARPREPPrec1;
              PREPPrec1.mood := wh;
         >

      DECOMP
         <
          C1: PREPPrec1.mood  = wh 
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = NPrec1.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := NPrec1.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              RADVPrec1 := 
                        {
                         mood    : declxpmood
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         };
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Rcase];
         >

   SUBRULE  (* INDEFPRO/DEMPRO antecedent, waar + PREP (waarvan; no comma *)

      < T2: T3
        T4: VARPREPP{VARPREPPrec1}
                         [errel/RADVP{RADVPrec1}[head/NPVAR{NPVARrec1}],
                          gluerel/GLUE{},
                          head/PREP{PREPrec1}
                         ]
      >
      < sig1: []
        sig2: []
        T2: T3
        T1:PREPP{PREPPrec1}
              [errel/RADV(KEY_waarradvkey){RADVrec1},
               gluerel/GLUE{},
               head/PREP{PREPrec1}
              ] 
      >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [DEMPRO, INDEFPRO]
      >

         (* no COMP part *)

      DECOMP
         <
          C1: PREPPrec1.mood  = wh 
              C11: (* temporally independent *)
                   (SENTENCErec2.superdeixis = omegadeixis) AND
                   (((SENTENCErec2.deixis = presentdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> presentdeixis)
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    ) OR
                    ((SENTENCErec2.deixis = pastdeixis) AND
                     (((QUOTE_temprefnotfound(mu2)) AND
                       (NPrec1.superdeixis <> pastdeixis) 
                      ) OR
                      (NOT QUOTE_temprefnotfound(mu2))
                      )
                     )
                    )
                   )
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = NPrec1.superdeixis)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := NPrec1.superdeixis;
                    SENTENCErec1.deixis := omegadeixis;  
                   
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              RADVPrec1 := 
                        {
                         mood    : declxpmood
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         };
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Rcase];
         >

>
&


\end{verbatim}
\newpage
\begin{description}
\item[* name:] RnonCNmodRELSENT1
\item[* some relevant examples:] 
Jan  + [x2 is nooit ziek ] $\rightarrow$ [Jan, [die nooit ziek is],]\\
iemand + [x2 is ziek] $\rightarrow$ [iemand [die ziek is ],]
iets + [x2 is lekker] $\rightarrow$ [iets [wat lekker is ],]
\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] NP-subgrammar
\item[* class:] (name of rule, transformation or filter class) modrules
\item[* date of creation:] 27-SEP-1988 11:57:36  
\item[* author:] Franciska de Jong
\item[* copied from:] --
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 31/10/88\ \ \ \ \ author: Lisette Appelo
\item date: 19/04/89\ \ \ \ \ author: Lisette Appelo\\
Changed superdeixisconditions/actions for independent sentences: allowed are:\\
- presentdeixis without refadv and NP.superdeixis <> presentdeixis\\
- presentdeixis with refadv\\
- pastdeixis without refadv and  NP.superdeixis <> pastdeixis\\
- pastdeixis with refadv
\end{enumerate}
\item[* task:] Modification of a non-CN by a restrictive, finite, relative SENTENCE.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] In analysis the absence 
of a comma behind the  relative sentence \'{i}s accepted, but in generation
a comma is always generated. 
\item[\  \ suggested semantics:] 
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\
\item modifications: 31/10/88: Added superdeixis conditions/actions.\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
 RULE RnonCNmodRELSENT1
< SUBST:
  m1: NP{NPrec1}[I1:head/T2]                 (* substituent *)
  m2: I2::SENTENCE{SENTENCErec1}
              [ shiftrel/NPVAR{NPVARrec1},
                mu2 
              ] 


>

< m :  NP{NPrec1}[I1:head/T2,
                  I3:sig1,
                  postmodrel/I2::SENTENCE{SENTENCErec1}
			      [ shiftrel/T1,
				mu2 
			      ],
                  I4:sig2
                ]
>

   MATCHCONDITIONS
      <
       I1: T2.CAT IN [PROPERNOUN, INDEFPRO, PERSPRO]
       I2: SENTENCErec1 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : finite
                 }
       I3: ALL(sig1, puncrel/PUNC(KEY_kommapunckey){PUNCrec3})
       I4: ALL(sig2, puncrel/PUNC(KEY_kommapunckey){PUNCrec4})
      >

   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE  (* PROPERNOUN, dierelpro, two comma's *)

      < T2: PROPERNOUN{PROPERNOUNrec1}[mu6]>
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: PROPERNOUN{PROPERNOUNrec1}[mu6]
        T1:RELPRO(KEY_dierelprokey){RELPROrec1}
      >

      COMP
         <
          C1: (NPrec1.genders *[mascgender, femgender] <> [] ) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Nominative, Dative, Accusative] <> [] )

          A1: @
         >


      DECOMP
         <
          C1: (NPrec1.genders *[mascgender, femgender] <> [] )
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >


   SUBRULE  (* dierelpro, one comma *)
      < T2: T3>
      < sig1: []
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: T3
        T1:RELPRO(KEY_dierelprokey){RELPROrec1}
         >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [PERSPRO, INDEFPRO]
      >


      COMP
         <
          C1: (NPrec1.genders *[mascgender, femgender] <> [] ) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Nominative, Dative, Accusative] <> [] )

          A1: @
         >

      DECOMP
         <
          C1: (NPrec1.genders *[mascgender, femgender] <> [] )
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >

   SUBRULE  (* dierelpro, no comma *)
      < T2: T3>
      < sig1: []
        sig2: []
        T2: T3
        T1:RELPRO(KEY_dierelprokey){RELPROrec1}
      >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [PERSPRO, INDEFPRO]
      >

         (* no COMP part *)

      DECOMP
         <
          C1: (NPrec1.genders *[mascgender, femgender] <> [] )
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >

   SUBRULE  (* datrelpro, one comma *)
      < T2: INDEFPRO{INDEFPROrec1}[mu6]>
      < sig1: []
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: INDEFPRO{INDEFPROrec1}[mu6]
        T1:RELPRO(KEY_datrelprokey){RELPROrec1}
      >


      COMP
         <
          C1: (NPrec1.genders = [neutgender] ) AND
              (NPrec1.animate = noanimate) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Nominative, Dative, Accusative] <> [] )

          A1: @
         >

      DECOMP
         <
          C1: (NPrec1.genders = [neutgender] ) AND
              (NPrec1.animate = noanimate)
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >


   SUBRULE  (* watbwhpro, one comma *)
      < T2: INDEFPRO{INDEFPROrec1}[mu6]>
      < sig1: []
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: INDEFPRO{INDEFPROrec1}[mu6]
        T1:BWHPRO(KEY_watwhprokey){BWHPROrec1}
      >


      COMP
         <
          C1: (NPrec1.genders = [neutgender] ) AND
              (NPrec1.animate = noanimate) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Nominative, Dative, Accusative] <> [] )

          A1: @
         >

      DECOMP
         <
          C1: (NPrec1.genders = [neutgender] ) AND
              (NPrec1.animate = noanimate)
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >

   SUBRULE  (* datrelpro, no comma *)
      < T2: INDEFPRO{INDEFPROrec1}[mu6]>
      < sig1: []
        sig2: []
        T2: INDEFPRO{INDEFPROrec1}[mu6]
        T1:RELPRO(KEY_datrelprokey){RELPROrec1}
      >

         (* no COMP part *)

      DECOMP
         <
          C1: (NPrec1.genders = [neutgender] ) AND
              (NPrec1.animate = noanimate)
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >

   SUBRULE  (* watbwhpro, no comma *)
      < T2: INDEFPRO{INDEFPROrec1}[mu6]>
      < sig1: []
        sig2: []
        T2: INDEFPRO{INDEFPROrec1}[mu6]
        T1:BWHPRO(KEY_watwhprokey){BWHPROrec1}
      >

         (* no COMP part *)

      DECOMP
         <
          C1: (NPrec1.genders = [neutgender] ) AND
              (NPrec1.animate = noanimate)
          A1: NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Nominative, Accusative, Dative];
         >


   SUBRULE  (* PROPERNOUN antecedent, waar; two comma's *)

      < T2: PROPERNOUN{PROPERNOUNrec1}[mu6]>
        T4: RADVP{RADVPrec1}[head/NPVAR{NPVARrec1}]
      >
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: PROPERNOUN{PROPERNOUNrec1}[mu6]
        T1: RADVP{RADVPrec2}[head/RADV(KEY_waarradvkey){RADVrec1}]
      >

      COMP
         <
          C1: lk IN RADVPrec1.kindefs AND
              RADVPrec1.radvkey = KEY_waarRADVkey AND              
              RADVPrec1.mood = declxpmood AND
              (NPrec1.genders *[mascgender, femgender] <> [] ) AND
              (NPrec1.human = nohuman) (* in COMP only *) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Rcase] <> [] ) 

          A1: RADVPrec2 := RADVPrec1;
              RADVPrec2.mood := wh;
         >

      DECOMP
         <
          C1: RADVPrec2 = 
                        {
                         mood    : wh
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         } AND
              (NPrec1.genders *[mascgender, femgender] <> [] )


          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.mood := declxpmood;
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Rcase];
         >

   SUBRULE  (* INDEFPRO/DEMPRO antecedent, waar; one comma *)

      < T2: T3
        T4: RADVP{RADVPrec1}[head/NPVAR{NPVARrec1}]
      >
      < sig1: []
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: T3
        T1: RADVP{RADVPrec2}[head/RADV(KEY_waarradvkey){RADVrec1}]
      >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [DEMPRO, INDEFPRO]
      >


      COMP
         <
          C1: lk IN RADVPrec1.kindefs AND
              RADVPrec1.radvkey = KEY_waarRADVkey AND              
              RADVPrec1.mood = declxpmood AND
              (NPrec1.human = nohuman) (* in COMP only *) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Rcase] <> [] ) 

          A1: RADVPrec2 := RADVPrec1;
              RADVPrec2.mood := wh;
         >
      DECOMP
         <
          C1: RADVPrec2 = 
                        {
                         mood    : wh
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         }

          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.mood := declxpmood;
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Rcase];
         >

   SUBRULE  (*  INDEFPRO/DEMPRO antecedent, waar; no comma *)
      < T2: T3
        T4: RADVP{RADVPrec1}[head/NPVAR{NPVARrec1}]
      >
      < sig1: []
        sig2: []
        T2: T3
        T1: RADVP{RADVPrec2}[head/RADV(KEY_waarradvkey){RADVrec1}]
      >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [DEMPRO, INDEFPRO]
      >

         (* no COMP part *)

      DECOMP
         <
          C1: RADVPrec2 = 
                        {
                         mood    : wh
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         }

          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.mood := declxpmood;
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Rcase];
         >


SUBRULE  (* PROPERNOUN antecedent, WIE relative; two comma's *)

      < T2: PROPERNOUN{PROPERNOUNrec1}[mu6]
        T4: VARPREPP{VARPREPPrec1}
                     [head/PREP{PREPrec1},
                      objrel/NPVAR{NPVARrec1}
                     ]
      >
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: PROPERNOUN{PROPERNOUNrec1}[mu6]
        T1: PREPP{PREPPrec1}
                 [head/PREP{PREPrec1},
                  objrel/NP{NPrec1}[head/WHPRO{WHPROrec1}
                         [head/I5::BWHPRO{BWHPROrec1}]
                         ]
                 ]
      >
   MATCHCONDITIONS
      <
       I5: BWHPROrec1.key = 10152 (* wiebwhpro *)
      >

      COMP
         <
          C1: (NPrec1.human = yeshuman)  AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [dative, accusative] <> [] ) 

          A1: PREPPrec1 := VARPREPPrec1;
              PREPPrec1.mood := wh;
              WHPROrec1 := COPYT_BWHPROtoWHPRO(BWHPROrec1);
              NPrec1 := 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [dative, accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                  }
         >

       DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              WHPROrec1 = COPYT_BWHPROtoWHPRO(BWHPROrec1) AND
              NPrec1 = 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [dative, accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                  }
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [dative, accusative];
         >

SUBRULE  (* INDEFPRO/PERSPRO antecedent, WIE relative; one comma *)
      < T2: T3
        T4: VARPREPP{VARPREPPrec1}
                     [head/PREP{PREPrec1},
                      objrel/NPVAR{NPVARrec1}
                     ]
      >
      < sig1: []
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: T3
        T1: PREPP{PREPPrec1}
                 [head/PREP{PREPrec1},
                  objrel/NP{NPrec1}[head/WHPRO{WHPROrec1}
                         [head/I5::BWHPRO{BWHPROrec1}]
                         ]
                 ]
      >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [PERSPRO, INDEFPRO]
      >

      COMP
         <
          C1: (NPrec1.human = yeshuman)  AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [dative, accusative] <> [] ) 

          A1: PREPPrec1 := VARPREPPrec1;
              PREPPrec1.mood := wh;
              WHPROrec1 := COPYT_BWHPROtoWHPRO(BWHPROrec1);
              NPrec1 := 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [dative, accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                  }
         >

       DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              WHPROrec1 = COPYT_BWHPROtoWHPRO(BWHPROrec1) AND
              NPrec1 = 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [dative, accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                  }
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [dative, accusative];
         >

   SUBRULE  (*  INDEFPRO/PERSPRO antecedent, WIE relative; no comma *)
      < T2: T3
        T4: VARPREPP{VARPREPPrec1}
                     [head/PREP{PREPrec1},
                      objrel/NPVAR{NPVARrec1}
                     ]
      >
      < sig1: []
        sig2: []
        T2: T3
        T1: PREPP{PREPPrec1}
                 [head/PREP{PREPrec1},
                  objrel/NP{NPrec1}[head/WHPRO{WHPROrec1}
                         [head/I5::BWHPRO{BWHPROrec1}]
                         ]
                 ]
      >
   
   MATCHCONDITIONS
      <
       T2: T3.CAT IN [PERSPRO, INDEFPRO]
      >

         (* no COMP part *)

       DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              WHPROrec1 = COPYT_BWHPROtoWHPRO(BWHPROrec1) AND
              NPrec1 = 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [dative, accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                  }
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [dative, accusative];
         >

>
&


\end{verbatim}
\newpage
\begin{description}
\item[* name:] RnonCNmodRELSENT1
\item[* some relevant examples:] 
original noncnmodrelsent1:
Jan  + [x2 is nooit ziek ] $\rightarrow$ [Jan, [die nooit ziek is],]\\
iemand + [x2 is ziek] $\rightarrow$ [iemand [die ziek is ],]
iets + [x2 is lekker] $\rightarrow$ [iets [wat lekker is ],]

original noncnmodrelsent2:
iets waarvan ik wekelijks droom

original noncnmodrelsent3:
iets waar ik van droom

original noncnmodrelsent5:
iemand van wie ik droom

\item[* language:] (Dutch, English, Spanish) Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] NP-subgrammar
\item[* class:] (name of rule, transformation or filter class) modrules
\item[* date of creation:] 27-SEP-1988 11:57:36  
\item[* author:] Franciska de Jong
\item[* copied from:] --
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] Modification 
of a non-CN by a restrictive, finite, relative SENTENCE.
Present rule replaces the original noncnmodrelsent1-5. Cf. examples.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:] In analysis the absence 
of a comma behind the  relative sentence \'{i}s accepted, but in generation
a comma is always generated. 
\item[\  \ suggested semantics:] 
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\
\item modifications:\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
 RULE RnonCNmodRELSENT2
< SUBST:
  m1: NP{NPrec1}[I1:head/T2]                 (* substituent *)
  m2: I2::SENTENCE{SENTENCErec1}
              [ shiftrel/VARPREPP{VARPREPPrec1}
                         [errel/RADVP{RADVPrec1}[head/NPVAR{NPVARrec1}],
                          gluerel/GLUE{},
                          head/PREP{PREPrec1}
                         ],
                mu2 
              ] 

>

< m :  NP{NPrec1}[I1:head/T2,
                  I3:sig1,
                  postmodrel/I2::SENTENCE{SENTENCErec1}
	                [ shiftrel/PREPP{PREPPrec1}
                                [errel/RADV(KEY_waarradvkey){RADVrec1},
                                 gluerel/GLUE{},
                                 head/PREP{PREPrec1}
                                ],
                          mu2 
			],
                  I4:sig2
                ]
>

   MATCHCONDITIONS
      <
       I1: T2.CAT IN [PROPERNOUN, INDEFPRO, DEMPRO]
       I2: SENTENCErec1 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : finite
                 }
       I3: ALL(sig1, puncrel/PUNC(KEY_kommapunckey){PUNCrec3})
       I4: ALL(sig2, puncrel/PUNC(KEY_kommapunckey){PUNCrec4})
      >


   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE  (* PROPERNOUN, two comma 's*)

      < T2: PROPERNOUN{PROPERNOUNrec1}[mu6]>
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: PROPERNOUN{PROPERNOUNrec1}[mu6]                
      >

      COMP
         <
          C1: lk IN RADVPrec1.kindefs AND
              RADVPrec1.radvkey = KEY_waarRADVkey AND              
              (NPrec1.genders *[mascgender, femgender] <> [] ) AND
              (NPrec1.human = nohuman) (* in COMP only *) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Rcase] <> [] ) 
          A1: PREPPrec1 := VARPREPPrec1;
              PREPPrec1.mood := wh;
         >


      DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              (NPrec1.genders *[mascgender, femgender] <> [] )
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              RADVPrec1 := 
                        {
                         mood    : declxpmood
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         };
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Rcase];
         >


   SUBRULE  (* INDEFPRO/DEMPRO, one comma *)

      < T2: T3>
      < sig1: []
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: T3
      >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [DEMPRO, INDEFPRO]
      >


      COMP
         <
          C1: lk IN RADVPrec1.kindefs AND
              RADVPrec1.radvkey = KEY_waarRADVkey AND              
              (NPrec1.human = nohuman) (* in COMP only *) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Rcase] <> [] ) 
          A1: PREPPrec1 := VARPREPPrec1;
              PREPPrec1.mood := wh;
         >

      DECOMP
         <
          C1: PREPPrec1.mood  = wh 
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              RADVPrec1 := 
                        {
                         mood    : declxpmood
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         };
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Rcase];
         >

   SUBRULE  (*  INDEFPRO/DEMPRO, no comma *)
      < T2: T3>
      < sig1: []
        sig2: []
        T2: T3
      >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [DEMPRO, INDEFPRO]
      >


         (* no COMP part *)

      DECOMP
         <
          C1: PREPPrec1.mood  = wh 
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              RADVPrec1 := 
                        {
                         mood    : declxpmood
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         };
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Rcase];
         >

>

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RnonCNmodRELSENT2
\item[* relevant examples:] iets waarvan ik wekelijks droom
\item[* language:] Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 23-SEP-1988 11:36:19  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] to substitue NPVAR in VARPREPP by NP; 
in relsent RADV takes the place of NPVAR.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In addition to {\em iemand van wie ik droom}, 
{\em iemand waarvan ik droom} is accepted in analysis, but only the former
will be  generated;
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
 RULE RnonCNmodRELSENT3
< SUBST:
  m1: NP{NPrec1}[I1:head/T2]                 (* substituent *)
  m2: I2::SENTENCE{SENTENCErec1}
              [ shiftrel/RADVP{RADVPrec1}
                         [head/NPVAR{NPVARrec1}],
                mu2 
              ] 
>

< m :  NP{NPrec1}[I1:head/T2,
                  I3:sig1,
                  postmodrel/I2::SENTENCE{SENTENCErec1}
	                [ shiftrel/RADVP{RADVPrec2}
                                   [head/RADV(KEY_waarradvkey){RADVrec1}],
                          mu2 
			],
                  I4:sig2
                ]
>

MATCHCONDITIONS
      <
       I1: T2.CAT IN [PROPERNOUN, INDEFPRO, DEMPRO]
       I2: SENTENCErec1 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : finite
                 }
       I3: ALL(sig1, puncrel/PUNC(KEY_kommapunckey){PUNCrec3})
       I4: ALL(sig2, puncrel/PUNC(KEY_kommapunckey){PUNCrec4})
      >


   PARAMETERS
      <
       LEVEL
      >

<

   SUBRULE  (* PROPERNOUN, two comma's *)

      < T2: PROPERNOUN{PROPERNOUNrec1}[mu6]>
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: PROPERNOUN{PROPERNOUNrec1}[mu6]
      >

      COMP
         <
          C1: lk IN RADVPrec1.kindefs AND
              RADVPrec1.radvkey = KEY_waarRADVkey AND              
              RADVPrec1.mood = declxpmood AND
              (NPrec1.genders *[mascgender, femgender] <> [] ) AND
              (NPrec1.human = nohuman) (* in COMP only *) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Rcase] <> [] ) 

          A1: RADVPrec2 := RADVPrec1;
              RADVPrec2.mood := wh;
         >

      DECOMP
         <
          C1: RADVPrec2 = 
                        {
                         mood    : wh
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         } AND
              (NPrec1.genders *[mascgender, femgender] <> [] )


          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.mood := declxpmood;
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Rcase];
         >

   SUBRULE  (* INDEFPRO/DEMPRO, one comma *)

      < T2: T3>
      < sig1: []
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: T3
      >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [DEMPRO, INDEFPRO]
      >


      COMP
         <
          C1: lk IN RADVPrec1.kindefs AND
              RADVPrec1.radvkey = KEY_waarRADVkey AND              
              RADVPrec1.mood = declxpmood AND
              (NPrec1.human = nohuman) (* in COMP only *) AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [Rcase] <> [] ) 

          A1: RADVPrec2 := RADVPrec1;
              RADVPrec2.mood := wh;
         >
      DECOMP
         <
          C1: RADVPrec2 = 
                        {
                         mood    : wh
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         }

          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.mood := declxpmood;
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Rcase];
         >

   SUBRULE  (*  INDEFPRO/DEMPRO, no comma *)
      < T2: T3>
      < sig1: []
        sig2: []
        T2: T3
      >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [DEMPRO, INDEFPRO]
      >

         (* no COMP part *)

      DECOMP
         <
          C1: RADVPrec2 = 
                        {
                         mood    : wh
                         kindefs : [lk]
                         radvkey : RADVrec1.key
                         }

          A1: RADVPrec1 := RADVPrec2;
              RADVPrec1.mood := declxpmood;
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [Rcase];
         >
>

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RCNmodRELSENT3
\item[* relevant examples:] iets waar ik van droom
\item[* language:] Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 23-SEP-1988 11:36:19  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] to substitue CNVAR in RADVP by CN; in relsent RADV takes 
the place of CNVAR.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In addition to {\em de man van wie ik droom}, 
{\em de man waar ik van droom} is accepted in analysis, but only the former
will be  generated;
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}
\newpage
\begin{verbatim}
 RULE RnonCNmodRELSENT5  
< SUBST:
  m1: NP{NPrec1}[I1:head/T2]                 (* substituent *)
  m2: I2::SENTENCE{SENTENCErec1}
              [ shiftrel/VARPREPP{VARPREPPrec1}
                         [head/PREP{PREPrec1},
                          objrel/NPVAR{NPVARrec1}
                         ],
                mu2 
              ] 
>

< m :  NP{NPrec1}[I1:head/T2,
                  I3:sig1,
                  postmodrel/I2::SENTENCE{SENTENCErec1}
	                [ shiftrel/PREPP{PREPPrec1}
                                [head/PREP{PREPrec1},
                                 objrel/NP{NPrec1}[head/WHPRO{WHPROrec1}
                                                     [head/
                                                         I5::BWHPRO{BWHPROrec1}]
                                                  ]
                                ],
                          mu2 
			],
                  I4:sig2
                ]
>

MATCHCONDITIONS
      <
       I1: T2.CAT IN [PROPERNOUN, INDEFPRO, PERSPRO]
       I2: SENTENCErec1 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : finite
                 }
       I3: ALL(sig1, puncrel/PUNC(KEY_kommapunckey){PUNCrec3})
       I4: ALL(sig2, puncrel/PUNC(KEY_kommapunckey){PUNCrec4})
       I5: BWHPROrec1.key = 10152 (* wiebwhpro *)
      >


   PARAMETERS
      <
       LEVEL
      >

<
SUBRULE  (* PROPERNOUN, two comma's *)

      < T2: PROPERNOUN{PROPERNOUNrec1}[mu6]>
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: PROPERNOUN{PROPERNOUNrec1}[mu6]
      >

      COMP
         <
          C1: (NPrec1.human = yeshuman)  AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [dative, accusative] <> [] ) 

          A1: PREPPrec1 := VARPREPPrec1;
              PREPPrec1.mood := wh;
              WHPROrec1 := COPYT_BWHPROtoWHPRO(BWHPROrec1);
              NPrec1 := 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [dative, accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                  }
         >

       DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              WHPROrec1 = COPYT_BWHPROtoWHPRO(BWHPROrec1) AND
              NPrec1 = 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [dative, accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                  }
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [dative, accusative];
         >

SUBRULE  (* INDEFPRO/PERSPRO, one comma *)

      < T2: T3>
      < sig1: []
        sig2: [puncrel/PUNC(KEY_kommapunckey){PUNCrec2}]
        T2: T3
      >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [PERSPRO, INDEFPRO]
      >

      COMP
         <
          C1: (NPrec1.human = yeshuman)  AND
              (NPVARrec1.index = LEVEL ) AND
              (NPVARrec1 = COPYT_NPTOVAR(NPrec1) EXCEPT FOR [cases] ) AND
              (NPVARrec1.cases * [dative, accusative] <> [] ) 

          A1: PREPPrec1 := VARPREPPrec1;
              PREPPrec1.mood := wh;
              WHPROrec1 := COPYT_BWHPROtoWHPRO(BWHPROrec1);
              NPrec1 := 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [dative, accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                  }
         >

       DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              WHPROrec1 = COPYT_BWHPROtoWHPRO(BWHPROrec1) AND
              NPrec1 = 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [dative, accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                  }
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [dative, accusative];
         >

   SUBRULE  (*  INDEFPRO/PERSPRO, no comma *)
      < T2: T3>
      < sig1: []
        sig2: []
        T2: T3
      >

   MATCHCONDITIONS
      <
       T2: T3.CAT IN [PERSPRO, INDEFPRO]
      >

         (* no COMP part *)

       DECOMP
         <
          C1: PREPPrec1.mood  = wh AND
              WHPROrec1 = COPYT_BWHPROtoWHPRO(BWHPROrec1) AND
              NPrec1 = 
                    {
                     definite       : indef
                     number         : WHPROrec1.number  
                     cases          : [dative, accusative]
                     sexes          : WHPROrec1.sexes
                     animate        : WHPROrec1.animate
                     human          : yeshuman
                     mood           : wh
                     generic        : omegageneric
                     possRform      : WHPROrec1.possRform
                     syntquant      : omegaquant
                     specq          : yesspec
                  }
          A1: VARPREPPrec1 := PREPPrec1;
              VARPREPPrec1.mood := declxpmood;
              NPVARrec1 := COPYT_NPTOVAR(NPrec1);
              NPVARrec1.index := LEVEL;
              NPVARrec1.cases := [dative, accusative];
         >

>

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RCNnonmodRELSENT5
\item[* relevant examples:] iemand van wie ik droom
\item[* language:] Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 23-SEP-1988 11:36:19  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: ../../..\ \ \ \ \ author:
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] to substitue CNVAR met .human = yeshuman in VARPREPP by CN; 
in relsent WHPRO takes the place of CNVAR.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:\\

\end{enumerate}
\end{description}

BIGPRO moet nog weg (in een speciale controle regel;
independent/dependent in laatste subregel klopt nog niet overleg met Lisette)

% RULE RCNmodinfrel
< SUBST:
  m1: CN{CNrec1}[I1:mu1]                 (* substituent *)
  m2: I2::SENTENCE{SENTENCErec1}
              [ shiftrel/T1,
                I5:mu2 
              ] 


>

< m : CN{CNrec2}[ I1:mu1, 
                  postmodrel/I4::SENTENCE{SENTENCErec2}
	                [ I5:mu2 
			],
                  I3:sig1 
                ]
>

   MATCHCONDITIONS
      <
       I1: NOT EXIST(mu1,[head/EN{ENrec1}])
       I2: SENTENCErec1 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : infinite
                 }
       I3: ALL(sig1, puncrel/PUNC(KEY_kommapunckey){PUNCrec2})
       I4: SENTENCErec2 =
                 { mood        : relative
                   senttype    : subordinateclause
                   finiteness  : infinite
                 }
       I5: NOT EXIST(mu2,[shiftrel/..])
      >



   PARAMETERS
      <
       LEVEL
      >

<
   SUBRULE  (* CNVAR omCONJ, comma *)
      < T1: CNVAR{CNVARrec1}>
      < sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
      >

      (* No COMP part *)

      DECOMP
         <
          C1: true
              C11: (* temporally independent *)
                   SENTENCErec2.superdeixis = omegadeixis AND
                   SENTENCErec2.deixis = omegadeixis      AND
                   (NOT QUOTE_temprefnotfound(mu2))       
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = omegadeixis)      AND
                    (QUOTE_temprefnotfound(mu2))
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
          A1: CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Nominative, Accusative, Dative];
              CNrec1 := CNrec2;

         >

   SUBRULE  (* om , no comma *)
      < T1: CNVAR{CNVARrec1}>
      < sig1: []
      >

      COMP
         <
          C1: CNVARrec1.index = LEVEL  AND
              CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases]  AND
              CNVARrec1.cases * [Nominative, Dative, Accusative] <> [] 
              C11: (* temporally independent *)
                   SENTENCErec1.superdeixis = omegadeixis AND
                   SENTENCErec1.deixis = omegadeixis    AND
                   (NOT QUOTE_temprefnotfound(mu2))       
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   SENTENCErec1.deixis = omegadeixis                AND
                   SENTENCErec1.superdeixis = CNrec1.superdeixis    AND
                   (QUOTE_temprefnotfound(mu2))
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.superdeixis := omegadeixis;
          A1: CNrec2 := CNrec1;
              CNrec2.possgeni := false;

         >


      DECOMP
         <
          C1: true (* CNrec2.possgeni= false; via TCNnounposs *)
              C11: (* temporally independent *)
                   SENTENCErec2.superdeixis = omegadeixis AND
                   SENTENCErec2.deixis = omegadeixis      AND
                   (NOT QUOTE_temprefnotfound(mu2))       
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = omegadeixis)      AND
                    (QUOTE_temprefnotfound(mu2))
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
          A1: CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Nominative, Accusative, Dative];
              CNrec1 := CNrec2;

         >

   SUBRULE  (* RADVP .... PREP (waar .... van); comma *)

       <       
        T1: RADVP{RADVPrec1}[head/CNVAR{CNVARrec1}]
       >       
       <       
        sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
       >       

      (* No COMP part *)


      DECOMP
         <
          C1: true
              C11: (* temporally independent *)
                   SENTENCErec2.superdeixis = omegadeixis AND
                   SENTENCErec2.deixis = omegadeixis      AND
                   (NOT QUOTE_temprefnotfound(mu2))       
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = omegadeixis)      AND
                    QUOTE_temprefnotfound(mu2)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
          A1: RADVPrec1 :=
                {
                  mood    : declxpmood
                  radvkey : 0
                  kindefs : [Pk]
                };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;

         >

   SUBRULE  (* RADVP .... PREP (waar .... van); no comma *)

       <
       T1: RADVP{RADVPrec1}[head/CNVAR{CNVARrec1}]
       >
       <
       sig1: []
       >

      COMP
         <
          C1: pk IN RADVPrec1.kindefs AND
              RADVPrec1.radvkey = 0 AND              
              RADVPrec1.mood = declxpmood AND
              (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              (CNVARrec1.cases * [Rcase] <> [] )
              C11: (* temporally independent *)
                   SENTENCErec1.superdeixis = omegadeixis AND
                   SENTENCErec1.deixis = omegadeixis    AND
                   (NOT QUOTE_temprefnotfound(mu2))       
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   SENTENCErec1.deixis = omegadeixis                AND
                   SENTENCErec1.superdeixis = CNrec1.superdeixis    AND
                   (QUOTE_temprefnotfound(mu2))
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.superdeixis := omegadeixis;
          A1: CNrec2 := CNrec1;
              CNrec2.possgeni := false;
         >
      DECOMP
         <
          C1: true (* CNrec2.possgeni= false; via TCNnounposs *)
              C11: (* temporally independent *)
                   SENTENCErec2.superdeixis = omegadeixis AND
                   SENTENCErec2.deixis = omegadeixis      AND
                   (NOT QUOTE_temprefnotfound(mu2))       
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = omegadeixis)      AND
                    QUOTE_temprefnotfound(mu2)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
          A1: RADVPrec1 := 
                 {
                   mood    : declxpmood
                   kindefs : [Pk]
                   radvkey : 0
                 };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Rcase];
              CNrec1 := CNrec2;

         >

   SUBRULE  (* RADVP (waar); comma *)

       <
       T1: VARPREPP{VARPREPPrec1}
                    [ head/PREP(KEY_inprepkey){PREPrec1},
                      objrel/CNVAR{CNVARrec1}
                    ]
       >
       <
       sig1: [puncrel/PUNC(KEY_kommapunckey){PUNCrec1}]
       >

      (* No COMP part *)


      DECOMP
         <
          C1: true
              C11: (* temporally independent *)
                   SENTENCErec2.superdeixis = omegadeixis AND
                   SENTENCErec2.deixis = omegadeixis      AND
                   (NOT QUOTE_temprefnotfound(mu2))       
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = omegadeixis)      AND
                    QUOTE_temprefnotfound(mu2)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
          A1:
              VARPREPPrec1:= 
                 {
                   mood:              relativexpmood
                   actsubcefs:        PREPrec1.subcs
                   synppefs:          PREPrec1.synpps
                   thetapp:           PREPrec1.thetapp 
                   headkey:           PREPrec1.key
                   class:             PREPrec1.class
                   deixis:            PREPrec1.deixis
                   aspect:            PREPrec1.aspect
                   retro:             PREPrec1.retro

                   radvkey:           0
                   specQ:             yesspec
                 };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [accusative];
              CNrec1 := CNrec2;
         >


   SUBRULE  (* RADVP (waar); no comma *)

       <
       T1: VARPREPP{VARPREPPrec1}
                    [ head/PREP(KEY_inprepkey){PREPrec1},
                      objrel/CNVAR{CNVARrec1}
                    ]
       >
       <
       sig1: []
       >



      COMP
         <
          C1: VARPREPPrec1 = 
                 {
                   mood:              relativexpmood
                   actsubcefs:        PREPrec1.subcs
                   thetapp:           PREPrec1.thetapp 
                   headkey:           PREPrec1.key
                   class:             PREPrec1.class
                   deixis:            PREPrec1.deixis
                   aspect:            PREPrec1.aspect
                   retro:             PREPrec1.retro

                   radvkey:           0
                   specQ:             yesspec
                }  AND
              VARPREPPrec1.synppefs * PREPrec1.synpps <> [] AND
              (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              (CNVARrec1.human <> yeshuman) (* only in COMP *)  AND
              (CNVARrec1.cases * [Accusative] <> [] )
              C11: (* temporally independent *)
                   SENTENCErec1.superdeixis = omegadeixis AND
                   SENTENCErec1.deixis = omegadeixis    AND
                   (NOT QUOTE_temprefnotfound(mu2))       
              A11: SENTENCErec2 := SENTENCErec1;
              C12: (* temporally dependent *)
                   SENTENCErec1.deixis = omegadeixis                AND
                   SENTENCErec1.superdeixis = CNrec1.superdeixis    AND
                   (QUOTE_temprefnotfound(mu2))
              A12: SENTENCErec2 := SENTENCErec1;
                   SENTENCErec2.superdeixis := omegadeixis;
          A1: CNrec2 := CNrec1;
              CNrec2.possgeni := false;
         >

      DECOMP
         <
          C1: true (* CNrec2.possgeni= false; via TCNnounposs *)
              C11: (* temporally independent *)
                   SENTENCErec2.superdeixis = omegadeixis AND
                   SENTENCErec2.deixis = omegadeixis      AND
                   (NOT QUOTE_temprefnotfound(mu2))       
               A11: SENTENCErec1 := SENTENCErec2;
               C12: (SENTENCErec2.superdeixis = omegadeixis) AND
                    (SENTENCErec2.deixis = omegadeixis)      AND
                    QUOTE_temprefnotfound(mu2)
               A12: SENTENCerec1 := SENTENCErec2;
                    SENTENCErec1.superdeixis := CNrec2.superdeixis;
          A1: 
              VARPREPPrec1:= 
                 {
                   mood:              relativexpmood
                   actsubcefs:        PREPrec1.subcs
                   synppefs:          PREPrec1.synpps
                   thetapp:           PREPrec1.thetapp 
                   headkey:           PREPrec1.key
                   class:             PREPrec1.class
                   deixis:            PREPrec1.deixis
                   aspect:            PREPrec1.aspect
                   retro:             PREPrec1.retro

                   radvkey:           0
                   specQ:             yesspec
                 };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Accusative];
              CNrec1 := CNrec2;
         >


   
   SUBRULE  (* de dag om te komen; no comma *)

       <
       T1: VARPREPP{VARPREPPrec1}
                    [ head/PREP(KEY_'s_prep1243607'){PREPrec1},
                      objrel/CNVAR{CNVARrec1}
                    ]
       >
       <
       sig1: []
       >



      COMP
         <
          C1: VARPREPPrec1 = 
                 {
                   mood:              relativexpmood
                   actsubcefs:        PREPrec1.subcs
                   thetapp:           PREPrec1.thetapp 
                   headkey:           PREPrec1.key
                   class:             PREPrec1.class
                   deixis:            PREPrec1.deixis
                   aspect:            PREPrec1.aspect
                   retro:             PREPrec1.retro

                   radvkey:           0
                   specQ:             yesspec
                }  AND
              VARPREPPrec1.synppefs * PREPrec1.synpps <> [] AND
              (CNVARrec1.index = LEVEL ) AND
              (CNVARrec1 = COPYT_CNTOVAR(CNrec1) EXCEPT FOR [cases] ) AND
              (CNrec1.temporal = true) AND
              (CNVARrec1.cases * [Accusative] <> [] )
              C11: (* temporally independent *)
                   SENTENCErec1.superdeixis = omegadeixis AND
                   SENTENCErec1.deixis = omegadeixis    
              A11: SENTENCErec2 := SENTENCErec1;
          A1: CNrec2 := CNrec1;
              CNrec2.possgeni := false;

         >

      DECOMP
         <
          C1: CNrec2.temporal = true 
           (* CNrec2.possgeni= false; via TCNnounposs *)
              C11: (* temporally independent *)
                   SENTENCErec2.superdeixis = omegadeixis AND
                   SENTENCErec2.deixis = omegadeixis      
               A11: SENTENCErec1 := SENTENCErec2;
          A1: 
              VARPREPPrec1:= 
                 {
                   mood:              relativexpmood
                   actsubcefs:        PREPrec1.subcs
                   synppefs:          PREPrec1.synpps
                   thetapp:           PREPrec1.thetapp 
                   headkey:           PREPrec1.key
                   class:             PREPrec1.class
                   deixis:            PREPrec1.deixis
                   aspect:            PREPrec1.aspect
                   retro:             PREPrec1.retro

                   radvkey:           0
                   specQ:             yesspec
                 };
              CNVARrec1 := COPYT_CNTOVAR(CNrec2);
              CNVARrec1.index := LEVEL;
              CNVARrec1.cases := [Accusative];
              CNrec1 := CNrec2;

         >


>

&

\end{verbatim}
\newpage
\begin{description}
\item[* name:] RCNmodInfrel
\item[* relevant examples:]  
de boeken om te lezen (liggen op tafel);
de auto's om mee te spelen (liggen op tafel)
de plaats om te wonen is A'dam
de dag om te komen is woensdag
\item[* language:] Dutch
\item[* kind of rule:] (M-rule, S-rule, Transferrule) M-rule
\item[* subgrammar:] 
\item[* class:] (name of rule, transformation or filter class)
\item[* date of creation:] 23-SEP-1988 11:36:19  
\item[* author:] Franciska de Jong
\item[* copied from:]
\item[* modification:]\mbox{}
\begin{enumerate}
\item date: 31/10/88\ \ \ \ \ author: Lisette Appelo
\item date: ../../..\ \ \ \ \ author:
\end{enumerate}
\item[* task:] to substitue CNVAR in sentences by CN; 
Subrules have taken over the role of the original modrelsent1-5. 
Cf. the examples.
\item[\ \ strategy:] (also: deviations from accepted proposals)
\item[\ \ rejected alternatives:]
\item[\ \ clarification of variables:]
\item[\ \ clarification of the splitting up into subrules:]
\item[\ \ clarification of the collapsing of rules:] (e.g. clarification of parameters)
\item[\ \ differences analytical/generative version:]
In addition to {\em de man van wie ik droom}, 
{\em de man waarvan ik droom} is accepted in analysis, but only the former
will be  generated;
\item[\  \ suggested semantics:]
\item[\ \ presuppositions:]\mbox{}
\begin{enumerate}
\item dictionary:\\

\item rules:\\

\end{enumerate}
\item[\ \ consequences in the grammar:]
\item[\ \ translation aspects:]\mbox{}
\begin{enumerate} 
\item within this language:\\

\item in other languages:\\

\end{enumerate}
\item[* relevant literature/documents:]
\item[\ \ remarks:]\mbox{}
\begin{enumerate}
\item problems:\\

\item modifications:31/10/88: Added superdeixis condition/actions. In the 
superdeixis case the deixis value for the relative clause is given a value in 
generation and set to omega in analysis. This is done for the surface parser. 
It is the same task as is carried out for complement sentences in the 
superdeixisadaptation transformations.\\

\end{enumerate}
\end{description}


%%
E 2
E 1
